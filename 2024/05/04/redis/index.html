<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="Redis基础巩固, HyxiaoGe">
    <meta name="description" content="Redis 是一种高性能、基于内存的开源键值存储数据库系统，它主要用于缓存、会话管理和实时分析等用途。
关键特点
键值存储：Redis 以键值对的形式存储数据。每个键都是一个唯一的标识符，与一个值相关联。
基于内存存储：Redis 所有的数">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="referrer" content="no-referrer-when-downgrade">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    <title>Redis基础巩固 | HyxiaoGe</title>
    <link rel="icon" type="image/png" href="/favicon.png">
    
    <style>
        body{
            background-image: url(http://sv6693ki5.hn-bkt.clouddn.com/background/bg.jpg);
            background-repeat:no-repeat;
            background-size: 100% 100%;
            background-attachment:fixed;
        }
    </style>



    <!-- bg-cover style     -->



<link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.min.css">
<link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
<link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
<link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
<link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
<link rel="stylesheet" type="text/css" href="/css/matery.css">
<link rel="stylesheet" type="text/css" href="/css/my.css">
<link rel="stylesheet" type="text/css" href="/css/dark.css" media="none" onload="if(media!='all')media='all'">




    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
    <link rel="stylesheet" href="/css/post.css">




    



    <script src="/libs/jquery/jquery-3.6.0.min.js"></script>

<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="HyxiaoGe" type="application/atom+xml">
<link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"><script src="/js/prism.js"></script>
<script src="/js/prism-line-numbers.min.js"></script></head>


<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">HyxiaoGe</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/contact" class="waves-effect waves-light">
      
      <i class="fas fa-comments" style="zoom: 0.6;"></i>
      
      <span>留言板</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/friends" class="waves-effect waves-light">
      
      <i class="fas fa-address-book" style="zoom: 0.6;"></i>
      
      <span>友情链接</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
  <li>
    <a href="javascript:;" class="waves-effect waves-light" onclick="switchNightMode()" title="深色/浅色模式" >
      <i id="sum-moon-icon" class="fas fa-sun" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">HyxiaoGe</div>
        <div class="logo-desc">
            
            Never really desperate, only the lost of the soul.
            
        </div>
    </div>

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/contact" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-comments"></i>
			
			留言板
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/friends" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-address-book"></i>
			
			友情链接
		</a>
          
        </li>
        
        
    </ul>
</div>


        </div>

        
    </nav>

</header>

    



<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/10.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">Redis基础巩固</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/Redis/">
                                <span class="chip bg-color">Redis</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fas fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" class="post-category">
                                数据库
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2024-05-04
                </div>
                

                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-check fa-fw"></i>更新日期:&nbsp;&nbsp;
                    2025-07-28
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-file-word fa-fw"></i>文章字数:&nbsp;&nbsp;
                    9.8k
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-clock fa-fw"></i>阅读时长:&nbsp;&nbsp;
                    34 分
                </div>
                

                
                    <div id="busuanzi_container_page_pv" class="info-break-policy">
                        <i class="far fa-eye fa-fw"></i>阅读次数:&nbsp;&nbsp;
                        <span id="busuanzi_value_page_pv"></span>
                    </div>
				
            </div>
        </div>
        <hr class="clearfix">

        
        <!-- 是否加载使用自带的 prismjs. -->
        <link rel="stylesheet" href="/libs/prism/prism.min.css">
        

        

        <div class="card-content article-card-content">
            <div id="articleContent">
                <p>Redis 是一种高性能、基于内存的开源键值存储数据库系统，它主要用于<code>缓存</code>、<code>会话管理</code>和<code>实时分析</code>等用途。</p>
<h2 id="关键特点"><a href="#关键特点" class="headerlink" title="关键特点"></a>关键特点</h2><ol>
<li><strong>键值存储</strong>：Redis 以键值对的形式存储数据。每个键都是一个唯一的标识符，与一个值相关联。</li>
<li><strong>基于内存存储</strong>：Redis 所有的数据存储在内存中，这意味着它提供极高的读写速度，使得它非常适合用作缓存层，能够快速响应读取请求。</li>
<li><strong>持久性</strong>：Redis 支持数据持久性，可以将数据保存到磁盘上，以便在重启后恢复数据。</li>
<li><strong>多数据结构支持</strong>：Redis 支持各种数据结构，包括如字符串（string）、列表（list）、集合（set）、有序集合（sorted set）、哈希表（hash）、位图（bitmap）、超日志（hyperloglog）和地理空间索引（geospatial index）。等。这些数据结构可以用于不同的应用场景。</li>
<li><strong>发布-订阅模式</strong>：Redis 支持发布-订阅消息模式，允许客户端订阅特定的频道，从而实现高效的消息通信。这对于实现实时通信和事件驱动应用程序非常有用。</li>
<li><strong>事务</strong>：Redis 支持事务，可以一次执行多个命令，并保证这些命令在执行期间不会受到其他客户端的干扰。</li>
<li><strong>分布式和高可用性</strong>：通过使用哨兵（Sentinel）和集群，Redis 可以提供高可用性。哨兵用于监控 Redis 服务器的健康状况并自动执行故障转移。集群则提供数据分片和自动分区，以支持更大规模的数据存储。</li>
<li><strong>分片</strong>：Redis 支持数据分片，可以水平扩展存储容量和吞吐量。</li>
<li><strong>Lua脚本</strong>：Redis 允许使用 Lua 脚本执行高级操作，使得在服务器端可以进行复杂的逻辑，减少网络往返次数。</li>
<li><strong>社区支持</strong>：Redis 社区活跃，提供了许多扩展和插件，使其适用于各种不同的用例。</li>
</ol>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><ol>
<li>字符串（String）<ul>
<li><strong>结构</strong>：字符串是Redis最基本的数据类型。Redis中的字符串是二进制安全的，这意味着它们可以包含任何数据，比如JPEG图像或序列化对象。</li>
<li><strong>实现</strong>：字符串使用简单的<strong>动态字符串</strong>（SDS，Simple Dynamic String）实现，允许快速追加操作，与Java中的<code>StringBuffer</code>或<code>StringBuilder</code>类似，都支持动态修改，如追加、修改等操作，而不需要每次操作都创建一个新的字符串实例。</li>
</ul>
</li>
<li>列表（List）<ul>
<li><strong>结构</strong>：列表是字符串元素的集合，按插入顺序排序。</li>
<li><strong>实现</strong>：Redis列表用双向链表或压缩列表（ziplist）实现。较小的列表通常使用压缩列表以节省空间，而较大的列表则使用双向链表。</li>
</ul>
</li>
<li>集合（Set）<ul>
<li><strong>结构</strong>：集合是无序的字符串集合，每个元素都是唯一的。</li>
<li><strong>实现</strong>：小的集合使用压缩列表（ziplist）实现，较大的集合使用散列（hash table）实现。</li>
</ul>
</li>
<li>有序集合（Sorted Set）<ul>
<li><strong>结构</strong>：有序集合类似于集合，但每个元素都关联一个分数。这些元素按分数有序排列。</li>
<li><strong>实现</strong>：有序集合通过跳跃表（skiplist）和散列结构组合实现。跳跃表用于按分数排序和范围查询，而散列用于快速访问。</li>
</ul>
</li>
<li>哈希（Hash）<ul>
<li><strong>结构</strong>：哈希是键值对的集合，类似于Java中的HashMap或Python中的字典。</li>
<li><strong>实现</strong>：小的哈希使用压缩列表实现，大的哈希使用散列结构。</li>
</ul>
</li>
<li>位图（Bitmap）<ul>
<li><strong>结构</strong>：位图不是独立的数据类型，而是在字符串上操作单个位（binary digit）。</li>
<li><strong>实现</strong>：通过对字符串类型的特殊操作实现，允许设置和查询字符串值的特定位。</li>
</ul>
</li>
<li>HyperLogLog<ul>
<li><strong>结构</strong>：用于高效地执行基数计数（比如计算一个集合中不同元素的数量）。</li>
<li><strong>实现</strong>：使用近似算法，牺牲了精度以换取极高的空间效率。</li>
</ul>
</li>
<li>地理空间索引（Geospatial）<ul>
<li><strong>结构</strong>：用于存储地理位置信息，并进行各种地理相关的计算，如两点之间的距离。</li>
<li><strong>实现</strong>：基于有序集合，利用Z-order曲线在一维值中编码二维经纬度。</li>
</ul>
</li>
</ol>
<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><ol>
<li>缓存系统：<ul>
<li><strong>场景</strong>：减少数据库的负载，加速数据检索。</li>
<li><strong>实现</strong>：将经常查询的数据，如用户信息、商品详情等存储在 Redis 中。当数据被请求时，首先查询 Redis，如果找不到，再查询数据库，并将结果存回 Redis。</li>
</ul>
</li>
<li>会话存储（Session Store）：<ul>
<li><strong>场景</strong>：用于 Web 应用的用户会话管理。</li>
<li><strong>实现</strong>：将用户的会话信息存储在 Redis 中，由于 Redis 的读写速度快，可以快速处理大量并发的会话数据。</li>
</ul>
</li>
<li>消息队列：<ul>
<li><strong>场景</strong>：应用程序之间的消息传递和异步处理。</li>
<li><strong>实现</strong>：使用 Redis 的发布&#x2F;订阅功能或列表结构实现消息队列，支持生产者-消费者模型，实现数据的异步处理。</li>
</ul>
</li>
<li>排行榜&#x2F;计数器：<ul>
<li><strong>场景</strong>：用于实现社交网络、游戏等应用的排行榜功能。</li>
<li><strong>实现</strong>：利用 Redis 的有序集合（sorted set），可以快速添加、更新和获取排行榜数据。</li>
</ul>
</li>
<li>实时分析：<ul>
<li><strong>场景</strong>：网站的实时访问数据统计。</li>
<li><strong>实现</strong>：使用Redis的计数器功能，例如HyperLogLog来估计唯一访问者数量。</li>
</ul>
</li>
<li>地理空间数据处理：<ul>
<li><strong>场景</strong>：例如实现基于位置的服务，如查找附近的商店或用户。</li>
<li><strong>实现</strong>：使用Redis的地理空间索引功能，可以存储地理位置信息，并进行范围查询和距离计算。</li>
</ul>
</li>
<li>分布式锁：<ul>
<li><strong>场景</strong>：在分布式系统中同步不同进程或服务器之间的操作。</li>
<li><strong>实现</strong>：通过Redis的SETNX命令实现锁的机制，确保同一时间只有一个进程能执行特定的代码段。</li>
</ul>
</li>
<li>数据过期处理：<ul>
<li><strong>场景</strong>：自动删除过期的数据，如临时令牌或验证码。</li>
<li><strong>实现</strong>：利用Redis的键过期功能，可以为存储的数据设置生存时间。</li>
</ul>
</li>
</ol>
<h2 id="持久化机制"><a href="#持久化机制" class="headerlink" title="持久化机制"></a>持久化机制</h2><p>Redis 支持两种持久化机制，分别是RDB（Redis DataBase）和 AOF（Append Only File）。这两种机制可以单独使用，也可以同时使用，以便在不同的场景下平衡性能和数据安全性。</p>
<h3 id="RDB（默认持久化机制）"><a href="#RDB（默认持久化机制）" class="headerlink" title="RDB（默认持久化机制）"></a>RDB（默认持久化机制）</h3><ul>
<li><p><strong>介绍</strong>：</p>
<p>  RDB 持久化是通过<strong>创建数据集</strong>的快照来实现的。</p>
</li>
<li><p><strong>工作原理</strong>：</p>
<ul>
<li>在指定的时间间隔内，Redis自动创建当前数据的快照，并将其保存在一个紧凑的二进制文件中（默认为 <code>dump.rdb</code>）。Redis 在默认情况下只有一个 dump.rdb 文件，意味着每次创建新的RDB快照时，都会覆盖现有的<code>dump.rdb</code>文件。快照的创建可以通过自动或手动触发。自动触发基于配置的时间间隔和数据变化的次数。如果因为服务器宕机死机重启，那么内存中的数据就没了，但是他会从rdb中进行恢复。</li>
<li><strong>如果只开启了 RDB 持久化</strong>：<ul>
<li>那么每次启动或重启 Redis 时，它都会寻找 <code>dump.rdb</code> 文件。</li>
<li>如果找到了，就会加载该文件，将数据恢复到内存中。这个过程会阻塞服务器，直到加载完成。</li>
<li>如果没有找到 <code>dump.rdb</code> 文件，Redis 就会作为一个空实例启动。</li>
</ul>
</li>
<li><strong>如果同时开启了 RDB 和 AOF 两种持久化</strong>：<ul>
<li>在这种情况下，当 Redis 启动时，它会<strong>优先加载 AOF 文件</strong> (<code>appendonly.aof</code>) 来恢复数据，因为 AOF 文件通常保存了比 RDB 文件更完整、更新的数据。</li>
<li>此时，即使 <code>dump.rdb</code> 文件存在，<strong>它也会被忽略</strong>，Redis 不会加载它。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>优点</strong>：</p>
<ul>
<li><strong>高效性能</strong>：RDB是一个非常高效的方式来保存大量数据的快照。</li>
<li><strong>灾难恢复</strong>：由于RDB文件是压缩的二进制文件，适用于需要<code>定期备份数据</code>的情况，非常适合灾难恢复。</li>
</ul>
</li>
<li><p><strong>缺点</strong>：</p>
<ul>
<li><strong>数据丢失风险</strong>：如果Redis崩溃，自上次快照以来的所有数据都可能丢失。</li>
<li><strong>性能开销</strong>：在大数据集的情况下，保存快照可能会对性能产生短暂的影响。</li>
</ul>
<p>  在 RDB 持久性机制下，Redis 确实提供了两种快照（snapshot）保存方式：<code>SAVE</code> 和 <code>BFSAVE</code>。这两种命令都用于生成当前 Redis 数据库状态的快照，但它们在执行方式上有显著的不同。</p>
<p>  在 Redis 的配置文件 <code>redis.conf</code> 中，有类似这样的 <code>save</code> 配置项（默认开启）：</p>
<pre class="line-numbers language-language-json"><code class="language-language-json">save 900 1
save 300 10
save 60 10000
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>  当 Redis 因为满足了上述 <code>save</code> 配置的条件而<strong>自动触发</strong>持久化时，它<strong>执行的操作等同于 <code>BGSAVE</code></strong>，而不是阻塞的 <code>SAVE</code>。Redis 会在后台创建一个子进程来完成快照的生成，以避免阻塞主服务。</p>
</li>
</ul>
<ol>
<li>SAVE<ul>
<li><strong>执行方式</strong>：<code>SAVE</code>命令会创建一个快照并将其保存在磁盘上，但这个过程是同步进行的。这意味着在 <code>SAVE</code>命令执行期间，Redis将停止处理其他命令。</li>
<li><strong>使用场景</strong>：由于<code>SAVE</code>会堵塞所有其他客户端请求，它通常不推荐在生产环境中使用。它更适用于低流量的时段或维护期间，例如，当需要确保数据完全同步到磁盘时。</li>
</ul>
</li>
<li>BGSAVE（ Redis 自动持久化时默认采用的机制）<ul>
<li><strong>执行方式</strong>：<code>BGSAVE</code>命令会在后台创建一个快照。具体来说，Redis会先创建一个子进程，然后子进程负责将快照写入磁盘，而父进程（即原始的Redis服务器进程）可以继续处理客户端请求。</li>
<li><strong>使用场景</strong>：由于<code>BGSAVE</code>不会堵塞主服务进程，它更适合生产环境中使用，尤其是在需要定期快照但又不希望影响服务性能的场合。</li>
</ul>
</li>
</ol>
<h3 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h3><ul>
<li><p><strong>介绍</strong>：</p>
<p>  AOF（Append-Only File）是一种将Redis操作命令以追加方式写入日志文件的机制，是追加式备份。它以文本格式记录Redis的写操作（新增、修改、删除），都会记录在这个AOF日志里。</p>
<p>  需要注意的是，<strong>redis是先执行写操作指令，随后再把指令追加进AOF文件中</strong>。</p>
</li>
<li><p><strong>工作原理</strong>：</p>
<ul>
<li>每个写操作命令都会追加到AOF文件的末尾。</li>
<li>类似于记录日志，把所有的写操作追加到文件。追加的形式是append，逐个命令追加，不是修改。<ul>
<li>比如说 <code>set key1 abc</code>, <code>set key1 123</code>，虽然两次设置key1的值，但不会合并，而是追加命令。</li>
<li>redis恢复的时候先恢复AOF，如果AOF有问题（比如破损），则再恢复RDB。</li>
<li>redis恢复的时候是读取AOF中的命令，从头到尾读一遍，然后数据恢复。</li>
</ul>
</li>
<li>Redis启动时，通过重新执行这些命令来重建原始数据。</li>
<li>AOF 是通过Redis主线程执行的，因此每个写操作都会导致磁盘I&#x2F;O，当然这是为了确保数据的持久性。</li>
</ul>
</li>
<li><p><strong>优点</strong>：</p>
<ul>
<li><strong>数据完整性</strong>：与RDB相比，AOF可以提供更好的数据完整性和安全性。</li>
<li><strong>易于阅读</strong>：AOF文件以文本格式存储，易于阅读和维护。</li>
<li><strong>灵活性</strong>：提供多种同步策略，如<code>每秒同步</code>、<code>每修改同步</code>等。</li>
</ul>
</li>
<li><p><strong>缺点</strong>：</p>
<ul>
<li><strong>文件大小</strong>：AOF文件可能会比RDB文件大很多，因为它保存了所有的写操作。</li>
<li><strong>性能开销</strong>：特别是在每次修改同步的配置下，可能会对写入性能产生影响。</li>
</ul>
</li>
</ul>
<p><strong>重写机制</strong>：</p>
<p>AOF 的重写机制是Redis用来优化AOF文件大小和性能的重要机制。随着操作的不断累积，AOF文件可能会变得非常大，包含许多已经不再需要的命令。<strong>AOF重写机制就会创建一个新的AOF文件，其中包含了与当前数据库相同的数据，但是采用更紧凑的格式，通常比原始AOF文件要小得多。这有助于减少AOF文件的大小，提高Redis性能，以及降低恢复速度。</strong></p>
<p><strong>工作原理</strong>：</p>
<ul>
<li><strong>创建新的AOF文件</strong>：在AOF重写过程中，Redis会创建一个新的AOF文件。并且<strong>不是去分析和重放旧的 AOF 日志文件</strong>，而是<strong>直接读取当前数据库内存中的数据</strong>，然后为这些数据生成一套最精简的写入命令。</li>
<li><strong>最小命令集</strong>：新的AOF文件仅包含使数据库达到当前状态的最小命令集。例如，如果一个键被修改多次，新的AOF文件只会包含这个键的最终状态。</li>
</ul>
<p><strong>重写模式</strong>：</p>
<p>AOF重写有两种模式，其中一种是<code>混合模式</code>，另一种是<code>纯AOF模式</code>。</p>
<ul>
<li><p><strong>混合模式（Mixed Mode）:</strong></p>
<ul>
<li>在混合模式下AOF重写生成的新AOF文件既包含AOF格式的写命令，也包含RDB快照的数据。</li>
<li>首先，redis会把当前所有的数据以rdb形式存入到AOF文件中，这些都是二进制文件，数据量小，随后新的数据会以AOF格式追加到这个AOF文件中。</li>
<li>恢复过程会更快，因为只需要加载一个文件。</li>
</ul>
</li>
<li><p><strong>纯AOF模式</strong>：</p>
<ul>
<li>AOF重写生成的新AOF文件仅包含AOF格式的写命令，不包含RDB快照的数据。但是会将一些重复的，没有意义的指令给去除掉，减少文件体积。</li>
</ul>
</li>
<li><p><strong>触发机制</strong></p>
<ul>
<li><strong>手动触发</strong>：可以通过执行<code>BGREWRITEAOF</code>命令手动触发AOF重写。</li>
<li><strong>自动触发</strong>：Redis还可以配置为在AOF文件增长到一定大小时自动触发重写。这是通过配置文件中的<code>auto-aof-rewrite-percentage</code> 和 <code>auto-aof-rewrite-min-size</code> 指令来控制的。</li>
</ul>
</li>
<li><p><strong>过程细节</strong></p>
<ul>
<li><strong>使用子进程</strong>：类似于<code>BGSAVE</code>命令，AOF重写也是在一个子进程中进行的，以避免堵塞主进程。</li>
<li><strong>追加写入期间的命令</strong>：在重写过程中，对Redis数据库进行的所有写操作同时会被追加到旧的和新的AOF文件中，确保数据一致性。</li>
<li><strong>切换文件</strong>：一旦新的AOF文件创建完成，Redis会使用新文件替换旧的AOF文件，并从此刻开始只向新文件追加新的写命令。</li>
</ul>
</li>
<li><p><strong>优点</strong></p>
<ul>
<li><strong>减少磁盘占用</strong>：通过删除命令，AOF重写能显著减少AOF文件的大小。</li>
<li><strong>提高重启速度</strong>：更小的AOF文件意味着重启时重放命令的速度更快。</li>
</ul>
</li>
<li><p><strong>注意事项</strong></p>
<ul>
<li><strong>性能影响</strong>：尽管AOF重写是非堵塞的，但它可能会增加磁盘I&#x2F;O负担，因此在高负载的系统上运行时需要小心。</li>
<li><strong>内存影响</strong>：与<code>BGSAVE</code>类似，AOF重写也会临时增加Redis的内存使用，因为它需要创建一个当前数据库状态的副本。</li>
</ul>
<p>  <strong>AOF小结</strong>：</p>
<ol>
<li>AOF写入：<ul>
<li>AOF操作本身是将每个写命令追加到AOF文件的过程。这种追加操作通常是非堵塞的，但它的行为取决于具体的配置。</li>
<li>在AOF配置中，有一个<code>appendfsync</code>选项，它控制着操作系统刷新数据到磁盘的时机，这个选项有三个设置：<ul>
<li><strong>always</strong>（每修改同步）：每个写命令都同步写入磁盘，这可能导致堵塞，尤其是在磁盘I&#x2F;O性能较差的时候。</li>
<li><strong>everysec</strong>（每秒同步）：在默认情况下，大多数Redis设置会使用这个选项。大约每秒同步一次，这是一种平衡性能和数据安全性的做法，通常不会引起显著的堵塞。</li>
<li><code>no</code>：交给操作系统决定何时进行数据写入，这种方式下写入操作是非堵塞的，但在系统崩溃的情况下可能会丢失更多数据。</li>
</ul>
</li>
</ul>
</li>
<li>AOF重写：<ul>
<li>AOF重写操作是非堵塞的。在执行AOF重写时，Redis会启动一个子进程来进行重写工作，而主进程继续处理客户端的请求。</li>
<li>由于AOF重写是在子进程中完成的，它不会堵塞正在进行的客户端命令处理。不过，它可能会对系统的整体性能产生影响，主要是因为磁盘I&#x2F;O和额外的CPU负载。</li>
</ul>
</li>
</ol>
</li>
</ul>
<h3 id="两种持久化机制如何选择"><a href="#两种持久化机制如何选择" class="headerlink" title="两种持久化机制如何选择"></a>两种持久化机制如何选择</h3><p>选择RDB还是AOF持久化取决于应用的需求。通常情况下，两者可以结合使用以获得更好的性能和持久性。例如，可以启用AOF来记录最近的写操作，并同时使用RDB来提供定期的全数据快照。</p>
<p>总的来说，RDB适合对<code>定期备份敏感</code>、<code>数据集较大</code>的场景，而AOF适合对<code>实时性要求较高</code>、<code>数据恢复性要求非常高</code>的场景。具体选择应该根据应用程序的性质和需求来确定。</p>
<h2 id="淘汰策略"><a href="#淘汰策略" class="headerlink" title="淘汰策略"></a>淘汰策略</h2><p>Redis 的数据淘汰策略是<strong>指当内存使用达到一定阈值时，Redis如何选择删除一些数据以释放内存的方法</strong>。这些策略主要用于当Redis被用作缓存时，帮助管理内存的使用。</p>
<ol>
<li><strong>noeviction</strong>（无淘汰策略）：当内存使用达到限制时，对写入操作返回错误，但允许读操作。这是<strong>默认策略</strong>。</li>
<li><strong>allkeys-lru</strong>（最近最少使用）：在内存达到限制时，在所有键中移除最近最少使用的键。适用于通用缓存场景。</li>
<li><strong>volatile-lru</strong>（过期时间中最少使用）：仅淘汰设置了过期时间的键中的最近最少使用的键。</li>
<li><strong>allkeys-random</strong>（随机）：在内存达到限制时，在所有键中随机移除键。</li>
<li><strong>volatile-random</strong>（过期时间中随机）：仅随机移除设置了过期时间的键。</li>
<li><strong>allkeys-lfu</strong>：在所有键中移除最不经常使用的键。</li>
<li><strong>volatile-lfu</strong>（最近最少频繁使用）：从已设置过期时间的键中，移除最不经常使用的键。</li>
<li><strong>volatile-ttl</strong>（最短剩余时间）：从已设置过期的键中，移除即将到期的键。</li>
</ol>
<p><strong>应用场景：</strong></p>
<p>选择哪种淘汰策略取决于具体的使用场景和需求。例如，如果使用Redis作为缓存，并且希望在内存不足时自动删除老旧数据，可以选择<strong>allkeys-lru</strong>策略。</p>
<p>对于关键数据，可能更倾向于使用<strong>noeviction</strong>策略，并在应用层面控制内存使用。</p>
<h2 id="非阻塞I-O模型"><a href="#非阻塞I-O模型" class="headerlink" title="非阻塞I&#x2F;O模型"></a>非阻塞I&#x2F;O模型</h2><p>在此之前，我们先了解下什么是I&#x2F;O模型。I&#x2F;O（输入&#x2F;输出）模型描述的是程序如何处理输入和输出操作。在计算机系统中，I&#x2F;O操作通常是指与外部设备（如硬盘、网络接口等）的数据交换。I&#x2F;O模型决定了程序在等待I&#x2F;O操作完成时的行为，这对程序的性能和响应能力有重要影响。</p>
<p>主要有以下几种I&#x2F;O模型：</p>
<ol>
<li>堵塞I&#x2F;O（Blocking I&#x2F;O）：<ul>
<li>在这种模型中，应用程序发起I&#x2F;O请求后，必须等待数据准备就绪并完成操作，期间应用程序被堵塞，不能执行其他任务。</li>
<li>例如，读取文件操作会一直等待，直到有数据可以读取。</li>
</ul>
</li>
<li>非堵塞I&#x2F;O（New I&#x2F;O）：<ul>
<li>应用程序发起I&#x2F;O请求后，如果数据未准备好，操作系统会立即返回一个错误（通常是“资源暂时不可用”），应用程序可以继续执行其他任务。</li>
<li>应用程序需要不断地询问操作系统数据是否准备好，这个过程为“轮询（polling）”。</li>
</ul>
</li>
<li>I&#x2F;O复用（I&#x2F;O Multiplexing）：<ul>
<li>应用程序通过一个API（如select、poll、epoll）监控多个I&#x2F;O流，一旦其中一个或多个I&#x2F;O流准备好，操作系统通知应用程序。</li>
<li>这种模型允许单个线程同时管理多个I&#x2F;O操作，而不是为每个I&#x2F;O操作创建单独的线程。</li>
</ul>
</li>
<li>信号驱动I&#x2F;O（Signal-driver I&#x2F;O）：<ul>
<li>应用程序告诉操作系统启动一个操作，并让操作系统在数据准备好时通过信号来通知它。</li>
<li>与非堵塞I&#x2F;O不同，信号驱动I&#x2F;O不需要应用程序不断地检查数据是否准备好。</li>
</ul>
</li>
<li>异步I&#x2F;O（Asynchronous I&#x2F;O）：<ul>
<li>应用程序发起I&#x2F;O操作后，可以立即开始执行下一个指令。操作系统将完成整个I&#x2F;O操作（包括数据传输）并在操作完成后通知应用程序。</li>
<li>这种模型下，应用程序无需等待I&#x2F;O操作的完成。</li>
</ul>
</li>
</ol>
<p><strong>接下来让我们通过一个关于Redis如何利用非阻塞I&#x2F;O处理客户端请求的例子来更好地理解非堵塞I&#x2F;O模型概念。</strong></p>
<p><strong>场景：客户端请求处理</strong></p>
<h3 id="传统堵塞I-O模型的限制"><a href="#传统堵塞I-O模型的限制" class="headerlink" title="传统堵塞I&#x2F;O模型的限制"></a><strong>传统堵塞I&#x2F;O模型的限制</strong></h3><p>在传统的堵塞I&#x2F;O模型下，当Redis服务器接收来自一个客户端的请求时，它必须等待整个请求的处理完全完成（包括等待所有必要的数据被读取或写入），在此期间，它不能处理来自其他客户端的任何其他请求。这意味着如果某个请求的处理需要一些时间（例如，一个复杂的查询或大量数据的读取），其他客户端必须等待，这降低了整体的响应性和吞吐量。</p>
<h3 id="Redis的非堵塞I-O模型"><a href="#Redis的非堵塞I-O模型" class="headerlink" title="Redis的非堵塞I&#x2F;O模型"></a><strong>Redis的非堵塞I&#x2F;O模型</strong></h3><p>现在再来看看Redis是如何使用非堵塞I&#x2F;O来优化这个过程的：</p>
<ol>
<li><strong>多个客户端同时连接</strong>：多个客户端同时向Redis服务器发送请求。</li>
<li>非堵塞I&#x2F;O操作：<ul>
<li>当Redis服务器接收到一个请求时，它会开始处理这个请求。如果在处理过程中需要进行I&#x2F;O操作（比如读取磁盘上的数据），Redis服务器不会在这个操作完成前被堵塞。</li>
<li>相反，如果数据尚未准备好，Redis可以暂时停止处理这个请求，并转而处理其他客户端的请求。</li>
</ul>
</li>
<li>I&#x2F;O多路复用：<ul>
<li>在后台，Redis使用I&#x2F;O多路复用技术（如epoll）来有效地监控所有活跃的客户端连接。</li>
<li>一旦某个请求的I&#x2F;O操作完成（例如，所需数据已准备好读取），I&#x2F;O多路复用机制会通知Redis服务器，然后Redis可以继续处理这个请求。</li>
</ul>
</li>
<li>高效并发处理：<ul>
<li>通过这种方式，Redis可以在单个线程中高效地处理多个并发请求，而无需为每个请求或连接创建单独的线程。</li>
<li>这提高了服务器的响应性和吞吐量，即使在面对大量并发请求时也能保持高性能。</li>
</ul>
</li>
</ol>
<p><strong>结论</strong>：Redis 正是使用了<strong>非堵塞I&#x2F;O</strong>和<strong>I&#x2F;O多路复用</strong>，才能够快速、高效地处理成千上万的并发连接和请求，而无需创建和管理多个线程，从而大大提高了资源利用率和性能。</p>
<h3 id="事件驱动模型"><a href="#事件驱动模型" class="headerlink" title="事件驱动模型"></a>事件驱动模型</h3><ul>
<li><strong>非堵塞的事件循环模型</strong>：</li>
<li>Redis 采用了非堵塞的事件循环模型，允许多个客户端并发请求。虽然Redis在任何给定时间点只能处理一个请求，但它可以快速轮询多个客户端请求，以确保高吞吐量。<ul>
<li>事件驱动：<ul>
<li>Redis的<strong>核心运行机制</strong>是<code>基于事件驱动</code>的。意味着Redis的主要功能是接收和处理客户端请求、执行命令、数据持久化等，都是通过响应各种事件来完成的。</li>
<li>在事件驱动模型中，Redis不需要为每个任务或请求创建新的线程，而是在单线程中异步处理这些事件。这种方式使得Redis能够高效地处理大量并发请求，同时保持简单的架构和低延迟。</li>
</ul>
</li>
<li><strong>事件循环</strong>：Redis的核心是一个<code>事件循环</code>，也称为<code>事件驱动循环</code>。这个事件循环不断地检查并处理发生的事件，而不会堵塞整个系统。它会轮询各个已注册的事件，如客户端连接事件、套接字可读事件、套接字可写事件等。</li>
<li><strong>事件监听</strong>：Redis使用操作系统提供的多路复用机制，如<code>epoll（Linux）</code>、<code>kqueue（BSD）</code>、<code>select</code>等，来监听多个套接字上的事件。这使得Redis能够同时处理多个客户端连接而无需为每个连接创建一个新线程。</li>
<li><strong>协程和事件处理</strong>：在一些版本的Redis中，引入了协程（Coroutine）和事件处理机制，可以更有效地处理多个客户端请求和数据库操作，提高了并发性能。</li>
</ul>
</li>
</ul>
<h2 id="Redis的操作是同步还是异步"><a href="#Redis的操作是同步还是异步" class="headerlink" title="Redis的操作是同步还是异步"></a>Redis的操作是同步还是异步</h2><p>先说结论，<strong>基于内存操作是同步，基于网络I&#x2F;O或磁盘I&#x2F;O是异步</strong>。</p>
<h3 id="同步"><a href="#同步" class="headerlink" title="同步"></a><strong>同步</strong></h3><ul>
<li>当Redis接收到像<code>get key1, set key1</code>这样的命令时，如果数据在内存中（即不需要从磁盘加载），Redis会立即处理这个命令并同步返回结果。即使是在这种同步情况下，操作也是非常迅速的，因为它是在内存中进行的，几乎没有什么延迟。</li>
<li>因此，对于大多数常规操作，Redis的处理是足够快的，以至于即使这些操作都是同步进行的，也不会对性能造成显著影响。</li>
</ul>
<h3 id="异步"><a href="#异步" class="headerlink" title="异步"></a><strong>异步</strong></h3><ul>
<li>在网络I&#x2F;O方面，Redis使用<code>非堵塞I/O</code>机制。这意味着Redis可以在等待一个网络请求的数据准备好时，同时处理其他网络请求或内部任务。</li>
<li>在磁盘I&#x2F;O方面，需要区分不同类型的操作：<ul>
<li><strong>RDB持久化</strong>：当执行如<code>BGSAVE</code>命令进行RDB持久化时，Redis会在后台创建一个数据快照。这是一个异步操作，不会堵塞主事件循环。</li>
<li><strong>AOF持久化</strong>：对于AOF持久化，其行为取决于配置。如果配置为<code>appendfsync always</code>，则每次写入都会同步到磁盘，这可能是同步的。如果配置为<code>appendfsync everysec</code>或<code>appendfsync no</code>，则写入操作是异步的，因为实际的磁盘写入是延迟或由操作系统管理的。</li>
<li><strong>磁盘读取</strong>：对于磁盘读取（如重启时从RDB或AOF恢复数据），这通常是同步进行的，因为Redis需要这些数据来恢复其状态。</li>
</ul>
</li>
</ul>
<h2 id="Redis-单线程为什么这么快"><a href="#Redis-单线程为什么这么快" class="headerlink" title="Redis 单线程为什么这么快"></a>Redis 单线程为什么这么快</h2><p>Redis 采用单线程模型的优势在于它能够避免多线程带来的复杂性，降低了线程切换和锁竞争的开销，以及更容易实现一些关键操作的原子性。</p>
<ol>
<li>内存操作<ul>
<li><strong>快速数据访问</strong>：Redis是一个基于内存的数据存储系统。内存操作比磁盘操作快得多，避免了磁盘寻址和磁盘I&#x2F;O的开销。</li>
</ul>
</li>
<li>高效的数据结构<ul>
<li><strong>优化的实现</strong>：Redis内部使用高效的数据结构（如哈希表、跳跃表等），这些结构经过优化，能够快速执行数据操作，如添加、删除、查找和访问。</li>
</ul>
</li>
<li>单线程模型<ul>
<li><strong>避免上下文切换</strong>：多线程程序需要处理上下文切换的开销。Redis的单线程模型避免了这种开销，从而提高了效率。</li>
<li><strong>无需锁机制</strong>：Redis是单线程的，不需要担心数据同步和锁的问题。</li>
</ul>
</li>
<li>非堵塞I&#x2F;O<ul>
<li><strong>I&#x2F;O多路复用</strong>：Redis利用I&#x2F;O多路复用技术（如epoll、kqueue）来同时监听多个网络连接，从而提高网络通信效率。</li>
<li><strong>事件驱动模型</strong>：Redis使用基于非堵塞I&#x2F;O的事件驱动模型。这意味着即使在执行I&#x2F;O操作（如网络请求）时，Redis也不会被堵塞，而是能够继续处理其他任务。</li>
</ul>
</li>
<li>优化的命令执行<ul>
<li><strong>快速命令处理</strong>：Redis的大多数命令非常简单，可以在常数时间内完成（例如O(1)或O(log n)）。</li>
<li><strong>管道化和批量操作</strong>：Redis支持管道化，允许客户端一次性发送多个命令，然后Redis以此快速处理，减少了网络往返延迟。</li>
</ul>
</li>
</ol>
<h2 id="缓存雪崩、缓存击穿、缓存穿透"><a href="#缓存雪崩、缓存击穿、缓存穿透" class="headerlink" title="缓存雪崩、缓存击穿、缓存穿透"></a>缓存雪崩、缓存击穿、缓存穿透</h2><h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><p><strong>原理</strong>：缓存雪崩是指在缓存系统中，大量的缓存数据几乎同时失效（过期），导致所有的请求都直接落到数据库上，从而可能引起数据库压力过大、甚至宕机的问题。 </p>
<p><strong>解决方法：</strong></p>
<ol>
<li><strong>设置不同的过期时间</strong>：为缓存数据设置略微不同的过期时间，防止大量数据同时过期。</li>
<li><strong>使用持久化</strong>：确保缓存层有持久化机制，这样即使缓存服务器重启，也可以从持久化存储中恢复数据。</li>
<li><strong>设置备用缓存</strong>：建立备用缓存或多级缓存策略，当主缓存不可用时，可以使用备用缓存。</li>
<li><strong>限流和降级</strong>：在系统架构中实现限流策略，以及在高负载时启用服务降级策略。</li>
</ol>
<h3 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h3><p><strong>原理</strong>：缓存击穿是指对某个热点 key 非常频繁的访问，在这个 key 突然失效的瞬间，大量请求直接达到数据库上，可能导致数据库短时间内承受巨大压力。</p>
<p> <strong>解决方法：</strong></p>
<ol>
<li><strong>设置热点数据永不过期</strong>：对于这些非常热门的数据，可以将它们设置为永不过期。</li>
<li><strong>使用互斥锁</strong>：当缓存失效时，不是所有请求都去数据库加载数据，而是使用某种互斥锁机制确保只有一个请求去请求数据库加载数据库并回填到缓存中。</li>
<li><strong>提前更新</strong>：监控这些热点key的访问频率和模式，根据预测在它们即将过期时提前更新它们的值。</li>
</ol>
<h3 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h3><p><strong>原理</strong>：缓存穿透是指查询一个<strong>一定不存在</strong>的数据，由于缓存不会命中，每次都要到数据库去查询，可能会被恶意利用，对数据库造成压力。 </p>
<p><strong>解决方法：</strong></p>
<ol>
<li><strong>布隆过滤器</strong>：在缓存之前使用布隆过滤器，它可以快速判断一个数据是否在数据集中，如果不存在，则无需查询数据库，直接返回空响应即可。</li>
<li><strong>缓存空对象</strong>：即使某个数据在数据库中不存在，也将这个“空”结果缓存起来，避免对同一个不存在的数据发起多次查询。</li>
<li><strong>参数校验</strong>：增加严格的参数校验，避免非法参数查询。</li>
</ol>
<h2 id="布隆过滤器是什么"><a href="#布隆过滤器是什么" class="headerlink" title="布隆过滤器是什么"></a>布隆过滤器是什么</h2><p>布隆过滤器是一种空间效率很高的概率型数据结构，用于测试一个元素是否是一个集合的成员。它的主要特点是：</p>
<ol>
<li><strong>如果布隆过滤器判断元素不存在</strong>：那么该元素一定不存在于集合中。</li>
<li><strong>如果布隆过滤器判断元素存在</strong>：则该元素可能存在于集合中。也就是说，存在一定的误判概率，即布隆过滤器可能会错误地判断某个不存在的元素为存在（称为假阳性）。</li>
</ol>
<p>布隆过滤器的这种特性使其非常适合用于那些不需要100%准确性但对空间效率有较高要求的场景，如网络应用中的缓存穿透问题、垃圾邮件检测等。</p>
<h3 id="原理简述"><a href="#原理简述" class="headerlink" title="原理简述"></a><strong>原理简述</strong></h3><p>布隆过滤器通过多个独立的哈希函数对元素进行处理。当添加一个元素时，它会被所有的哈希函数分别哈希，然后在对应的位置上做标记。在查询时，会对元素使用相同的哈希函数，检查所有对应的位置是否都被标记过。如果所有位置都被标记，布隆过滤器判断元素“<code>可能存在</code>”；如果任何一个位置未被标记，则元素“<code>一定不存在</code>”。</p>
<p><strong>场景</strong></p>
<p><strong>应用：缓存穿透问题</strong></p>
<pre><code>	**问题**：缓存穿透是指缓存和数据库中都没有的数据，但请求者故意进行重复请求的现象。如这些请求数据由于不存在，每次请求都要访问数据库然后返回，这将导致数据库压力过大。

	**措施**：布隆过滤器可以用来防止缓存穿透。方法是将所有可能查询的数据哈希到一个足够大的布隆过滤器中。查询时，先查询布隆过滤器，如果布隆过滤器说数据不存在，那么肯定不存在，请求可以拒绝，从而避免对底层数据源的查询压力。如果布隆过滤器认为数据可能存在，请求才会被进一步的查询数据库或缓存系统。
</code></pre>
<h2 id="Redis和数据库如何做到一致性"><a href="#Redis和数据库如何做到一致性" class="headerlink" title="Redis和数据库如何做到一致性"></a>Redis和数据库如何做到一致性</h2><ol>
<li>缓存失效策略<ul>
<li><strong>主动失效</strong>：每当数据库更新时，立即删除或更新缓存中的相应数据。</li>
<li><strong>延迟双删</strong>：<ol>
<li><strong>先删除缓存</strong></li>
<li><strong>再更新数据库</strong></li>
<li><strong>休眠一段时间（例如几百毫秒）</strong></li>
<li><strong>再次删除缓存</strong></li>
</ol>
</li>
</ul>
</li>
<li>读写分离和最终一致性<ul>
<li>对于某些非关键性应用，可以接受最终一致性而不是强一致性。</li>
<li>通过设置合理的缓存过期时间，可以在一定时间内自动更新缓存，减少数据不一致的时间窗口。</li>
</ul>
</li>
<li>事务和锁机制<ul>
<li>在更新数据时使用事务和锁来确保数据库操作和缓存操作的原子性。</li>
<li>这种方法适用于要求严格一致性的场景，但可能会影响系统的性能。</li>
</ul>
</li>
</ol>
<h2 id="Redis-分布式锁"><a href="#Redis-分布式锁" class="headerlink" title="Redis 分布式锁"></a>Redis 分布式锁</h2><h3 id="实现分布式锁"><a href="#实现分布式锁" class="headerlink" title="实现分布式锁"></a>实现分布式锁</h3><p>Redis 分布式锁底层实现的关键点在于 Redis <strong>提供的原子命令</strong>。</p>
<p>Redis 分布式锁的原理主要基于它的命令， <code>SETNX</code> （SET if not exists），Redis 使用单线程处理命令，因此在执行 SETNX 命令期间不会发生竞态条件（线程竞争），即使多个客户端同时尝试设置同一个键，Redis也会确保只有一个客户端成功设置。这使得 SETNX 命令成为实现分布式锁的理想选择，因为它可以安全地用于多个客户端之间的协调。</p>
<ol>
<li><strong>SETNX（SET if Not exists）命令</strong>：Redis中通常使用 SETNX 命令来尝试设置一个键的值，但仅在该键不存在时才设置成功。这一特性使得可以将键视为锁，当 SETNX 成功时标识锁被获取。</li>
<li>内部执行过程：<ul>
<li><strong>检查键是否存在</strong>：在执行 <code>SETNX</code> 命令时，Redis首先会检查指定的键是否已经存在于数据库中。</li>
<li><strong>如果键不存在，设置键的值</strong>：如果检查发现键不存在，Redis会执行设置操作，将指定的键设置为指定的值。这个设置操作是原子的，即Redis确保在多个客户端同时尝试设置相同键时，只有一个客户端会成功设置，而其他客户端将失败。</li>
<li><strong>返回结果</strong>：SETNX命令会根据操作的结果返回一个<code>布尔值</code>，通常是标识为<code>1</code>代表成功获取锁，<code>0</code>代表锁已被其他客户端持有。客户端可以根据这个返回值来确定是否成功获取锁或设置键的值。</li>
</ul>
</li>
</ol>
<p><strong>正确的方式：使用 <code>SET</code> 命令的扩展选项</strong></p>
<p>现代 Redis 推荐使用一条 <strong><code>SET</code> 命令来原子地完成加锁和设置超时。</strong></p>
<pre class="line-numbers language-language-bash"><code class="language-language-bash">SET lock_key "unique_random_value" NX PX 30000
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<ul>
<li><code>lock_key</code>：锁的唯一标识。</li>
<li><code>unique_random_value</code>：<strong>一个唯一的随机字符串，用作锁的持有者凭证，用于安全地释放锁。</strong></li>
<li><code>NX</code>：只在 <code>lock_key</code> 不存在时才设置，等同于 <code>SETNX</code> 的效果。</li>
<li><code>PX 30000</code>：设置 <code>lock_key</code> 的过期时间为 30000 毫秒（30秒），避免死锁。</li>
</ul>
<p>这个操作是<strong>原子</strong>的，即 Redis 确保在多个客户端同时尝试设置相同键时，只有一个客户端会成功。命令返回 “OK” 代表成功获取锁，返回 “nil” 代表锁已被其他客户端持有。</p>
<p><strong>锁的释放：</strong></p>
<p>锁的持有者完成其任务后应该释放锁。<strong>为了防止错误地释放了别人的锁，释放操作必须是原子的“先比较、后删除”。<strong>这通常通过</strong>Lua 脚本</strong>来实现。</p>
<h3 id="为什么Redis适合做分布式锁"><a href="#为什么Redis适合做分布式锁" class="headerlink" title="为什么Redis适合做分布式锁"></a>为什么Redis适合做分布式锁</h3><ul>
<li><strong>原子性操作</strong>：Redis的<code>SETNX</code>命令和<code>EXPIRE</code>命令是原子操作，这意味着它们在执行时不会受到竞态条件的影响。这使得在多个客户端之间安全地实现分布式锁非常容易。</li>
<li><strong>高性能</strong>：Redis是一个内存数据库，可以在微秒级别执行操作，因此在获取和释放锁时非常快速。这使得Redis适合用作分布式锁。</li>
<li><strong>可用性</strong>：Redis支持主从复制和分片，因此即使某个Redis节点发生故障，其他节点仍然可以提供服务。这确保了分布式锁的可用性。</li>
<li><strong>超时和自动释放</strong>：Redis可以为锁设置超时时间，确保锁在一段时间后自动释放，防止死锁情况的发生。</li>
<li><strong>简单易用</strong>：Redis的API自带了SETNX和EXPIRE命令，创建锁和管理锁非常容易。</li>
</ul>
<h2 id="Redis-6-0-多线程的改动"><a href="#Redis-6-0-多线程的改动" class="headerlink" title="Redis 6.0 多线程的改动"></a>Redis 6.0 多线程的改动</h2><p>从 Redis 6.0版本开始，Redis开始引入了多线程模型来处理网络I&#x2F;O。这是Redis架构中的一个重要变化，但需要注意的是，<strong>这个多线程模型主要用于网络请求的读写操作，并不涉及到数据的实际读写操作，也就是说，数据的实际读写还是单线程在处理。</strong></p>
<p><strong>Redis多线程模型的特点</strong></p>
<ol>
<li><strong>限于网络I&#x2F;O</strong>：<strong>多线程在Redis中主要用于处理客户端请求的接受和响应的发送，即网络I&#x2F;O操作</strong>。数据的读取和写入仍然在主线程中单线程执行，以保证原子性和一致性。</li>
<li><strong>配置可调整</strong>：用户可以配置线程数量，以优化网络I&#x2F;O的性能。默认情况下，多线程不会启用，需要用户配置。</li>
</ol>
<p><strong>为什么采用这种多线程设计</strong></p>
<p>通过使用多线程处理网络I&#x2F;O，Redis可以更好地利用现代多核CPU的能力，提高在高并发情况下的性能，尤其是在处理大量网络请求时。</p>

                
            </div>
            <hr/>

            



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/Redis/">
                                    <span class="chip bg-color">Redis</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">
<div id="article-share">

    

    

</div>

                </div>
            </div>
            
        </div>
    </div>

    

    

    

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/2024/07/15/docker-bi-ji/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/12.jpg" class="responsive-img" alt="Docker 笔记">
                        
                        <span class="card-title">Docker 笔记</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2024-07-15
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/%E7%AC%94%E8%AE%B0/" class="post-category">
                                    笔记
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/Docker/">
                        <span class="chip bg-color">Docker</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2024/05/03/mysql/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/15.jpg" class="responsive-img" alt="MySQL基础巩固">
                        
                        <span class="card-title">MySQL基础巩固</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2024-05-03
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" class="post-category">
                                    数据库
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/MySQL/">
                        <span class="chip bg-color">MySQL</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>



<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>


  <!-- 是否加载使用自带的 prismjs. -->
  <script type="text/javascript" src="/libs/prism/prism.min.js"></script>


<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>



    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget card" style="background-color: white;">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h2, h3, h4'
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>




    <footer class="page-footer bg-color">
    

    <div class="container row center-align"
         style="margin-bottom: 15px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            
                <span id="year">2023-2025</span>
            
            <a href="/about" target="_blank">Sean</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            
            <br>
            
                &nbsp;<i class="fas fa-chart-area"></i>&nbsp;站点总字数:&nbsp;<span
                        class="white-color">124.7k</span>
            
            
            
                
            
            
                <span id="busuanzi_container_site_pv">
                &nbsp;|&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;
                    <span id="busuanzi_value_site_pv" class="white-color"></span>
            </span>
            
            
                <span id="busuanzi_container_site_uv">
                &nbsp;|&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;
                    <span id="busuanzi_value_site_uv" class="white-color"></span>
            </span>
            
            <br>

            <!-- 运行天数提醒. -->
            
                <span id="sitetime"> Loading ...</span>
                <script>
                    var calcSiteTime = function () {
                        var seconds = 1000;
                        var minutes = seconds * 60;
                        var hours = minutes * 60;
                        var days = hours * 24;
                        var years = days * 365;
                        var today = new Date();
                        var startYear = "2023";
                        var startMonth = "7";
                        var startDate = "28";
                        var startHour = "0";
                        var startMinute = "0";
                        var startSecond = "0";
                        var todayYear = today.getFullYear();
                        var todayMonth = today.getMonth() + 1;
                        var todayDate = today.getDate();
                        var todayHour = today.getHours();
                        var todayMinute = today.getMinutes();
                        var todaySecond = today.getSeconds();
                        var t1 = Date.UTC(startYear, startMonth, startDate, startHour, startMinute, startSecond);
                        var t2 = Date.UTC(todayYear, todayMonth, todayDate, todayHour, todayMinute, todaySecond);
                        var diff = t2 - t1;
                        var diffYears = Math.floor(diff / years);
                        var diffDays = Math.floor((diff / days) - diffYears * 365);

                        // 区分是否有年份.
                        var language = 'zh-CN';
                        if (startYear === String(todayYear)) {
                            document.getElementById("year").innerHTML = todayYear;
                            var daysTip = 'This site has been running for ' + diffDays + ' days';
                            if (language === 'zh-CN') {
                                daysTip = '本站已运行 ' + diffDays + ' 天';
                            } else if (language === 'zh-HK') {
                                daysTip = '本站已運行 ' + diffDays + ' 天';
                            }
                            document.getElementById("sitetime").innerHTML = daysTip;
                        } else {
                            document.getElementById("year").innerHTML = startYear + " - " + todayYear;
                            var yearsAndDaysTip = 'This site has been running for ' + diffYears + ' years and '
                                + diffDays + ' days';
                            if (language === 'zh-CN') {
                                yearsAndDaysTip = '本站已运行 ' + diffYears + ' 年 ' + diffDays + ' 天';
                            } else if (language === 'zh-HK') {
                                yearsAndDaysTip = '本站已運行 ' + diffYears + ' 年 ' + diffDays + ' 天';
                            }
                            document.getElementById("sitetime").innerHTML = yearsAndDaysTip;
                        }
                    }

                    calcSiteTime();
                </script>
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/HyxiaoGe" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>



    <a href="mailto:hyxiao97@gmail.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fas fa-envelope-open"></i>
    </a>













</div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script type="text/javascript">
$(function () {
    var searchFunc = function (path, search_id, content_id) {
        'use strict';
        $.ajax({
            url: path,
            dataType: "xml",
            success: function (xmlResponse) {
                // get the contents from search data
                var datas = $("entry", xmlResponse).map(function () {
                    return {
                        title: $("title", this).text(),
                        content: $("content", this).text(),
                        url: $("url", this).text()
                    };
                }).get();
                var $input = document.getElementById(search_id);
                var $resultContent = document.getElementById(content_id);
                $input.addEventListener('input', function () {
                    var str = '<ul class=\"search-result-list\">';
                    var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                    $resultContent.innerHTML = "";
                    if (this.value.trim().length <= 0) {
                        return;
                    }
                    // perform local searching
                    datas.forEach(function (data) {
                        var isMatch = true;
                        var data_title = data.title.trim().toLowerCase();
                        var data_content = data.content.trim().replace(/<[^>]+>/g, "").toLowerCase();
                        var data_url = data.url;
                        data_url = data_url.indexOf('/') === 0 ? data.url : '/' + data_url;
                        var index_title = -1;
                        var index_content = -1;
                        var first_occur = -1;
                        // only match artiles with not empty titles and contents
                        if (data_title !== '' && data_content !== '') {
                            keywords.forEach(function (keyword, i) {
                                index_title = data_title.indexOf(keyword);
                                index_content = data_content.indexOf(keyword);
                                if (index_title < 0 && index_content < 0) {
                                    isMatch = false;
                                } else {
                                    if (index_content < 0) {
                                        index_content = 0;
                                    }
                                    if (i === 0) {
                                        first_occur = index_content;
                                    }
                                }
                            });
                        }
                        // show search results
                        if (isMatch) {
                            str += "<li><a href='" + data_url + "' class='search-result-title'>" + data_title + "</a>";
                            var content = data.content.trim().replace(/<[^>]+>/g, "");
                            if (first_occur >= 0) {
                                // cut out 100 characters
                                var start = first_occur - 20;
                                var end = first_occur + 80;
                                if (start < 0) {
                                    start = 0;
                                }
                                if (start === 0) {
                                    end = 100;
                                }
                                if (end > content.length) {
                                    end = content.length;
                                }
                                var match_content = content.substr(start, end);
                                // highlight all keywords
                                keywords.forEach(function (keyword) {
                                    var regS = new RegExp(keyword, "gi");
                                    match_content = match_content.replace(regS, "<em class=\"search-keyword\">" + keyword + "</em>");
                                });

                                str += "<p class=\"search-result\">" + match_content + "...</p>"
                            }
                            str += "</li>";
                        }
                    });
                    str += "</ul>";
                    $resultContent.innerHTML = str;
                });
            }
        });
    };

    searchFunc('/search.xml', 'searchInput', 'searchResult');
});
</script>

    <!-- 白天和黑夜主题 -->
<div class="stars-con">
    <div id="stars"></div>
    <div id="stars2"></div>
    <div id="stars3"></div>  
</div>

<script>
    function switchNightMode() {
        $('<div class="Cuteen_DarkSky"><div class="Cuteen_DarkPlanet"></div></div>').appendTo($('body')),
        setTimeout(function () {
            $('body').hasClass('DarkMode') 
            ? ($('body').removeClass('DarkMode'), localStorage.setItem('isDark', '0'), $('#sum-moon-icon').removeClass("fa-sun").addClass('fa-moon')) 
            : ($('body').addClass('DarkMode'), localStorage.setItem('isDark', '1'), $('#sum-moon-icon').addClass("fa-sun").removeClass('fa-moon')),
            
            setTimeout(function () {
            $('.Cuteen_DarkSky').fadeOut(1e3, function () {
                $(this).remove()
            })
            }, 2e3)
        })
    }
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    

    
    
    

    <!-- 雪花特效 -->
     
        <script type="text/javascript">
            // 只在桌面版网页启用特效
            var windowWidth = $(window).width();
            if (windowWidth > 768) {
                document.write('<script type="text/javascript" src="/libs/others/snow.js"><\/script>');
            }
        </script>
    

    <!-- 鼠标星星特效 -->
    

    

    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    <script src="/libs/others/clicklove.js" async="async"></script>
    
    
    <script async src="/libs/others/busuanzi.pure.mini.js"></script>
    

    

    

    <!--腾讯兔小巢-->
    
    

    

    

    
    <script src="/libs/instantpage/instantpage.js" type="module"></script>
    

</body>

</html>
