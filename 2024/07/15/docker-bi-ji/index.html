<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="Docker 笔记, HyxiaoGe">
    <meta name="description" content="Docker 笔记
容器是什么？镜像是什么？容器：是一个轻量级、可独立运行的软件包。它是动态的、可运行的。它是通过用镜像创建出来的一个具体的、正在运行的进程实例。
镜像：是用来创建和运行 Docker 容器的。它包含了运行某个应用所需的一切">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="referrer" content="no-referrer-when-downgrade">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    <title>Docker 笔记 | HyxiaoGe</title>
    <link rel="icon" type="image/png" href="/favicon.png">
    
    <style>
        body{
            background-image: url(http://sv6693ki5.hn-bkt.clouddn.com/background/bg.jpg);
            background-repeat:no-repeat;
            background-size: 100% 100%;
            background-attachment:fixed;
        }
    </style>



    <!-- bg-cover style     -->



<link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.min.css">
<link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
<link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
<link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
<link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
<link rel="stylesheet" type="text/css" href="/css/matery.css">
<link rel="stylesheet" type="text/css" href="/css/my.css">
<link rel="stylesheet" type="text/css" href="/css/dark.css" media="none" onload="if(media!='all')media='all'">




    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
    <link rel="stylesheet" href="/css/post.css">




    



    <script src="/libs/jquery/jquery-3.6.0.min.js"></script>

<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="HyxiaoGe" type="application/atom+xml">
<link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"><script src="/js/prism.js"></script>
<script src="/js/prism-line-numbers.min.js"></script></head>


<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">HyxiaoGe</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/contact" class="waves-effect waves-light">
      
      <i class="fas fa-comments" style="zoom: 0.6;"></i>
      
      <span>留言板</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/friends" class="waves-effect waves-light">
      
      <i class="fas fa-address-book" style="zoom: 0.6;"></i>
      
      <span>友情链接</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
  <li>
    <a href="javascript:;" class="waves-effect waves-light" onclick="switchNightMode()" title="深色/浅色模式" >
      <i id="sum-moon-icon" class="fas fa-sun" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">HyxiaoGe</div>
        <div class="logo-desc">
            
            Never really desperate, only the lost of the soul.
            
        </div>
    </div>

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/contact" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-comments"></i>
			
			留言板
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/friends" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-address-book"></i>
			
			友情链接
		</a>
          
        </li>
        
        
    </ul>
</div>


        </div>

        
    </nav>

</header>

    



<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/12.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">Docker 笔记</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/Docker/">
                                <span class="chip bg-color">Docker</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fas fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/categories/%E7%AC%94%E8%AE%B0/" class="post-category">
                                笔记
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2024-07-15
                </div>
                

                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-check fa-fw"></i>更新日期:&nbsp;&nbsp;
                    2025-07-31
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-file-word fa-fw"></i>文章字数:&nbsp;&nbsp;
                    7.6k
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-clock fa-fw"></i>阅读时长:&nbsp;&nbsp;
                    30 分
                </div>
                

                
                    <div id="busuanzi_container_page_pv" class="info-break-policy">
                        <i class="far fa-eye fa-fw"></i>阅读次数:&nbsp;&nbsp;
                        <span id="busuanzi_value_page_pv"></span>
                    </div>
				
            </div>
        </div>
        <hr class="clearfix">

        
        <!-- 是否加载使用自带的 prismjs. -->
        <link rel="stylesheet" href="/libs/prism/prism.min.css">
        

        

        <div class="card-content article-card-content">
            <div id="articleContent">
                <h1 id="Docker-笔记"><a href="#Docker-笔记" class="headerlink" title="Docker 笔记"></a>Docker 笔记</h1><hr>
<h2 id="容器是什么？镜像是什么？"><a href="#容器是什么？镜像是什么？" class="headerlink" title="容器是什么？镜像是什么？"></a>容器是什么？镜像是什么？</h2><p><strong>容器</strong>：是一个轻量级、可独立运行的软件包。它是<strong>动态的</strong>、<strong>可运行的</strong>。它是通过用镜像创建出来的一个<strong>具体的、正在运行的进程实例</strong>。</p>
<p>镜像：是用来创建和运行 Docker 容器的。它包含了运行某个应用所需的一切：代码、运行时环境（如 Node.js 或 Java）、系统工具、系统库和设置。</p>
<h2 id="分层-Layer-是什么？"><a href="#分层-Layer-是什么？" class="headerlink" title="分层 (Layer) 是什么？"></a>分层 (Layer) 是什么？</h2><p>一个 Docker 镜像并非一个单一的文件，而是由一组<strong>文件系统层 (Layers)</strong> 堆叠而成的。你可以把它想象成一个千层蛋糕。</p>
<ul>
<li><strong>只读性</strong>: 镜像的每一层都是<strong>只读的 (read-only)</strong>。</li>
<li><strong>来源</strong>: <code>Dockerfile</code> 中的每一条指令，通常都会创建一个新的镜像层。比如 <code>FROM</code>, <code>RUN</code>, <code>COPY</code>, <code>ADD</code> 等。</li>
<li><strong>共享与复用</strong>: 不同的镜像可以<strong>共享</strong>相同的层。如果它们都基于同一个基础镜像，那么这个基础镜像的层在主机上只需要存储一份。</li>
</ul>
<h3 id="工作原理：只读的镜像层-可写的容器层"><a href="#工作原理：只读的镜像层-可写的容器层" class="headerlink" title="工作原理：只读的镜像层 + 可写的容器层"></a><strong>工作原理：只读的镜像层 + 可写的容器层</strong></h3><p>当 Docker 使用一个镜像来启动一个容器时，它并不会改变这个镜像。而是在镜像的顶层添加了一个新的、<strong>可写的层</strong>，我们称之为 <strong>“容器层” (Container Layer)</strong>。</p>
<ul>
<li><strong>容器的生命周期内</strong>：你对容器做的所有更改，比如新建文件、修改文件、删除文件，都发生在这个<strong>可写的容器层</strong>里。</li>
<li><strong>写时复制 (Copy-on-Write)</strong>: 如果容器需要修改一个底层镜像中已存在的文件，Docker 会先把这个文件从下面的只读层复制到最上层的可写容器层，然后再进行修改。原来的只读层中的文件保持不变。这就是所谓的“写时复制”机制。</li>
</ul>
<h3 id="分层架构的好处-面试重点"><a href="#分层架构的好处-面试重点" class="headerlink" title="分层架构的好处 (面试重点)"></a><strong>分层架构的好处 (面试重点)</strong></h3><p>面试官通常会问，为什么 Docker 要采用这种分层设计？</p>
<ol>
<li><strong>高效的存储 (Efficient Storage)</strong>:<ul>
<li><strong>共享基础层</strong>: 假设你的主机上有三个Python服务，它们都基于<code>python:3.12-slim</code>。那么 <code>python:3.12-slim</code> 对应的所有层都只会在磁盘上存储<strong>一份</strong>。这极大地节省了磁盘空间。<ul>
<li><strong>共享的基础镜像 (<code>python:3.12-slim</code>)</strong>: 由 <code>[基础层]</code> 构成，大小为 <strong>100MB</strong>。</li>
<li><strong>镜像 a (<code>service-a</code>)</strong>:<ul>
<li>构成: <code>[基础层]</code> + <code>[a层(5MB)]</code></li>
<li><code>docker images</code> 显示的大小 ≈ <strong>105MB</strong></li>
</ul>
</li>
<li><strong>镜像 b (<code>service-b</code>)</strong>:<ul>
<li>构成: <code>[基础层]</code> + <code>[b层(8MB)]</code></li>
<li><code>docker images</code> 显示的大小 ≈ <strong>108MB</strong></li>
</ul>
</li>
<li><strong>镜像 c (<code>service-c</code>)</strong>:<ul>
<li>构成: <code>[基础层]</code> + <code>[c层(2MB)]</code></li>
<li><code>docker images</code> 显示的大小 ≈ <strong>102MB</strong></li>
</ul>
</li>
<li>总占用 &#x3D; 100MB (基础) + 5MB (a) + 8MB (b) + 2MB (c) &#x3D; 115MB</li>
</ul>
</li>
</ul>
</li>
<li><strong>更快的构建 (Faster Builds)</strong>:<ul>
<li><strong>利用缓存</strong>: Docker 会缓存每一层的构建结果。当你修改 <code>Dockerfile</code> 并重新构建时，Docker 只会重新构建你修改的那一行指令以及它之后的所有层，之前的层会直接使用缓存。这极大地加快了开发和构建的速度。<ul>
<li><p><strong>场景：开发一个简单的 Python Web 应用</strong></p>
<p>  假设你的项目文件夹里有这两个文件：</p>
<ol>
<li><code>requirements.txt</code> (记录 Python 依赖，比如 <code>flask</code>, <code>requests</code>)</li>
<li><code>app.py</code> (你的主程序代码)</li>
</ol>
<p>  你的 <code>Dockerfile</code> 是这样精心设计的（<strong>这个顺序很关键</strong>）：</p>
<pre class="line-numbers language-language-docker"><code class="language-language-docker"># --- 关卡 1: 选择基础镜像 ---
FROM python:3.9-slim

# --- 关卡 2: 设置工作目录 ---
WORKDIR /app

# --- 关卡 3: 复制依赖文件 ---
COPY requirements.txt .

# --- 关卡 4: 安装依赖 (这步通常很慢) ---
RUN pip install -r requirements.txt

# --- 关卡 5: 复制所有项目代码 ---
COPY . .

# --- 关卡 6: 设置启动命令 ---
CMD ["python", "app.py"]
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="第一次构建：从零开始"><a href="#第一次构建：从零开始" class="headerlink" title="第一次构建：从零开始"></a><strong>第一次构建：从零开始</strong></h3><p>  你第一次运行 <code>docker build -t my-app .</code>。</p>
<ul>
<li><strong>Docker 的动作</strong>：它会老老实实地从头到尾执行每一条指令。<ul>
<li><code>关卡1 (FROM)</code>: 执行… 完成！<strong>(创建存档1)</strong></li>
<li><code>关卡2 (WORKDIR)</code>: 执行… 完成！<strong>(创建存档2)</strong></li>
<li><code>关卡3 (COPY req...)</code>: 执行… 完成！<strong>(创建存档3)</strong></li>
<li><code>关卡4 (RUN pip...)</code>: 开始下载和安装库，可能需要几十秒甚至几分钟… 完成！<strong>(创建存档4)</strong></li>
<li><code>关卡5 (COPY . .)</code>: 执行… 完成！<strong>(创建存档5)</strong></li>
<li><code>关卡6 (CMD)</code>: 执行… 完成！<strong>(创建存档6)</strong></li>
</ul>
</li>
<li><strong>你的感受</strong>：有点慢，需要耐心等待 <code>pip install</code> 完成。</li>
</ul>
<hr>
<h3 id="第二次构建：只改了-Python-代码"><a href="#第二次构建：只改了-Python-代码" class="headerlink" title="第二次构建：只改了 Python 代码"></a><strong>第二次构建：只改了 Python 代码</strong></h3><p>  这是最常见的开发场景。你修改了 <code>app.py</code> 里面的逻辑，但没有动 <code>requirements.txt</code>。现在你再次运行 <code>docker build -t my-app .</code>。</p>
<ul>
<li><strong>Docker 的动作</strong>：<ul>
<li><code>关卡1 (FROM)</code>: 指令没变 -&gt; <strong>使用存档1 (USING CACHE)</strong></li>
<li><code>关卡2 (WORKDIR)</code>: 指令没变 -&gt; <strong>使用存档2 (USING CACHE)</strong></li>
<li><code>关卡3 (COPY req...)</code>: Docker 会检查 <code>requirements.txt</code> 文件的内容。发现文件没变 -&gt; <strong>使用存档3 (USING CACHE)</strong></li>
<li><code>关卡4 (RUN pip...)</code>: 因为上一层（关卡3）使用了缓存，并且本行指令也没变 -&gt; <strong>使用存档4 (USING CACHE)</strong>。<strong>最耗时的安装步骤被瞬间跳过！</strong></li>
<li><code>关卡5 (COPY . .)</code>: Docker 检查要复制的所有文件，发现 <code>app.py</code> 变了！ -&gt; <strong>存档5失效，重新执行！</strong></li>
<li><code>关卡6 (CMD)</code>: <strong>重要规则：一旦中间某一层缓存失效，它之后的所有层都会重新执行</strong> -&gt; <strong>重新执行！</strong></li>
</ul>
</li>
<li><strong>你的感受</strong>：构建速度极快！几乎是秒级完成，因为最慢的 <code>pip install</code> 被跳过了。</li>
</ul>
<hr>
<h3 id="第三次构建：修改了依赖文件"><a href="#第三次构建：修改了依赖文件" class="headerlink" title="第三次构建：修改了依赖文件"></a><strong>第三次构建：修改了依赖文件</strong></h3><p>  这次，你往 <code>requirements.txt</code> 里增加了一个新的库，比如 <code>numpy</code>。然后再次运行 <code>docker build -t my-app .</code>。</p>
<ul>
<li><strong>Docker 的动作</strong>：<ul>
<li><code>关卡1 (FROM)</code>: 使用缓存。</li>
<li><code>关卡2 (WORKDIR)</code>: 使用缓存。</li>
<li><code>关卡3 (COPY req...)</code>: Docker 检查 <code>requirements.txt</code>，发现文件内容变了！-&gt; <strong>存档3失效，重新执行！</strong></li>
<li><code>关卡4 (RUN pip...)</code>: 因为上一层（关卡3）是重新执行的 -&gt; <strong>存档4失效，必须重新执行！</strong> Docker 会再次运行 <code>pip install</code>，这次会把 <code>numpy</code> 也装上。</li>
<li><code>关-关6</code>: 同样全部重新执行。</li>
</ul>
</li>
<li><strong>你的感受</strong>：构建又变慢了。这是符合预期的，因为依赖确实发生了变化，需要重新安装。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><strong>高效的分发 (Efficient Distribution)</strong>:<ul>
<li><strong>按需传输</strong>: 当你从 Docker Hub 拉取 (<code>docker pull</code>) 一个镜像时，Docker 客户端会检查本地已经存在的层，只下载那些本地没有的层。同理，推送 (<code>docker push</code>) 镜像时也一样。这使得镜像的拉取和推送非常快。</li>
</ul>
</li>
</ol>
<h2 id="缓存失效了，之前的缓存会自动删除吗"><a href="#缓存失效了，之前的缓存会自动删除吗" class="headerlink" title="缓存失效了，之前的缓存会自动删除吗"></a>缓存失效了，之前的缓存会自动删除吗</h2><p>回答：<strong>不会，缓存失效后，旧的缓存层不会在构建时自动删除。</strong></p>
<p>它们会变成一种特殊的状态，我们称之为 <strong>“悬空镜像” (dangling image)</strong> 或更广义的 “悬空层” (dangling layers)。</p>
<h3 id="这是什么意思？我们用一个比喻来理解"><a href="#这是什么意思？我们用一个比喻来理解" class="headerlink" title="这是什么意思？我们用一个比喻来理解"></a><strong>这是什么意思？我们用一个比喻来理解</strong></h3><p>把镜像的标签（比如 <code>my-app:latest</code>）想象成一个<strong>便利贴</strong>。</p>
<ol>
<li><strong>第一次构建</strong>:<ul>
<li>你构建了一个镜像，我们叫它 <code>镜像A</code>。</li>
<li>Docker 把 <code>my-gzh:v1</code> 这张便利贴粘在了 <code>镜像A</code> 上。</li>
<li>此时，<code>镜像A</code> 是有主（有便利贴）的。</li>
</ul>
</li>
<li><strong>你修改了代码，再次构建</strong>:<ul>
<li>因为缓存失效，Docker 创建了一个全新的镜像，我们叫它 <code>镜像B</code>。</li>
<li>Docker 会把 <code>my-app:latest</code> 这张便利贴从 <code>镜像A</code> 身上<strong>撕下来</strong>，然后<strong>粘到新的 <code>镜像B</code></strong> 身上。</li>
</ul>
</li>
<li><strong>现在发生了什么？</strong><ul>
<li><code>镜像B</code> 成为了新的 <code>my-app:latest</code>。</li>
<li>而 <code>镜像A</code> 呢？它身上的便利贴被撕走了，它变成了一个<strong>没有名字、没有标签的“无主孤魂”</strong>。</li>
</ul>
</li>
</ol>
<p>这个被撕掉标签的 <code>镜像A</code>，就是我们所说的 <strong>“悬空镜像” (dangling image)</strong>。它和它所包含的那些旧的、失效的缓存层，依然<strong>静静地躺在你的硬盘上</strong>，并不会自动消失。</p>
<h3 id="为什么要这么设计？"><a href="#为什么要这么设计？" class="headerlink" title="为什么要这么设计？"></a><strong>为什么要这么设计？</strong></h3><p>Docker 这么做有它的道理，比如：</p>
<ul>
<li><strong>安全回滚</strong>：万一你发现新的构建有问题，那个旧的、没有标签的镜像还在，理论上你还可以通过它的 ID 找回它，重新给它贴上标签来回滚。</li>
<li><strong>性能考虑</strong>：在构建过程中频繁地进行磁盘删除操作，可能会影响构建性能。所以 Docker 选择把“构建”和“清理”这两个动作分开。</li>
</ul>
<h3 id="那如何清理这些“无主孤魂”呢？"><a href="#那如何清理这些“无主孤魂”呢？" class="headerlink" title="那如何清理这些“无主孤魂”呢？"></a><strong>那如何清理这些“无主孤魂”呢？</strong></h3><p>既然 Docker 不会自动清理，就需要我们手动当一下“清洁工”。Docker 提供了非常方便的命令。</p>
<ol>
<li><p><strong>查看有哪些悬空镜像</strong><br>你可以用这个命令，专门列出所有被撕掉标签的悬空镜像：</p>
<pre class="line-numbers language-language-docker"><code class="language-language-docker">docker images -f dangling=true
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p> 你可能会看到一堆 <code>&lt;none&gt;</code>:<code>&lt;none&gt;</code> 的镜像，这些就是它们。</p>
</li>
<li><p><strong>清理悬空镜像</strong></p>
<p> 使用 prune (修剪) 命令可以一键清理。</p>
<pre class="line-numbers language-language-docker"><code class="language-language-docker">docker image prune
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p> 执行后，Docker 会找到所有悬空镜像并询问你是否要删除它们，你输入 <code>y</code> 即可。这些镜像占用的磁盘空间就会被释放。</p>
</li>
</ol>
<h3 id="如何查看镜像的分层？"><a href="#如何查看镜像的分层？" class="headerlink" title="如何查看镜像的分层？"></a><strong>如何查看镜像的分层？</strong></h3><p>你可以使用 <code>docker history</code> 命令来查看一个镜像的构建历史和分层信息。</p>
<pre class="line-numbers language-language-bash"><code class="language-language-bash"># 拉取一个镜像用于演示
docker pull python:3.9-slim

# 查看它的分层历史
docker history python:3.9-slim
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>你会看到类似下面的输出，每一行都代表一个层，以及创建该层的命令和它的大小：</p>
<pre class="line-numbers language-language-bash"><code class="language-language-bash">IMAGE          CREATED        CREATED BY                                      SIZE      COMMENT
a1b2c3d4e5f6   2 weeks ago    /bin/sh -c #(nop)  CMD ["python3"]              0B
<missing>      2 weeks ago    /bin/sh -c #(nop)  ENTRYPOINT ["docker-entry…   0B
<missing>      2 weeks ago    /bin/sh -c #(nop) COPY file:238737301c4475…     341B
<missing>      2 weeks ago    /bin/sh -c set -ex;   savedAptMark="$(apt-ma…   4.86MB
<missing>      2 weeks ago    /bin/sh -c #(nop)  ENV PYTHON_GET_PIP_URL=h…   0B
... (更多层) ...
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>总结一下：</strong></p>
<p>镜像是静态的、只读的模板。它由多个只读层构成，每一层对应<code>Dockerfile</code>的一条指令。启动容器时，会在镜像之上增加一个可写层。这种分层结构带来了存储、构建和分发上的巨大效率优势。</p>
<h2 id="Docker-的整体架构"><a href="#Docker-的整体架构" class="headerlink" title="Docker 的整体架构"></a>Docker 的整体架构</h2><p>Docker 采用的是经典的 <strong>C&#x2F;S 架构 (Client&#x2F;Server, 客户端&#x2F;服务器架构)</strong>。它主要由三大部分组成：</p>
<ol>
<li>客户端 (Docker Client)</li>
<li>主机 (Docker Host) &#x2F; 守护进程 (Docker Daemon)</li>
<li>镜像仓库 (Docker Registry)</li>
</ol>
<h3 id="客户端-Docker-Client"><a href="#客户端-Docker-Client" class="headerlink" title="客户端 (Docker Client)"></a><strong>客户端 (Docker Client)</strong></h3><ul>
<li><strong>是什么</strong>：就是你主要打交道的对象，最常见的就是 <code>docker</code> 命令行工具。</li>
<li><strong>做什么</strong>：当你输入一个命令，比如 <code>docker run ...</code> 或 <code>docker build ...</code>，Client 会将这个命令通过 <strong>REST API</strong> 发送给 Docker Daemon。</li>
<li><strong>在哪</strong>：Client 可以和 Docker Daemon 运行在<strong>同一台机器</strong>上，也可以通过网络连接到<strong>远程</strong>的 Docker Daemon 上进行管理。</li>
</ul>
<p>简单来说，客户端就是个“传话的”，负责把你的指令传递给真正的“干活的”。</p>
<h3 id="主机-Docker-Host-守护进程-Docker-Daemon"><a href="#主机-Docker-Host-守护进程-Docker-Daemon" class="headerlink" title="主机 (Docker Host) &amp; 守护进程 (Docker Daemon)"></a><strong>主机 (Docker Host) &amp; 守护进程 (Docker Daemon)</strong></h3><p>这是 Docker 架构的核心和大脑，真正的“实干家”。</p>
<ul>
<li><strong>守护进程 (Docker Daemon, <code>dockerd</code>)</strong>:<ul>
<li>它是一个常驻在后台的系统进程。</li>
<li>它负责监听来自 Docker Client 的 API 请求。</li>
<li>它拥有管理一切 Docker 对象的全部权力，包括：<ul>
<li><strong>镜像 (Images)</strong>: 管理本地镜像，如果本地没有，会从 Registry 拉取。</li>
<li><strong>容器 (Containers)</strong>: 创建、运行、停止、删除容器。</li>
<li><strong>网络 (Networks)</strong>: 创建和配置容器网络。</li>
<li><strong>数据卷 (Volumes)</strong>: 管理数据的持久化。</li>
</ul>
</li>
</ul>
</li>
<li><strong>Docker Host</strong>: 指安装了 Docker Daemon 的物理机或虚拟机。Daemon 就是运行在这个 Host 上的。</li>
</ul>
<h3 id="镜像仓库-Docker-Registry"><a href="#镜像仓库-Docker-Registry" class="headerlink" title="镜像仓库 (Docker Registry)"></a><strong>镜像仓库 (Docker Registry)</strong></h3><ul>
<li><strong>是什么</strong>：一个集中存放和分发 Docker 镜像的服务。你可以把它理解为 Docker 世界的 “GitHub” 或 “Maven 中央仓库”。</li>
<li><strong>做什么</strong>：<ul>
<li><code>docker pull</code>: Daemon 从 Registry 拉取镜像到本地。</li>
<li><code>docker push</code>: Daemon 将本地构建的镜像推送到 Registry。</li>
</ul>
</li>
<li><strong>分类</strong>：<ul>
<li><strong>公共仓库 (Public Registry)</strong>: 比如官方的 <strong>Docker Hub</strong>，是默认的 Registry。</li>
<li><strong>私有仓库 (Private Registry)</strong>: 出于安全或网络原因，公司通常会搭建自己的私有仓库，比如 Harbor，或者使用云厂商提供的私有仓库服务 (如阿里云 ACR)。</li>
</ul>
</li>
</ul>
<h2 id="Dockerfile-最佳实践与深度理解"><a href="#Dockerfile-最佳实践与深度理解" class="headerlink" title="Dockerfile 最佳实践与深度理解"></a><code>Dockerfile</code> 最佳实践与深度理解</h2><h3 id="1-保持镜像轻量-Keep-Images-Small"><a href="#1-保持镜像轻量-Keep-Images-Small" class="headerlink" title="1. 保持镜像轻量 (Keep Images Small)"></a><strong>1. 保持镜像轻量 (Keep Images Small)</strong></h3><p><strong>为什么重要？</strong></p>
<ul>
<li><strong>存储成本</strong>：更小的镜像占用更少的磁盘和仓库空间。</li>
<li><strong>分发速度</strong>：更小的镜像 <code>push</code> 和 <code>pull</code> 都更快，能极大地提升 CI&#x2F;CD 效率和应用部署速度。</li>
</ul>
<p><strong>实践方法一：选择一个精简的基础镜像</strong></p>
<p><code>FROM</code> 是 <code>Dockerfile</code> 的第一行，也是决定镜像大小的起点。</p>
<ul>
<li><strong><code>ubuntu</code> (或 <code>centos</code>)</strong>: 包含完整的操作系统工具，体积最大，通常几百MB。适合需要大量系统工具的场景。</li>
<li><strong><code>image:tag-slim</code> (如 <code>python:3.9-slim</code>)</strong>: 官方提供的“瘦身版”，移除了很多非必需的工具包，体积适中。<strong>通常是生产环境的首选。</strong></li>
<li><strong><code>alpine</code></strong>: 基于 Alpine Linux，一个极度轻量化的发行版。体积最小，通常只有几MB。但它使用 <code>musl</code> 代替 <code>glibc</code> 作为 C 标准库，偶尔可能遇到兼容性问题。</li>
</ul>
<p><strong>建议</strong>：<strong>没有特殊理由，就从 <code>slim</code> 版本开始。如果对体积有极致要求，再考虑 <code>alpine</code>。</strong></p>
<p><strong>实践方法二：使用多阶段构建 (Multi-Stage Builds)</strong></p>
<p>这是减小镜像体积<strong>最有效</strong>的手段，尤其适用于需要编译的语言（如 Go, Java, Rust）或需要构建步骤的前端应用（如 Node.js, React）。</p>
<p><strong>核心思想</strong>：用一个包含完整构建工具的“构建镜像”来完成编译&#x2F;打包，然后把最终的产物（可执行文件、静态资源等）复制到一个干净的、极小的“生产镜像”中。</p>
<p><strong>糟糕的例子 (单阶段)</strong>:</p>
<pre class="line-numbers language-language-docker"><code class="language-language-docker"># 把所有构建工具和中间产物都打进了最终镜像
FROM node:16
WORKDIR /app
COPY package*.json ./
RUN npm install
COPY . .
RUN npm run build # 生成了 dist 目录

# 问题：最终镜像里包含了完整的Node.js、npm、devDependencies等，非常臃肿
CMD ["npm", "start"]
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这个镜像可能有 1GB 大小。</p>
<p><strong>优秀的例子 (多阶段)</strong>:</p>
<pre class="line-numbers language-language-docker"><code class="language-language-docker"># --- 构建阶段 (Builder Stage) ---
# 使用一个完整的 Node.js 镜像，并给它起个别名 `builder`
FROM node:16 AS builder
WORKDIR /app
COPY package*.json ./
RUN npm install
COPY . .
RUN npm run build

# --- 生产阶段 (Production Stage) ---
# 使用一个极度轻量化的 Nginx 服务器作为最终镜像
FROM nginx:1.21-alpine
# 只从 `builder` 阶段复制出最终的静态文件产物
COPY --from=builder /app/dist /usr/share/nginx/html

# EXPOSE 80 (Nginx 默认)
# CMD ["nginx", "-g", "daemon off;"] (Nginx 默认)
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这个最终镜像可能只有 20MB 大小。对比天差地别！</p>
<p><strong>实践方法三：清理不必要的中间文件</strong></p>
<p>在 <code>RUN</code> 指令中，应该把多个命令用 <code>&amp;&amp;</code> 串联起来，并在结尾清理掉缓存和临时文件。因为每一条 <code>RUN</code> 都会创建一个新的层，如果你不一次性清理，垃圾就会被永久封存在上一层里。</p>
<p><strong>糟糕的例子</strong>:</p>
<pre class="line-numbers language-language-docker"><code class="language-language-docker"># 垃圾被留在了第一层
RUN apt-get update
# 安装了软件，但缓存还在
RUN apt-get install -y curl
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>优秀的例子</strong>:</p>
<pre class="line-numbers language-language-docker"><code class="language-language-docker">RUN apt-get update && \
    apt-get install -y curl && \
    rm -rf /var/lib/apt/lists/*
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>把所有操作合并到一条 <code>RUN</code> 指令中，并在结尾删除了 apt 缓存，确保这一层是干净的。</p>
<h3 id="2-高效利用构建缓存"><a href="#2-高效利用构建缓存" class="headerlink" title="2. 高效利用构建缓存"></a><strong>2. 高效利用构建缓存</strong></h3><p>我们之前讨论过缓存的原理。这里的核心就是<strong>优化 <code>Dockerfile</code> 的指令顺序</strong>。</p>
<p><strong>核心原则：把变化最少、最稳定的层放在前面；把最频繁变化的层放在后面。</strong></p>
<p><strong>糟糕的例子</strong>:</p>
<pre class="line-numbers language-language-docker"><code class="language-language-docker">FROM python:3.9-slim
WORKDIR /app
# 只要任何一个代码文件变动，下面整块都要重新执行
COPY . .
# 导致每次改代码都要重新安装所有依赖，非常慢
RUN pip install -r requirements.txt
CMD ["python", "app.py"]
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>优秀的例子</strong>:</p>
<pre class="line-numbers language-language-docker"><code class="language-language-docker">FROM python:3.9-slim
WORKDIR /app
# 1. 先只复制依赖文件。这个文件通常不怎么变。
COPY requirements.txt .
# 2. 安装依赖。只要 requirements.txt 不变，这一层就会被完美缓存。
RUN pip install -r requirements.txt
# 3. 最后再复制你的代码。这样你频繁修改代码时，上面耗时的步骤都能利用缓存。
COPY . .
CMD ["python", "app.py"]
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="Docker网络操作"><a href="#Docker网络操作" class="headerlink" title="Docker网络操作"></a>Docker网络操作</h2><p>Docker 主要有三种常见的网络模式：</p>
<ol>
<li><strong><code>bridge</code> (桥接模式)</strong>：默认模式，单机环境下的“局域网”。Docker 会为这个网络分配一个私有的 IP 地址段（比如 <code>172.17.0.0/16</code>），每个接入的容器都会获得一个自己的内部 IP 地址。</li>
<li><strong><code>host</code> (主机模式)</strong>：直接使用主机的网络，性能最好但隔离性差。容器直接共享使用宿主机的网络协议栈。在容器内部看到的网卡、IP 地址、端口等，都和宿主机上完全一样。</li>
<li><strong><code>overlay</code> (覆盖网络)</strong>：用于多台主机之间的容器通信，是集群（Swarm）的基石。<br>它可以在多台不同的物理或虚拟主机之上，创建一个统一的、虚拟的二层网络。这使得连接到同一个 <code>overlay</code> 网络的容器，即使它们分布在不同的主机上，也感觉像是在同一个局域网内，可以互相直接通信。</li>
</ol>
<h2 id="数据持久化：Volume-vs-Bind-Mount"><a href="#数据持久化：Volume-vs-Bind-Mount" class="headerlink" title="数据持久化：Volume vs. Bind Mount"></a>数据持久化：<code>Volume</code> vs. <code>Bind Mount</code></h2><h3 id="1-数据卷-Volumes-：Docker-的“专业行李箱”"><a href="#1-数据卷-Volumes-：Docker-的“专业行李箱”" class="headerlink" title="1. 数据卷 (Volumes)：Docker 的“专业行李箱”"></a><strong>1. 数据卷 (Volumes)：Docker 的“专业行李箱”</strong></h3><p>这是 Docker官方<strong>最推荐</strong>的数据持久化方式。</p>
<ul>
<li><strong>是什么</strong>：Volume 是一个由 <strong>Docker 自己创建和管理</strong>的特殊目录。它独立于容器的生命周期，专门用来存放持久化数据。在 Linux 系统上，它通常位于 <code>/var/lib/docker/volumes/</code> 目录下，但我们<strong>不应该</strong>直接去操作这个目录。</li>
<li><strong>工作原理</strong>：你可以把它想象成一个 Docker 帮你保管的、可插拔的“U盘”。你创建一个 Volume (U盘)，然后把它“插”到容器的指定目录上。即使容器这个“电脑”坏了、被扔掉了，这个“U盘”和里面的数据都还在，可以再插到新的容器上继续使用。</li>
<li><strong>特点</strong>：<ul>
<li><strong>Docker 管理</strong>：创建、删除、查看等都通过 Docker 命令进行，与宿主机的具体目录结构解耦。</li>
<li><strong>独立生命周期</strong>：删除容器时，Volume <strong>不会</strong>被删除（除非你显式删除它）。</li>
<li><strong>高性能</strong>：在 Linux 上，Volume 的读写性能接近原生磁盘。</li>
<li><strong>跨平台兼容性好</strong>：无论你在 Windows, macOS 还是 Linux 上，Volume 的行为都是一致的。</li>
<li><strong>更安全</strong>：容器只能访问到挂载的 Volume，无法随意访问宿主机的其他文件。</li>
</ul>
</li>
<li><strong>适用场景</strong>：<ul>
<li><strong>数据库数据</strong>：比如 MySQL, PostgreSQL 的数据目录。</li>
<li><strong>应用生成的内容</strong>：比如用户上传的图片、附件等。</li>
<li>需要在多个容器之间<strong>共享数据</strong>的场景。</li>
<li><strong>所有需要持久化的生产环境数据</strong>。</li>
</ul>
</li>
</ul>
<p><strong>示例</strong>：</p>
<pre class="line-numbers language-language-docker"><code class="language-language-docker"># 1. 创建一个 Volume
docker volume create my-db-data

# 2. 运行 MySQL 容器，并将这个 Volume 挂载到容器内的数据目录
# -v my-db-data:/var/lib/mysql
#  (Volume名称):(容器内路径)
docker run -d --name mysql-db \
  -v my-db-data:/var/lib/mysql \
  -e MYSQL_ROOT_PASSWORD=secret \
  mysql:5.7
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="2-绑定挂载-Bind-Mounts-：宿主机的“任意门”"><a href="#2-绑定挂载-Bind-Mounts-：宿主机的“任意门”" class="headerlink" title="2. 绑定挂载 (Bind Mounts)：宿主机的“任意门”"></a><strong>2. 绑定挂载 (Bind Mounts)：宿主机的“任意门”</strong></h3><p>这种方式是直接将宿主机上的<strong>一个已存在的目录或文件</strong>挂载到容器中。</p>
<ul>
<li><strong>是什么</strong>：Bind Mount 就是在容器和宿主机之间开了一扇“任意门”。门的一边是宿主机的某个指定路径，另一边是容器内的某个路径。两边的内容是实时同步、完全一致的。</li>
<li><strong>工作原理</strong>：容器内的进程对挂载点的读写，实际上就是直接对宿主机文件系统的读写。容器内的 <code>uid/gid</code> 权限也可能会影响到宿主机上的文件权限。</li>
<li><strong>特点</strong>：<ul>
<li><strong>直接映射</strong>：非常直观，所见即所得。</li>
<li><strong>依赖宿主机</strong>：强依赖于宿主机的特定文件路径。如果换一台机器，这个路径可能不存在，导致无法启动。</li>
<li><strong>潜在安全风险</strong>：如果挂载了像 <code>/</code> 或 <code>/etc</code> 这样的系统目录，容器内的进程（尤其是 root 用户）就可能修改甚至破坏宿主机系统。</li>
<li><strong>性能</strong>：在 Linux 上性能也很好，但在 macOS 和 Windows 上，因为有虚拟化文件系统的介入，性能可能会比 Volume 差一些。</li>
</ul>
</li>
<li><strong>适用场景</strong>：<ul>
<li><strong>开发环境</strong>：这是 Bind Mount 最核心、最完美的应用场景。你可以把本地的<strong>源代码目录</strong>挂载到容器里，这样你在本地 IDE 里修改代码，容器内的应用可以立刻感知到变化（比如用 <code>nodemon</code> 实现热更新），无需重新构建镜像。</li>
<li>需要将主机的某些<strong>配置文件</strong>（如 <code>nginx.conf</code>）共享给容器使用的场景。</li>
</ul>
</li>
</ul>
<p><strong>示例</strong>：</p>
<pre class="line-numbers language-language-docker"><code class="language-language-docker"># 把宿主机当前目录下的 `my-app` 文件夹，挂载到容器内的 `/app` 目录
# -v $(pwd)/my-app:/app
#  (宿主机绝对路径):(容器内路径)
docker run -d --name dev-container \
  -v $(pwd)/my-app:/app \
  my-dev-image
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="如何分析Docker镜像的大小组成"><a href="#如何分析Docker镜像的大小组成" class="headerlink" title="如何分析Docker镜像的大小组成"></a>如何分析Docker镜像的大小组成</h2><h3 id="方法一：基础体检-docker-history"><a href="#方法一：基础体检-docker-history" class="headerlink" title="方法一：基础体检 - docker history"></a><strong>方法一：基础体检 - <code>docker history</code></strong></h3><p>这是 Docker 自带的最基础的工具，可以快速查看镜像的“履历”，也就是它的分层历史和每一层的大小。</p>
<ul>
<li><p><strong>如何使用</strong>：</p>
<pre class="line-numbers language-language-docker"><code class="language-language-docker">docker history your-image:tag
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
<li><p><strong>能看到什么</strong>：<br>它会列出构成这个镜像的每一层，以及创建该层的 <code>Dockerfile</code> 指令（<code>CREATED BY</code> 列）和该层自身的大小（<code>SIZE</code> 列）。</p>
<pre class="line-numbers language-language-docker"><code class="language-language-docker">IMAGE          CREATED         CREATED BY                                      SIZE
f1a3a4b5c6d7   5 minutes ago   /bin/sh -c #(nop) CMD ["./my-app"]              0B
a2b3c4d5e6f7   5 minutes ago   /bin/sh -c #(nop) COPY file:123... in /app/     15MB
c3d4e5f6a7b8   10 minutes ago  /bin/sh -c pip install -r requirements.txt      120MB  <-- 尺寸可疑！
d4e5f6a7b8c9   2 hours ago     /bin/sh -c #(nop) COPY file:456... in /app/     1KB
...
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p><strong>优点</strong>：</p>
<ul>
<li>无需安装任何额外工具，是 Docker 内置功能。</li>
<li>可以快速定位到是<strong>哪一条 <code>RUN</code> 或 <code>COPY</code> 命令</strong>导致了镜像体积的剧增。</li>
</ul>
</li>
<li><p><strong>缺点</strong>：</p>
<ul>
<li><strong>只能看到层的大小，看不到层里面具体是哪个文件大</strong>。比如上面那个 120MB 的层，我们只知道是 <code>pip install</code> 产生的，但不知道是 <code>numpy</code> 占了 80MB 还是 <code>pandas</code> 占了 100MB。</li>
</ul>
</li>
</ul>
<h3 id="方法三：专业分析工具-dive-强烈推荐"><a href="#方法三：专业分析工具-dive-强烈推荐" class="headerlink" title="方法三：专业分析工具 - dive (强烈推荐)"></a><strong>方法三：专业分析工具 - <code>dive</code> (强烈推荐)</strong></h3><p><code>dive</code> 是一个开源的第三方工具，是专门为分析 Docker 镜像而生的“神器”。它可以让你像透视一样看清镜像的每一层。</p>
<ul>
<li><p><strong>如何使用</strong>：<br>你需要先安装 <code>dive</code> (在 macOS 上可以用 <code>brew install dive</code>，其他系统请参考其 GitHub 页面)。然后执行：</p>
<pre class="line-numbers language-language-docker"><code class="language-language-docker">dive your-image:tag
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
<li><p><strong>能看到什么</strong>：<br><code>dive</code> 会打开一个交互式的界面，主要分为两个窗格：</p>
<ul>
<li><strong>左侧窗格</strong>：显示了镜像的所有<strong>分层</strong>，和 <code>docker history</code> 的结果类似。你可以用上下键在不同层之间切换。</li>
<li><strong>右侧窗格</strong>：实时显示<strong>当前选中层的文件系统树</strong>。你可以像在文件管理器里一样，展开目录，查看文件。</li>
</ul>
</li>
</ul>
<h2 id="Docker-Compose-单机环境下的“轻量级”编排工具。"><a href="#Docker-Compose-单机环境下的“轻量级”编排工具。" class="headerlink" title="Docker Compose -  单机环境下的“轻量级”编排工具。"></a>Docker Compose -  <strong>单机环境下的“轻量级”编排工具</strong>。</h2><pre class="line-numbers language-language-yaml"><code class="language-language-yaml">version: '3' # 文件格式版本
services: # “食材”列表，定义了应用包含的所有服务
  
  web: # 第一个服务，名为 "web"
    image: nginx:latest # 使用哪个镜像
    ports: # 端口映射
      - "80:80"
    volumes: # 数据挂载
      - ./html:/usr/share/nginx/html
    networks: # 连接到哪个网络
      - webnet
     
  db: # 第二个服务，名为 "db"
    image: mysql:5.7
    environment: # 环境变量
      MYSQL_ROOT_PASSWORD: password
    volumes:
      - db_data:/var/lib/mysql
    networks:
      - webnet

volumes: # 定义这个应用会用到的数据卷
  db_data:

networks: # 定义这个应用会用到的网络
  webnet:
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="核心优势"><a href="#核心优势" class="headerlink" title="核心优势"></a><strong>核心优势</strong></h3><ol>
<li><strong>一键管理，简单高效</strong><ul>
<li><code>docker-compose up -d</code>：一键启动并后台运行整个应用。</li>
<li><code>docker-compose down</code>：一键停止并删除所有相关的容器、网络。</li>
<li><code>docker-compose logs -f</code>：一键查看所有服务的日志。<br> 你不再需要关心单个容器，而是从<strong>整个应用</strong>的层面来管理服务。</li>
</ul>
</li>
<li><strong>自动化的服务发现与网络</strong><br>当你运行 <code>docker-compose up</code> 时，Compose 会<strong>自动创建一个专用的桥接网络</strong>（在上面的例子里就是 <code>webnet</code>）。<ul>
<li>处在这个网络里的所有服务（<code>web</code> 和 <code>db</code>），可以<strong>直接通过服务名作为主机名进行通信</strong>。</li>
<li>例如，<code>web</code> 服务可以直接连接 <code>mysql://db:3306</code> 来访问数据库，而不需要关心 <code>db</code> 容器的 IP 地址是什么。这个过程是全自动的。</li>
</ul>
</li>
<li><strong>配置即代码，易于分享和版本控制</strong><code>docker-compose.yml</code> 是一个纯文本文件，你可以像对待代码一样，把它提交到 Git 仓库里。<ul>
<li><strong>团队协作</strong>：新同事加入项目时，他只需要 <code>git pull</code> 拉取代码，然后运行 <code>docker-compose up</code>，一个完全一致的开发环境瞬间就搭建好了。</li>
<li><strong>环境一致性</strong>：确保了开发、测试、甚至简单生产环境的配置都是完全一致的，避免了“在我电脑上是好的”这种经典问题。</li>
</ul>
</li>
</ol>
<h2 id="Docker-Swarm"><a href="#Docker-Swarm" class="headerlink" title="Docker Swarm"></a>Docker Swarm</h2><p><strong>定义：Docker 官方内置的、原生的集群管理和编排工具</strong>。<br>Docker Swarm 则是把<strong>多台安装了 Docker 的主机（物理机或虚拟机）聚合在一起，组成一个“虚拟的单一主机”</strong>，也就是一个 Docker 集群。</p>
<h3 id="核心概念与角色"><a href="#核心概念与角色" class="headerlink" title="核心概念与角色"></a>核心概念与角色</h3><ul>
<li><strong>Swarm (集群)</strong>: 指的是由多台 Docker 主机组成的整个集群。</li>
<li><strong>Node (节点)</strong>: 集群中的<strong>每一台</strong> Docker 主机就是一个节点。节点分为两种角色：<ul>
<li><strong>Manager Node (管理节点)</strong>: <strong>集群的“大脑”和“指挥官”</strong>。<ul>
<li><strong>职责</strong>：接收用户的指令（比如 <code>docker service create</code>）、维护集群的期望状态、决定将容器（任务）调度到哪个节点上运行、管理整个集群的状态。</li>
<li><strong>高可用</strong>：为了防止“指挥官”单点故障，生产环境通常会设置 3 个或 5 个 Manager 节点。它们之间通过 Raft 一致性算法同步数据，即使一个 Manager 宕机，其他 Manager 也能接管工作。</li>
</ul>
</li>
<li><strong>Worker Node (工作节点)</strong>: <strong>集群的“工兵”和“劳动力”</strong>。<ul>
<li><strong>职责</strong>：不参与决策，唯一的任务就是接收来自 Manager 节点的指令，然后<strong>运行或停止容器（任务）</strong>。它们是真正干活的。</li>
</ul>
</li>
</ul>
</li>
<li><strong>Service (服务)</strong>: 这是在 Swarm 模式下部署应用的<strong>核心抽象</strong>。<ul>
<li>它不再是单个的容器，而是一个<strong>服务定义</strong>。你向 Manager 声明：“我想要一个名为 <code>webapp</code> 的服务，它使用 <code>nginx</code> 镜像，需要一直保持 <strong>3 个副本</strong>在运行，并对外暴露 80 端口”。</li>
<li>Swarm 会持续监控，确保任何时候都有 3 个符合你定义的容器在运行。</li>
</ul>
</li>
<li><strong>Task (任务)</strong>: 一个服务运行的<strong>具体实例</strong>，也就是一个<strong>容器</strong>。如果一个服务有 3 个副本（replicas），那么它就对应着 3 个正在运行的任务（容器）。<strong>任务是 Swarm 中最小的调度单位。</strong></li>
</ul>
<h3 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h3><p><strong>第一步：初始化集群</strong></p>
<p>在一台准备当 Manager 的机器上执行：</p>
<pre class="line-numbers language-language-yaml"><code class="language-language-yaml">docker swarm init --advertise-addr <MANAGER-IP>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>这个命令会把这台机器变成 Swarm 集群的第一个（也是目前唯一一个）Manager 节点。并且它会生成一个“入群口令”(Token)。</p>
<p><strong>第二步：节点加入集群</strong><br>在其他机器上，使用第一步生成的口令，让它们作为 Worker 节点加入集群：</p>
<pre class="line-numbers language-language-yaml"><code class="language-language-yaml">docker swarm join --token <YOUR-TOKEN> <MANAGER-IP>:2377
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><strong>第三步：部署服务 (下发乐谱)</strong></p>
<p>现在，在<strong>Manager 节点</strong>上告诉“Manager ”要部署什么服务：</p>
<pre class="line-numbers language-language-yaml"><code class="language-language-yaml">docker service create --name web --replicas 3 -p 8080:80 nginx
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>docker swarm启动服务的命令是：<code>docker service create</code></p>
<ul>
<li>我想要一个名为 <code>web</code> 的<strong>服务</strong>。</li>
<li>它的期望状态是永远保持 <strong>3 个副本</strong>（<code>-replicas 3</code>）。</li>
<li>它使用 <code>nginx</code> 镜像。</li>
<li>将集群的 <code>8080</code> 端口映射到这个服务所有副本的 <code>80</code> 端口。</li>
</ul>
<p><strong>第四步：Swarm 的魔法：声明式服务与自愈</strong></p>
<ol>
<li><strong>调度</strong>：Manager 节点收到命令后，会查看所有 Worker 节点的负载情况，然后决定在哪几个 Worker 上启动这 3 个 Nginx 容器（任务）。</li>
<li><strong>路由网格 (Routing Mesh)</strong>： <code>-p 8080:80</code> 这个端口映射非常强大。无论你访问<strong>集群中任何一个节点</strong>的 <code>8080</code> 端口，Swarm 都会自动把请求负载均衡到这 3 个 Nginx 容器中的一个，不管那个容器具体在哪台机器上。</li>
<li><strong>自愈 (Self-healing)</strong>：这是编排平台的核心魅力。假设一个运行着 Nginx 容器的 Worker 节点突然宕机了。<ul>
<li>Manager 会立刻发现：“警告！<code>web</code> 服务的当前状态（2个副本）不等于期望状态（3个副本）！”</li>
<li>为了恢复到期望状态，Manager 会马上在另一个健康的 Worker 节点上，<strong>自动启动一个新的 Nginx 容器</strong>。</li>
<li>整个过程无需人工干预，服务会自动恢复。你只需要声明你的“期望”，Swarm 会搞定一切。</li>
</ul>
</li>
</ol>
<p><strong>第五步：扩缩容与更新</strong></p>
<ul>
<li><p><strong>扩容</strong>：业务高峰来了，你想把 3 个 Nginx 增加到 10 个。</p>
<pre class="line-numbers language-language-yaml"><code class="language-language-yaml">docker service scale web=10
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>  Manager 会立刻调度，启动 7 个新的 Nginx 容器。</p>
</li>
<li><p><strong>更新</strong>：你想把 Nginx 的版本升级到 <code>1.21</code>。</p>
<pre class="line-numbers language-language-yaml"><code class="language-language-yaml">docker service update --image nginx:1.21 web
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>  Swarm 会自动进行“滚动更新”，一个一个地用新版本容器替换旧版本容器，保证服务在更新过程中不中断。</p>
</li>
</ul>
<h3 id="路由网格-Routing-Mesh"><a href="#路由网格-Routing-Mesh" class="headerlink" title="路由网格 (Routing Mesh)"></a>路由网格 (Routing Mesh)</h3><pre class="line-numbers language-language-yaml"><code class="language-language-yaml">docker service create --name my-nginx-service --replicas 3 -p 8080:80 nginx
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>这里的 <code>-p 8080:80</code> 已经不是“把主机端口 8080 映射到单个容器的 80 端口”这个简单的意思了。它的含义是：</p>
<p><strong>“在整个集群的所有节点上，都发布 8080 端口，并让它成为 <code>my-nginx-service</code> 这个服务的统一入口。”</strong></p>
<ul>
<li><strong>发布端口</strong>：当你创建服务并发布端口后，Swarm 会在<strong>集群中的每一个节点</strong>上都监听 8080 端口，准备接收外部流量。</li>
<li><strong>智能路由</strong>：无论你的请求到达<strong>哪一个节点</strong>的 8080 端口（可以是 Manager，也可以是 Worker，即使这个节点上并没有运行 Nginx 容器），路由网格都会接收这个请求。</li>
<li><strong>负载均衡</strong>：路由网格知道 <code>my-nginx-service</code> 背后有 3 个正在运行的容器（任务），也知道它们各自的内部 IP 地址。它会自动将接收到的请求，以轮询的方式<strong>负载均衡</strong>到这 3 个容器中的一个去处理。</li>
</ul>
<h2 id="一、Docker-基础配置"><a href="#一、Docker-基础配置" class="headerlink" title="一、Docker 基础配置"></a>一、Docker 基础配置</h2><ol>
<li><p><strong>安装后配置</strong></p>
<pre class="line-numbers language-language-bash"><code class="language-language-bash"># 将当前用户添加到docker组（避免每次使用sudo）
sudo usermod -aG docker $USER

# 配置Docker开机自启
sudo systemctl enable docker
sudo systemctl start docker

# 查看Docker版本
docker version
docker info
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p><strong>配置镜像加速器</strong></p>
<pre class="line-numbers language-language-bash"><code class="language-language-bash"># 编辑Docker配置文件
sudo vim /etc/docker/daemon.json

# 添加镜像加速器配置
&#123;
  "registry-mirrors": [
    "<https://docker.m.daocloud.io>",
    "<https://dockerproxy.com>",
    "<https://docker.mirrors.ustc.edu.cn>",
    "<https://docker.nju.edu.cn>",
    "<https://iju9kaj2.mirror.aliyuncs.com>",
    "<http://hub-mirror.c.163.com>",
    "<https://cr.console.aliyun.com>",
    "<https://hub.docker.com>",
    "<http://mirrors.ustc.edu.cn>"
  ]
&#125;

# 重启Docker服务
sudo systemctl daemon-reload
sudo systemctl restart docker
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ol>
<h2 id="二、镜像管理"><a href="#二、镜像管理" class="headerlink" title="二、镜像管理"></a>二、镜像管理</h2><ol>
<li><p><strong>搜索和拉取镜像</strong></p>
<pre class="line-numbers language-language-bash"><code class="language-language-bash">docker search nginx                 # 搜索镜像
docker pull nginx                   # 拉取最新版本
docker pull nginx:1.21              # 拉取指定版本
docker pull ubuntu:20.04            # 拉取Ubuntu 20.04
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p><strong>查看本地镜像</strong></p>
<pre class="line-numbers language-language-bash"><code class="language-language-bash">docker images                       # 列出本地镜像
docker images -a                    # 显示所有镜像（包括中间层）
docker images nginx                 # 查看特定镜像
docker images --format "&#123;&#123;.ID&#125;&#125;: &#123;&#123;.Repository&#125;&#125;"  # 自定义格式输出
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p><strong>镜像详细信息</strong></p>
<pre class="line-numbers language-language-bash"><code class="language-language-bash">docker inspect nginx                # 查看镜像详细信息
docker history nginx                # 查看镜像历史
docker image prune                  # 清理未使用的镜像
docker rmi nginx:1.21               # 删除指定镜像
docker rmi $(docker images -q)      # 删除所有镜像
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p><strong>保存和加载镜像</strong></p>
<pre class="line-numbers language-language-bash"><code class="language-language-bash">docker save -o nginx.tar nginx:latest     # 保存镜像到tar文件
docker load -i nginx.tar                  # 从tar文件加载镜像
docker save nginx:latest | gzip > nginx.tar.gz  # 压缩保存
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
</li>
<li><p><strong>构建镜像</strong></p>
<pre class="line-numbers language-language-bash"><code class="language-language-bash">docker build -t myapp:1.0 .              # 从Dockerfile构建
docker build -t myapp:1.0 -f Dockerfile.dev .  # 指定Dockerfile
docker build --no-cache -t myapp:1.0 .   # 不使用缓存构建
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
</li>
</ol>
<h2 id="三、容器管理"><a href="#三、容器管理" class="headerlink" title="三、容器管理"></a>三、容器管理</h2><ol>
<li><p><strong>运行容器</strong></p>
<pre class="line-numbers language-language-bash"><code class="language-language-bash">docker run nginx                    # 运行nginx容器
docker run -d nginx                 # 后台运行
docker run -p 8080:80 nginx         # 端口映射
docker run --name mynginx nginx     # 指定容器名称
docker run -it ubuntu bash          # 交互式运行
docker run -e MYSQL_ROOT_PASSWORD=123456 mysql  # 设置环境变量
docker run -v /host/data:/container/data nginx  # 挂载数据卷
docker run --rm nginx               # 容器退出后自动删除
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p><strong>查看容器</strong></p>
<pre class="line-numbers language-language-bash"><code class="language-language-bash">docker ps                           # 查看运行中的容器
docker ps -a                        # 查看所有容器
docker ps -q                        # 只显示容器ID
docker ps --format "table &#123;&#123;.ID&#125;&#125;\\t&#123;&#123;.Names&#125;&#125;\\t&#123;&#123;.Status&#125;&#125;"
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p><strong>容器操作</strong></p>
<pre class="line-numbers language-language-bash"><code class="language-language-bash">docker start container_id           # 启动容器
docker stop container_id            # 停止容器
docker restart container_id         # 重启容器
docker pause container_id           # 暂停容器
docker unpause container_id         # 恢复容器
docker rm container_id              # 删除容器
docker rm -f container_id           # 强制删除运行中的容器
docker container prune              # 清理停止的容器
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p><strong>容器交互</strong></p>
<pre class="line-numbers language-language-bash"><code class="language-language-bash">docker exec -it container_id bash   # 进入运行中的容器
docker exec container_id ls /app    # 在容器中执行命令
docker attach container_id          # 附加到容器
docker cp file.txt container_id:/app/  # 复制文件到容器
docker cp container_id:/app/file.txt ./  # 从容器复制文件
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p><strong>查看容器信息</strong></p>
<pre class="line-numbers language-language-bash"><code class="language-language-bash">docker logs container_id            # 查看容器日志
docker logs -f container_id         # 实时查看日志
docker logs --tail 100 container_id # 查看最后100行
docker top container_id             # 查看容器进程
docker stats                        # 查看容器资源使用
docker inspect container_id         # 查看容器详细信息
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ol>
<h2 id="四、网络管理"><a href="#四、网络管理" class="headerlink" title="四、网络管理"></a>四、网络管理</h2><ol>
<li><p><strong>网络操作</strong></p>
<pre class="line-numbers language-language-bash"><code class="language-language-bash">docker network ls                   # 列出网络
docker network create mynet         # 创建网络
docker network inspect bridge       # 查看网络详情
docker network rm mynet             # 删除网络
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p><strong>容器网络</strong></p>
<pre class="line-numbers language-language-bash"><code class="language-language-bash">docker run --network=mynet nginx    # 指定网络运行容器
docker network connect mynet container_id    # 连接容器到网络
docker network disconnect mynet container_id  # 断开连接
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
</li>
<li><p><strong>端口映射</strong></p>
<pre class="line-numbers language-language-bash"><code class="language-language-bash">docker run -p 8080:80 nginx         # 映射端口8080到容器80
docker run -p 127.0.0.1:8080:80 nginx  # 只绑定本地地址
docker run -P nginx                 # 随机映射端口
docker port container_id            # 查看端口映射
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ol>
<h2 id="五、数据卷管理"><a href="#五、数据卷管理" class="headerlink" title="五、数据卷管理"></a>五、数据卷管理</h2><ol>
<li><p><strong>创建和管理数据卷</strong></p>
<pre class="line-numbers language-language-bash"><code class="language-language-bash">docker volume create mydata         # 创建数据卷
docker volume ls                    # 列出数据卷
docker volume inspect mydata        # 查看数据卷详情
docker volume rm mydata             # 删除数据卷
docker volume prune                 # 清理未使用的数据卷
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p><strong>使用数据卷</strong></p>
<pre class="line-numbers language-language-bash"><code class="language-language-bash">docker run -v mydata:/app nginx     # 挂载命名数据卷
docker run -v /host/path:/container/path nginx  # 挂载主机目录
docker run --mount source=mydata,target=/app nginx  # 使用--mount
docker run -v $(pwd):/app nginx     # 挂载当前目录
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ol>
<h2 id="六、Docker-Compose"><a href="#六、Docker-Compose" class="headerlink" title="六、Docker Compose"></a>六、Docker Compose</h2><ol>
<li><p><strong>基本命令</strong></p>
<pre class="line-numbers language-language-bash"><code class="language-language-bash">docker-compose up                   # 启动服务
docker-compose up -d                # 后台启动
docker-compose down                 # 停止并删除容器
docker-compose ps                   # 查看服务状态
docker-compose logs                 # 查看日志
docker-compose logs -f service_name # 查看特定服务日志
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p><strong>服务管理</strong></p>
<pre class="line-numbers language-language-bash"><code class="language-language-bash">docker-compose start                # 启动服务
docker-compose stop                 # 停止服务
docker-compose restart              # 重启服务
docker-compose build                # 构建服务
docker-compose pull                 # 拉取服务镜像
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p><strong>docker-compose.yml示例</strong></p>
<pre class="line-numbers language-language-yaml"><code class="language-language-yaml">version: '3'
services:
  web:
    image: nginx:latest
    ports:
      - "80:80"
    volumes:
      - ./html:/usr/share/nginx/html
    networks:
      - webnet

  db:
    image: mysql:5.7
    environment:
      MYSQL_ROOT_PASSWORD: password
    volumes:
      - db_data:/var/lib/mysql
    networks:
      - webnet

volumes:
  db_data:

networks:
  webnet:
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ol>
<h2 id="七、Dockerfile编写"><a href="#七、Dockerfile编写" class="headerlink" title="七、Dockerfile编写"></a>七、Dockerfile编写</h2><ol>
<li><p><strong>基础指令</strong></p>
<pre><code># 基础镜像
FROM node:14-alpine

# 维护者信息
LABEL maintainer=&quot;name@example.com&quot;

# 设置工作目录
WORKDIR /app

# 复制文件
COPY package*.json ./
COPY . .

# 运行命令
RUN npm install

# 环境变量
ENV NODE_ENV=production
ENV PORT=3000

# 暴露端口
EXPOSE 3000

# 启动命令
CMD [&quot;npm&quot;, &quot;start&quot;]
</code></pre>
</li>
<li><p><strong>多阶段构建</strong></p>
<pre><code># 构建阶段
FROM node:14 AS builder
WORKDIR /app
COPY package*.json ./
RUN npm install
COPY . .
RUN npm run build

# 生产阶段
FROM nginx:alpine
COPY --from=builder /app/dist /usr/share/nginx/html
EXPOSE 80
CMD [&quot;nginx&quot;, &quot;-g&quot;, &quot;daemon off;&quot;]
</code></pre>
</li>
<li><p><strong>最佳实践</strong></p>
<pre><code># 使用特定版本的基础镜像
FROM node:14.17.0-alpine

# 使用非root用户
RUN addgroup -S appgroup &amp;&amp; adduser -S appuser -G appgroup
USER appuser

# 利用构建缓存
COPY package*.json ./
RUN npm install
COPY . .

# 减少层数
RUN apt-get update &amp;&amp; apt-get install -y \\
    package1 \\
    package2 \\
    &amp;&amp; rm -rf /var/lib/apt/lists/*
</code></pre>
</li>
</ol>
<h2 id="八、镜像仓库操作"><a href="#八、镜像仓库操作" class="headerlink" title="八、镜像仓库操作"></a>八、镜像仓库操作</h2><ol>
<li><p><strong>登录和推送</strong></p>
<pre class="line-numbers language-language-bash"><code class="language-language-bash">docker login                        # 登录Docker Hub
docker login registry.example.com   # 登录私有仓库
docker tag myapp:1.0 username/myapp:1.0  # 标记镜像
docker push username/myapp:1.0      # 推送镜像
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p><strong>私有仓库</strong></p>
<pre class="line-numbers language-language-bash"><code class="language-language-bash"># 运行私有仓库
docker run -d -p 5000:5000 --name registry registry:2

# 标记并推送到私有仓库
docker tag myapp:1.0 localhost:5000/myapp:1.0
docker push localhost:5000/myapp:1.0

# 从私有仓库拉取
docker pull localhost:5000/myapp:1.0
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ol>
<h2 id="九、容器资源限制"><a href="#九、容器资源限制" class="headerlink" title="九、容器资源限制"></a>九、容器资源限制</h2><ol>
<li><p><strong>CPU限制</strong></p>
<pre class="line-numbers language-language-bash"><code class="language-language-bash">docker run --cpus=2 nginx           # 限制使用2个CPU
docker run --cpu-shares=512 nginx   # CPU共享权重
docker run --cpuset-cpus="0,1" nginx  # 指定CPU核心
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
</li>
<li><p><strong>内存限制</strong></p>
<pre class="line-numbers language-language-bash"><code class="language-language-bash">docker run -m 512m nginx            # 限制内存512MB
docker run --memory-swap=1g nginx   # 限制总内存(含swap)
docker run --oom-kill-disable nginx # 禁用OOM killer
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
</li>
<li><p><strong>其他资源限制</strong></p>
<pre class="line-numbers language-language-bash"><code class="language-language-bash">docker run --device-read-bps /dev/sda:1mb nginx  # 限制磁盘读取速度
docker run --device-write-bps /dev/sda:1mb nginx # 限制磁盘写入速度
docker run --pids-limit 100 nginx   # 限制进程数
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
</li>
</ol>
<h2 id="十、Docker健康检查"><a href="#十、Docker健康检查" class="headerlink" title="十、Docker健康检查"></a>十、Docker健康检查</h2><ol>
<li><p><strong>Dockerfile中定义</strong></p>
<pre><code>HEALTHCHECK --interval=30s --timeout=3s \\
  CMD curl -f &lt;http://localhost/&gt; || exit 1
</code></pre>
</li>
<li><p><strong>运行时指定</strong></p>
<pre class="line-numbers language-language-bash"><code class="language-language-bash">docker run -d --health-cmd="curl -f <http://localhost/> || exit 1" \\
           --health-interval=30s \\
           --health-timeout=3s \\
           --health-retries=3 \\
           nginx
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p><strong>查看健康状态</strong></p>
<pre class="line-numbers language-language-bash"><code class="language-language-bash">docker inspect --format='&#123;&#123;.State.Health.Status&#125;&#125;' container_id
docker ps --filter health=healthy
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
</li>
</ol>
<h2 id="十一、日志管理"><a href="#十一、日志管理" class="headerlink" title="十一、日志管理"></a>十一、日志管理</h2><ol>
<li><p><strong>日志驱动配置</strong></p>
<pre class="line-numbers language-language-bash"><code class="language-language-bash"># 配置JSON文件日志驱动
docker run --log-driver=json-file \\
           --log-opt max-size=10m \\
           --log-opt max-file=3 \\
           nginx

# 配置syslog日志驱动
docker run --log-driver=syslog \\
           --log-opt syslog-address=tcp://192.168.0.42:123 \\
           nginx
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p><strong>查看日志</strong></p>
<pre class="line-numbers language-language-bash"><code class="language-language-bash">docker logs container_id            # 查看容器日志
docker logs -f --tail 100 container_id  # 实时查看最后100行
docker logs --since 30m container_id    # 查看最近30分钟的日志
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
</li>
</ol>
<h2 id="十二、清理和维护"><a href="#十二、清理和维护" class="headerlink" title="十二、清理和维护"></a>十二、清理和维护</h2><ol>
<li><p><strong>系统清理</strong></p>
<pre class="line-numbers language-language-bash"><code class="language-language-bash">docker system df                    # 查看Docker磁盘使用
docker system prune                 # 清理未使用的数据
docker system prune -a              # 清理所有未使用的数据
docker system prune --volumes       # 同时清理数据卷
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p><strong>资源清理</strong></p>
<pre class="line-numbers language-language-bash"><code class="language-language-bash">docker container prune              # 清理停止的容器
docker image prune                  # 清理未使用的镜像
docker volume prune                 # 清理未使用的数据卷
docker network prune                # 清理未使用的网络
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ol>
<h2 id="十三、故障排查"><a href="#十三、故障排查" class="headerlink" title="十三、故障排查"></a>十三、故障排查</h2><ol>
<li><p><strong>容器调试</strong></p>
<pre class="line-numbers language-language-bash"><code class="language-language-bash">docker logs container_id            # 查看容器日志
docker inspect container_id         # 查看容器详细信息
docker exec -it container_id sh     # 进入容器shell
docker diff container_id            # 查看容器文件变化
docker events                       # 查看Docker事件
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p><strong>网络调试</strong></p>
<pre class="line-numbers language-language-bash"><code class="language-language-bash">docker network inspect bridge       # 查看网络详情
docker exec container_id ping other_container  # 测试容器间连通性
docker exec container_id nslookup other_container  # DNS解析测试
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
</li>
<li><p><strong>性能分析</strong></p>
<pre class="line-numbers language-language-bash"><code class="language-language-bash">docker stats                        # 实时查看资源使用
docker top container_id             # 查看容器进程
docker inspect -f '&#123;&#123;.State.Pid&#125;&#125;' container_id  # 获取容器PID
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
</li>
</ol>
<h2 id="十四、安全最佳实践"><a href="#十四、安全最佳实践" class="headerlink" title="十四、安全最佳实践"></a>十四、安全最佳实践</h2><ol>
<li><p><strong>运行时安全</strong></p>
<pre class="line-numbers language-language-bash"><code class="language-language-bash"># 以只读模式运行容器
docker run --read-only nginx

# 限制容器capabilities
docker run --cap-drop=ALL --cap-add=NET_BIND_SERVICE nginx

# 使用非root用户运行
docker run --user=1000:1000 nginx
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p><strong>镜像安全</strong></p>
<pre class="line-numbers language-language-bash"><code class="language-language-bash"># 扫描镜像漏洞
docker scan nginx:latest

# 使用官方镜像或可信来源
docker pull docker.io/library/nginx:latest

# 签名验证
docker trust inspect nginx:latest
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ol>
<h2 id="十五、常用技巧和别名"><a href="#十五、常用技巧和别名" class="headerlink" title="十五、常用技巧和别名"></a>十五、常用技巧和别名</h2><ol>
<li><p><strong>实用别名</strong></p>
<pre class="line-numbers language-language-bash"><code class="language-language-bash"># 添加到~/.bashrc或~/.zshrc
alias dps='docker ps'
alias dpsa='docker ps -a'
alias di='docker images'
alias drm='docker rm $(docker ps -aq)'
alias drmi='docker rmi $(docker images -q)'
alias dex='docker exec -it'
alias dlog='docker logs -f'
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p><strong>常用组合命令</strong></p>
<pre class="line-numbers language-language-bash"><code class="language-language-bash"># 停止所有容器
docker stop $(docker ps -aq)

# 删除所有停止的容器
docker rm $(docker ps -aq -f status=exited)

# 删除所有未打标签的镜像
docker rmi $(docker images -f "dangling=true" -q)

# 查看容器IP地址
docker inspect -f '&#123;&#123;range .NetworkSettings.Networks&#125;&#125;&#123;&#123;.IPAddress&#125;&#125;&#123;&#123;end&#125;&#125;' container_id

# 导出容器文件系统
docker export container_id > container.tar
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ol>
<h2 id="十六、Docker-Swarm集群管理"><a href="#十六、Docker-Swarm集群管理" class="headerlink" title="十六、Docker Swarm集群管理"></a>十六、Docker Swarm集群管理</h2><ol>
<li><p><strong>初始化和加入集群</strong></p>
<pre class="line-numbers language-language-bash"><code class="language-language-bash"># 初始化Swarm集群
docker swarm init --advertise-addr 192.168.1.100

# 获取加入token
docker swarm join-token worker
docker swarm join-token manager

# 加入集群
docker swarm join --token SWMTKN-1-xxx 192.168.1.100:2377
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p><strong>服务管理</strong></p>
<pre class="line-numbers language-language-bash"><code class="language-language-bash"># 创建服务
docker service create --name web --replicas 3 -p 80:80 nginx

# 扩展服务
docker service scale web=5

# 更新服务
docker service update --image nginx:1.21 web

# 查看服务
docker service ls
docker service ps web
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ol>
<h2 id="十七、实际应用示例"><a href="#十七、实际应用示例" class="headerlink" title="十七、实际应用示例"></a>十七、实际应用示例</h2><ol>
<li><p><strong>Web应用部署</strong></p>
<pre class="line-numbers language-language-bash"><code class="language-language-bash"># 创建网络
docker network create webapp-net

# 运行数据库
docker run -d \\
  --name db \\
  --network webapp-net \\
  -e MYSQL_ROOT_PASSWORD=secret \\
  -e MYSQL_DATABASE=webapp \\
  -v mysql-data:/var/lib/mysql \\
  mysql:5.7

# 运行Web应用
docker run -d \\
  --name webapp \\
  --network webapp-net \\
  -p 8080:80 \\
  -e DB_HOST=db \\
  -e DB_USER=root \\
  -e DB_PASSWORD=secret \\
  -e DB_NAME=webapp \\
  webapp:latest
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p><strong>开发环境搭建</strong></p>
<pre class="line-numbers language-language-yaml"><code class="language-language-yaml"># docker-compose.yml
version: '3'
services:
  frontend:
    build: ./frontend
    volumes:
      - ./frontend:/app
      - /app/node_modules
    ports:
      - "3000:3000"
    command: npm start

  backend:
    build: ./backend
    volumes:
      - ./backend:/app
    ports:
      - "5000:5000"
    environment:
      - NODE_ENV=development
    depends_on:
      - db

  db:
    image: postgres:13
    volumes:
      - pgdata:/var/lib/postgresql/data
    environment:
      - POSTGRES_PASSWORD=secret
      - POSTGRES_DB=myapp

volumes:
  pgdata:
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p><strong>CI&#x2F;CD集成</strong></p>
<pre class="line-numbers language-language-bash"><code class="language-language-bash"># Jenkinsfile示例
pipeline &#123;
  agent &#123; docker &#123; image 'node:14' &#125; &#125;
  stages &#123;
    stage('Build') &#123;
      steps &#123;
        sh 'npm install'
        sh 'npm run build'
      &#125;
    &#125;
    stage('Test') &#123;
      steps &#123;
        sh 'npm test'
      &#125;
    &#125;
    stage('Docker Build') &#123;
      steps &#123;
        sh 'docker build -t myapp:$&#123;BUILD_NUMBER&#125; .'
      &#125;
    &#125;
    stage('Deploy') &#123;
      steps &#123;
        sh 'docker push myapp:$&#123;BUILD_NUMBER&#125;'
      &#125;
    &#125;
  &#125;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ol>

                
            </div>
            <hr/>

            



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/Docker/">
                                    <span class="chip bg-color">Docker</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">
<div id="article-share">

    

    

</div>

                </div>
            </div>
            
        </div>
    </div>

    

    

    

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/2024/08/10/linux-bi-ji/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/19.jpg" class="responsive-img" alt="Linux常用命令">
                        
                        <span class="card-title">Linux常用命令</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2024-08-10
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/%E7%AC%94%E8%AE%B0/" class="post-category">
                                    笔记
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/Linux/">
                        <span class="chip bg-color">Linux</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2024/05/04/redis/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/10.jpg" class="responsive-img" alt="Redis基础巩固">
                        
                        <span class="card-title">Redis基础巩固</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2024-05-04
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" class="post-category">
                                    数据库
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/Redis/">
                        <span class="chip bg-color">Redis</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>



<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>


  <!-- 是否加载使用自带的 prismjs. -->
  <script type="text/javascript" src="/libs/prism/prism.min.js"></script>


<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>



    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget card" style="background-color: white;">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h2, h3, h4'
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>




    <footer class="page-footer bg-color">
    

    <div class="container row center-align"
         style="margin-bottom: 15px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            
                <span id="year">2023-2025</span>
            
            <a href="/about" target="_blank">Sean</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            
            <br>
            
                &nbsp;<i class="fas fa-chart-area"></i>&nbsp;站点总字数:&nbsp;<span
                        class="white-color">112.5k</span>
            
            
            
                
            
            
                <span id="busuanzi_container_site_pv">
                &nbsp;|&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;
                    <span id="busuanzi_value_site_pv" class="white-color"></span>
            </span>
            
            
                <span id="busuanzi_container_site_uv">
                &nbsp;|&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;
                    <span id="busuanzi_value_site_uv" class="white-color"></span>
            </span>
            
            <br>

            <!-- 运行天数提醒. -->
            
                <span id="sitetime"> Loading ...</span>
                <script>
                    var calcSiteTime = function () {
                        var seconds = 1000;
                        var minutes = seconds * 60;
                        var hours = minutes * 60;
                        var days = hours * 24;
                        var years = days * 365;
                        var today = new Date();
                        var startYear = "2023";
                        var startMonth = "7";
                        var startDate = "28";
                        var startHour = "0";
                        var startMinute = "0";
                        var startSecond = "0";
                        var todayYear = today.getFullYear();
                        var todayMonth = today.getMonth() + 1;
                        var todayDate = today.getDate();
                        var todayHour = today.getHours();
                        var todayMinute = today.getMinutes();
                        var todaySecond = today.getSeconds();
                        var t1 = Date.UTC(startYear, startMonth, startDate, startHour, startMinute, startSecond);
                        var t2 = Date.UTC(todayYear, todayMonth, todayDate, todayHour, todayMinute, todaySecond);
                        var diff = t2 - t1;
                        var diffYears = Math.floor(diff / years);
                        var diffDays = Math.floor((diff / days) - diffYears * 365);

                        // 区分是否有年份.
                        var language = 'zh-CN';
                        if (startYear === String(todayYear)) {
                            document.getElementById("year").innerHTML = todayYear;
                            var daysTip = 'This site has been running for ' + diffDays + ' days';
                            if (language === 'zh-CN') {
                                daysTip = '本站已运行 ' + diffDays + ' 天';
                            } else if (language === 'zh-HK') {
                                daysTip = '本站已運行 ' + diffDays + ' 天';
                            }
                            document.getElementById("sitetime").innerHTML = daysTip;
                        } else {
                            document.getElementById("year").innerHTML = startYear + " - " + todayYear;
                            var yearsAndDaysTip = 'This site has been running for ' + diffYears + ' years and '
                                + diffDays + ' days';
                            if (language === 'zh-CN') {
                                yearsAndDaysTip = '本站已运行 ' + diffYears + ' 年 ' + diffDays + ' 天';
                            } else if (language === 'zh-HK') {
                                yearsAndDaysTip = '本站已運行 ' + diffYears + ' 年 ' + diffDays + ' 天';
                            }
                            document.getElementById("sitetime").innerHTML = yearsAndDaysTip;
                        }
                    }

                    calcSiteTime();
                </script>
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/HyxiaoGe" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>



    <a href="mailto:hyxiao97@gmail.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fas fa-envelope-open"></i>
    </a>













</div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script type="text/javascript">
$(function () {
    var searchFunc = function (path, search_id, content_id) {
        'use strict';
        $.ajax({
            url: path,
            dataType: "xml",
            success: function (xmlResponse) {
                // get the contents from search data
                var datas = $("entry", xmlResponse).map(function () {
                    return {
                        title: $("title", this).text(),
                        content: $("content", this).text(),
                        url: $("url", this).text()
                    };
                }).get();
                var $input = document.getElementById(search_id);
                var $resultContent = document.getElementById(content_id);
                $input.addEventListener('input', function () {
                    var str = '<ul class=\"search-result-list\">';
                    var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                    $resultContent.innerHTML = "";
                    if (this.value.trim().length <= 0) {
                        return;
                    }
                    // perform local searching
                    datas.forEach(function (data) {
                        var isMatch = true;
                        var data_title = data.title.trim().toLowerCase();
                        var data_content = data.content.trim().replace(/<[^>]+>/g, "").toLowerCase();
                        var data_url = data.url;
                        data_url = data_url.indexOf('/') === 0 ? data.url : '/' + data_url;
                        var index_title = -1;
                        var index_content = -1;
                        var first_occur = -1;
                        // only match artiles with not empty titles and contents
                        if (data_title !== '' && data_content !== '') {
                            keywords.forEach(function (keyword, i) {
                                index_title = data_title.indexOf(keyword);
                                index_content = data_content.indexOf(keyword);
                                if (index_title < 0 && index_content < 0) {
                                    isMatch = false;
                                } else {
                                    if (index_content < 0) {
                                        index_content = 0;
                                    }
                                    if (i === 0) {
                                        first_occur = index_content;
                                    }
                                }
                            });
                        }
                        // show search results
                        if (isMatch) {
                            str += "<li><a href='" + data_url + "' class='search-result-title'>" + data_title + "</a>";
                            var content = data.content.trim().replace(/<[^>]+>/g, "");
                            if (first_occur >= 0) {
                                // cut out 100 characters
                                var start = first_occur - 20;
                                var end = first_occur + 80;
                                if (start < 0) {
                                    start = 0;
                                }
                                if (start === 0) {
                                    end = 100;
                                }
                                if (end > content.length) {
                                    end = content.length;
                                }
                                var match_content = content.substr(start, end);
                                // highlight all keywords
                                keywords.forEach(function (keyword) {
                                    var regS = new RegExp(keyword, "gi");
                                    match_content = match_content.replace(regS, "<em class=\"search-keyword\">" + keyword + "</em>");
                                });

                                str += "<p class=\"search-result\">" + match_content + "...</p>"
                            }
                            str += "</li>";
                        }
                    });
                    str += "</ul>";
                    $resultContent.innerHTML = str;
                });
            }
        });
    };

    searchFunc('/search.xml', 'searchInput', 'searchResult');
});
</script>

    <!-- 白天和黑夜主题 -->
<div class="stars-con">
    <div id="stars"></div>
    <div id="stars2"></div>
    <div id="stars3"></div>  
</div>

<script>
    function switchNightMode() {
        $('<div class="Cuteen_DarkSky"><div class="Cuteen_DarkPlanet"></div></div>').appendTo($('body')),
        setTimeout(function () {
            $('body').hasClass('DarkMode') 
            ? ($('body').removeClass('DarkMode'), localStorage.setItem('isDark', '0'), $('#sum-moon-icon').removeClass("fa-sun").addClass('fa-moon')) 
            : ($('body').addClass('DarkMode'), localStorage.setItem('isDark', '1'), $('#sum-moon-icon').addClass("fa-sun").removeClass('fa-moon')),
            
            setTimeout(function () {
            $('.Cuteen_DarkSky').fadeOut(1e3, function () {
                $(this).remove()
            })
            }, 2e3)
        })
    }
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    

    
    
    

    <!-- 雪花特效 -->
     
        <script type="text/javascript">
            // 只在桌面版网页启用特效
            var windowWidth = $(window).width();
            if (windowWidth > 768) {
                document.write('<script type="text/javascript" src="/libs/others/snow.js"><\/script>');
            }
        </script>
    

    <!-- 鼠标星星特效 -->
    

    

    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    <script src="/libs/others/clicklove.js" async="async"></script>
    
    
    <script async src="/libs/others/busuanzi.pure.mini.js"></script>
    

    

    

    <!--腾讯兔小巢-->
    
    

    

    

    
    <script src="/libs/instantpage/instantpage.js" type="module"></script>
    

</body>

</html>
