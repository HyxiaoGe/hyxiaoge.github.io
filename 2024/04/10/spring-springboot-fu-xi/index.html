<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="Spring SpringBoot 复习, HyxiaoGe">
    <meta name="description" content="Spring、SpringBootIOC（Inversion of Control）定义IoC 即控制反转，是一种设计原则，它将应用程序的控制权从程序代码本身转移到外部容器或框架中。传统的程序设计中，程序内部直接控制程序流程和对象的创建与销">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="referrer" content="no-referrer-when-downgrade">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    <title>Spring SpringBoot 复习 | HyxiaoGe</title>
    <link rel="icon" type="image/png" href="/favicon.png">
    
    <style>
        body{
            background-image: url(http://sv6693ki5.hn-bkt.clouddn.com/background/bg.jpg);
            background-repeat:no-repeat;
            background-size: 100% 100%;
            background-attachment:fixed;
        }
    </style>



    <!-- bg-cover style     -->



<link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.min.css">
<link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
<link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
<link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
<link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
<link rel="stylesheet" type="text/css" href="/css/matery.css">
<link rel="stylesheet" type="text/css" href="/css/my.css">
<link rel="stylesheet" type="text/css" href="/css/dark.css" media="none" onload="if(media!='all')media='all'">




    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
    <link rel="stylesheet" href="/css/post.css">




    



    <script src="/libs/jquery/jquery-3.6.0.min.js"></script>

<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="HyxiaoGe" type="application/atom+xml">
<link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"><script src="/js/prism.js"></script>
<script src="/js/prism-line-numbers.min.js"></script></head>


<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">HyxiaoGe</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/contact" class="waves-effect waves-light">
      
      <i class="fas fa-comments" style="zoom: 0.6;"></i>
      
      <span>留言板</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/friends" class="waves-effect waves-light">
      
      <i class="fas fa-address-book" style="zoom: 0.6;"></i>
      
      <span>友情链接</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
  <li>
    <a href="javascript:;" class="waves-effect waves-light" onclick="switchNightMode()" title="深色/浅色模式" >
      <i id="sum-moon-icon" class="fas fa-sun" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">HyxiaoGe</div>
        <div class="logo-desc">
            
            Never really desperate, only the lost of the soul.
            
        </div>
    </div>

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/contact" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-comments"></i>
			
			留言板
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/friends" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-address-book"></i>
			
			友情链接
		</a>
          
        </li>
        
        
    </ul>
</div>


        </div>

        
    </nav>

</header>

    



<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/17.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">Spring SpringBoot 复习</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/SpringBoot/">
                                <span class="chip bg-color">SpringBoot</span>
                            </a>
                        
                            <a href="/tags/Spring/">
                                <span class="chip bg-color">Spring</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fas fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/" class="post-category">
                                微服务
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2024-04-10
                </div>
                

                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-check fa-fw"></i>更新日期:&nbsp;&nbsp;
                    2025-08-03
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-file-word fa-fw"></i>文章字数:&nbsp;&nbsp;
                    8k
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-clock fa-fw"></i>阅读时长:&nbsp;&nbsp;
                    29 分
                </div>
                

                
                    <div id="busuanzi_container_page_pv" class="info-break-policy">
                        <i class="far fa-eye fa-fw"></i>阅读次数:&nbsp;&nbsp;
                        <span id="busuanzi_value_page_pv"></span>
                    </div>
				
            </div>
        </div>
        <hr class="clearfix">

        
        <!-- 是否加载使用自带的 prismjs. -->
        <link rel="stylesheet" href="/libs/prism/prism.min.css">
        

        

        <div class="card-content article-card-content">
            <div id="articleContent">
                <h1 id="Spring、SpringBoot"><a href="#Spring、SpringBoot" class="headerlink" title="Spring、SpringBoot"></a>Spring、SpringBoot</h1><h2 id="IOC（Inversion-of-Control）"><a href="#IOC（Inversion-of-Control）" class="headerlink" title="IOC（Inversion of Control）"></a>IOC（Inversion of Control）</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>IoC 即<strong>控制反转</strong>，是一种设计原则，它将应用程序的控制权从程序代码本身转移到外部容器或框架中。传统的程序设计中，程序内部直接控制程序流程和对象的创建与销毁，而在IoC中，对象的创建和管理由容器来完成，应用程序只需要描述组件之间的依赖关系，而不需要负责对象的创建和销毁。</p>
<h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>主要作用在于降低了组件之间的耦合度，使得应用程序更加灵活、可扩展和易于维护。通过将对象的创建和管理交给容器，可以更容易地替换、扩展和重用组件，同时也能更好地实现面向接口编程。</p>
<h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><p>IoC的实现原理主要通过<strong>依赖注入</strong>（Dependency Injection）来实现。</p>
<p>依赖注入是IoC的一种具体实现方式，它通过容器来动态地将组件之间的依赖关系注入到组件中，从而实现控制反转。</p>
<p>依赖注入有三种主要的方式：</p>
<p><strong>构造器注入</strong>(需要结合@Configuration来使用)</p>
<ul>
<li>通过构造函数来注入依赖对象。</li>
<li><strong>优势</strong>：明确表明了类的依赖关系，使得类的依赖关系更加明确和可见。</li>
<li><strong>劣势</strong>：当类有多个依赖关系时，构造函数的参数列表可能变得很长，增加了代码的复杂性。</li>
</ul>
<pre class="line-numbers language-language-java"><code class="language-language-java"> 		private final UserRepository userRepository;

    // 构造器注入
    public UserService(UserRepository userRepository) &#123;
        this.userRepository = userRepository;
    &#125;

    ...

    @Configuration
    public class AppConfig &#123;

		    @Bean
		    public UserRepository userRepository() &#123;
		        return new UserRepository();
		    &#125;

		    @Bean
		    public UserService userService(UserRepository userRepository) &#123;
		        return new UserService(userRepository);
		    &#125;
		&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>Setter注入（需要结合**@Autowired**来使用）</p>
<ul>
<li>通过Setter方法来注入依赖对象。</li>
<li>优劣势：同上</li>
</ul>
<pre class="line-numbers language-language-java"><code class="language-language-java">    private UserRepository userRepository;

    // Setter注入
    public void setUserRepository(UserRepository userRepository) &#123;
        this.userRepository = userRepository;
    &#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>字段注入</p>
<ul>
<li>通过字段直接注入依赖对象。</li>
<li><strong>优势</strong>：简洁明了，不需要额外的构造函数或Setter方法。</li>
<li><strong>劣势</strong>：对象的依赖关系被直接暴露在类的字段中，降低了类的封装性。</li>
</ul>
<pre class="line-numbers language-language-java"><code class="language-language-java">    @Autowired
    private UserRepository userRepository;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h2 id="AOP（Aspect-Oriented-Programming）"><a href="#AOP（Aspect-Oriented-Programming）" class="headerlink" title="AOP（Aspect-Oriented Programming）"></a>AOP（Aspect-Oriented Programming）</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p>AOP 即<strong>面向横面编程</strong>，是一种编程范式，它允许你将那些与核心业务逻辑无关，但又分散在代码各处的功能（比如日志记录、事务管理、安全检查）“横切”出来，集中管理。这样做的目的是提高代码的重用性、可维护性和可扩展性。</p>
<p>在Spring中，@Aspect 注解标记一个类后，Spring 会将其视为<strong>切面类</strong>，并在运行时自动为该类创建代理类对象，并将切面逻辑织入到代理对象中。就可以实现手动创建代理对象相似的功能，但更加简介和方便。</p>
<p>通过使用注解 @Aspect ，Spring 提供了一种声明式的方式来定义切面，并在AOP中应用它们，而无需手动编写代理逻辑和切面逻辑的代码。</p>
<ul>
<li><strong>@Before</strong>：在目标方法执行前执行切面逻辑。</li>
<li><strong>@After</strong>：在目标方法执行后（无论是否发生异常）执行切面逻辑。</li>
<li>@AfterReturing：在目标方法正常返回后执行切面逻辑。</li>
<li>@AfterThrowing：在目标方法抛出异常后执行切面逻辑。</li>
<li>@Around：在目标方法执行前后，控制目标方法的执行过程，可以自定义是否执行目标方法、执行前后的额外逻辑等。</li>
</ul>
<h3 id="实现原理-1"><a href="#实现原理-1" class="headerlink" title="实现原理"></a>实现原理</h3><p>在Spring中，AOP主要通过动态代理实现，具体而言有两种主要的实现方式：JDK动态代理和CGLIB动态代理。</p>
<ol>
<li><strong>JDK 动态代理：</strong><ul>
<li>JDK 动态代理是基于接口（UserService）的代理，它要求目标类（UserServiceImpl）必须实现一个接口。</li>
<li>当目标类实现了接口时，Spring 容器会自动使用 JDK 动态代理生成一个实现了该接口（UserService）的代理类，并在代理类中织入切面逻辑。</li>
</ul>
</li>
<li>CGLIB 动态代理：<ul>
<li>CGLIB 动态代理是基于继承的代理，它不要求目标必须实现接口。</li>
<li>当目标类没有实现接口时，Spring 容器会自动使用CGLIB动态代理生成一个目标类的子类，并在子类中织入切面逻辑。</li>
<li>CGLIB 动态代理通过字节码增强技术来实现。</li>
</ul>
</li>
</ol>
<h3 id="Spring-在什么情况下会选择-JDK-或-CGLIB？这个选择策略是一成不变的吗？"><a href="#Spring-在什么情况下会选择-JDK-或-CGLIB？这个选择策略是一成不变的吗？" class="headerlink" title="Spring 在什么情况下会选择 JDK 或 CGLIB？这个选择策略是一成不变的吗？"></a>Spring 在什么情况下会选择 JDK 或 CGLIB？这个选择策略是一成不变的吗？</h3><ul>
<li><strong>对于纯 Spring Framework</strong>：Spring 框架会进行“智能”检测。<ul>
<li>如果一个 Bean <strong>实现了接口</strong>，Spring AOP <strong>优先使用 JDK 动态代理</strong>。</li>
<li>如果一个 Bean <strong>没有实现任何接口</strong>，Spring AOP 别无选择，<strong>只能使用 CGLIB</strong>。</li>
</ul>
</li>
<li><strong>对于 Spring Boot (2.0 及以后版本)</strong>：这是一个关键区别！<ul>
<li><p><strong>默认使用 CGLIB</strong>。无论你的目标类是否实现了接口，Spring Boot 都默认创建基于 CGLIB 的子类代理。</p>
</li>
<li><p><strong>为什么这么做？</strong> 主要是为解决一个经典问题——<strong>“同类方法调用（Self-Invocation）”时的代理失效问题</strong>。</p>
</li>
<li><p><strong>如何修改？</strong> 如果你希望 Spring Boot 使用 JDK 动态代理，可以在 <code>application.properties</code> 或 <code>application.yml</code> 中进行配置：</p>
<pre class="line-numbers language-language-yaml"><code class="language-language-yaml">spring.aop.proxy-target-class=false
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>  设置为 <code>false</code> 后，Spring Boot 就会退回到和纯 Spring 框架一样的策略：有接口用 JDK，没接口用 CGLIB。</p>
</li>
</ul>
</li>
</ul>
<h3 id="这两种代理方式各有什么优缺点或者说限制？"><a href="#这两种代理方式各有什么优缺点或者说限制？" class="headerlink" title="这两种代理方式各有什么优缺点或者说限制？"></a>这两种代理方式各有什么优缺点或者说限制？</h3><p><strong>JDK 动态代理</strong></p>
<ul>
<li><strong>优点</strong>：<ul>
<li>它是 Java 官方提供的，无需引入任何第三方库。</li>
<li>在某些情况下，它的代理对象创建速度可能比 CGLIB 稍快。</li>
</ul>
</li>
<li><strong>缺点&#x2F;限制</strong>：<ul>
<li><strong>必须实现接口</strong>：这是它最大的限制。它只能为实现了接口的类创建代理。</li>
<li><strong>代理的是接口，不是类</strong>：生成的代理对象只能强制类型转换为接口类型，而不能是实现类类型。</li>
</ul>
</li>
</ul>
<p><strong>CGLIB 动态代理 (Code Generation Library)</strong></p>
<ul>
<li><strong>优点</strong>：<ul>
<li><strong>无需实现接口</strong>：可以为任意一个普通类（非 <code>final</code> 类）创建代理。</li>
<li><strong>解决了“同类方法调用”问题</strong>：由于它代理的是类本身，因此注入的代理对象就是目标类的子类型，可以避免代理失效。</li>
</ul>
</li>
<li><strong>缺点&#x2F;限制</strong>：<ul>
<li><strong>无法代理 <code>final</code> 类和 <code>final</code> 方法</strong>：因为 CGLIB 的原理是生成目标类的子类，而 <code>final</code> 关键字阻止了继承和重写。如果你的类或方法被声明为 <code>final</code>，AOP 将无法生效。</li>
<li><strong>性能开销</strong>：在早期版本中，CGLIB 因为涉及字节码操作，其代理对象的创建和方法执行的开销比 JDK 代理稍高。不过随着版本迭代和 JVM 的优化，这种性能差异已经非常微小了。</li>
</ul>
</li>
</ul>
<h3 id="什么是“同类方法调用（Self-Invocation）”代理失效问题？"><a href="#什么是“同类方法调用（Self-Invocation）”代理失效问题？" class="headerlink" title="什么是“同类方法调用（Self-Invocation）”代理失效问题？"></a>什么是“同类方法调用（Self-Invocation）”代理失效问题？</h3><p>这是 AOP 领域最经典的一个“坑”，也是 CGLIB 被 Spring Boot 设为默认方式的重要原因。</p>
<p><strong>场景</strong>：假设你有一个 <code>UserServiceImpl</code> 类，它被 Spring AOP 代理了。类里面有两个方法 <code>methodA()</code> 和 <code>methodB()</code>，并且 <code>methodA()</code> 上加了事务注解 <code>@Transactional</code>。</p>
<pre class="line-numbers language-language-java"><code class="language-language-java">@Service
public class UserServiceImpl implements UserService &#123;

    @Transactional
    public void methodA() &#123;
        System.out.println("Executing method A...");
        // ... 业务逻辑 ...
    &#125;

    public void methodB() &#123;
        System.out.println("Executing method B...");
        this.methodA(); // 问题在这里！
    &#125;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>问题</strong>：当外部代码调用 <code>userService.methodB()</code> 时，<code>methodB()</code> 本身没有事务。在 <code>methodB()</code> 内部，通过 <code>this.methodA()</code> 调用 <code>methodA()</code>，<strong>此时 <code>methodA</code> 的事务会生效吗？</strong></p>
<p><strong>答案</strong>：<strong>不会</strong>。</p>
<p><strong>原因</strong>：</p>
<ul>
<li>外部调用 <code>userService.methodB()</code> 时，调用的是 Spring 创建的<strong>代理对象</strong>。</li>
<li>但是，一旦进入了 <code>methodB()</code> 的方法体内部，<code>this</code> 关键字指向的是<strong>原始的目标对象（UserServiceImpl 实例）</strong>，而不是代理对象。</li>
<li>所以 <code>this.methodA()</code> 相当于一个普通的内部方法调用，它直接跳过了代理对象，AOP 的切面逻辑（比如事务）自然也就无法被织入。</li>
</ul>
<p><strong>如何解决？</strong></p>
<p><strong>使用 CGLIB (Spring Boot 默认)</strong>：因为 CGLIB 创建的是子类代理，并且 Spring Boot 默认 <code>proxy-target-class=true</code>，Spring 容器中注入的就是这个子类代理。这样，即使在类内部，对方法的调用也有机会被代理拦截（尽管 <code>this</code> 关键字的问题依然存在，但 Spring 通过更复杂的处理使得在某些情况下可以工作）。</p>
<ol>
<li><p><strong>自己注入自己</strong>：最标准的解决方式是避免使用 <code>this</code>。</p>
<pre class="line-numbers language-language-java"><code class="language-language-java">@Service
public class UserServiceImpl implements UserService &#123;

    @Autowired
    private UserService self; // 注入自身的代理对象

    @Transactional
    public void methodA() &#123; ... &#125;

    public void methodB() &#123;
        System.out.println("Executing method B...");
        self.methodA(); // 通过代理对象调用
    &#125;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p><strong>使用 <code>AopContext.currentProxy()</code></strong>：</p>
<pre class="line-numbers language-language-java"><code class="language-language-java">((UserService) AopContext.currentProxy()).methodA();
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
</ol>
<h2 id="Spring-Bean-的生命周期"><a href="#Spring-Bean-的生命周期" class="headerlink" title="Spring Bean 的生命周期"></a>Spring Bean 的生命周期</h2><h3 id="第一阶段：实例化-Instantiation"><a href="#第一阶段：实例化-Instantiation" class="headerlink" title="第一阶段：实例化 (Instantiation)"></a>第一阶段：实例化 (Instantiation)</h3><ol>
<li><strong>容器启动，扫描 Bean 定义</strong>：Spring 容器（<code>ApplicationContext</code>）启动时，会读取配置（XML、注解等），找到所有被管理的 Bean 的“图纸”（<code>BeanDefinition</code>）。</li>
<li><strong>实例化 Bean</strong>：当容器需要一个 Bean 时（比如因为懒加载被首次请求，或者因为非懒加载在容器启动时就需要），它会根据 <code>BeanDefinition</code>，通过<strong>反射</strong>机制调用该类的构造函数，创建一个原始的、空的 Bean 对象实例。</li>
</ol>
<h3 id="第二阶段：属性填充-Populate"><a href="#第二阶段：属性填充-Populate" class="headerlink" title="第二阶段：属性填充 (Populate)"></a>第二阶段：属性填充 (Populate)</h3><ol>
<li><strong>依赖注入 (DI)</strong>：Spring 容器会检查这个 Bean 依赖的其他 Bean（通过 <code>@Autowired</code>, <code>@Resource</code> 等注解）。它会去容器中找到这些依赖的 Bean，并通过反射（调用 setter 方法或直接设置字段）将它们注入到当前的 Bean 实例中。</li>
</ol>
<h3 id="第三阶段：初始化-Initialization"><a href="#第三阶段：初始化-Initialization" class="headerlink" title="第三阶段：初始化 (Initialization)"></a>第三阶段：初始化 (Initialization)</h3><ol>
<li><p><strong>Aware 接口的注入</strong>：Spring 会检查 Bean 是否实现了特定的 <code>Aware</code> 接口（如 <code>BeanNameAware</code>, <code>BeanFactoryAware</code>, <code>ApplicationContextAware</code>）。如果实现了，就会调用相应的方法，将 Bean 的名字、所在的 Bean 工厂、应用上下文等环境信息注入给它。</p>
<ul>
<li><code>setBeanName()</code></li>
<li><code>setBeanFactory()</code></li>
<li><code>setApplicationContext()</code></li>
</ul>
</li>
<li><p><strong><code>BeanPostProcessor</code> 前置处理</strong>：调用所有已注册的 <code>BeanPostProcessor</code> 的 <code>postProcessBeforeInitialization()</code> 方法。这是一个非常强大的扩展点，它允许你在 Bean 的“正式初始化”之前，对 Bean 进行任意的修改或包装。<strong>AOP 代理就是在这个阶段通过一个特殊的 <code>BeanPostProcessor</code> 实现的</strong>。如果 Spring 发现这个 Bean 需要被代理，它就会在这里返回一个代理对象，替换掉原始的 Bean 对象。</p>
</li>
<li><p><strong><code>@PostConstruct</code> 注解</strong>：如果 Bean 的方法上标注了 <code>@PostConstruct</code> 注解，Spring 会调用这个方法。这是 JSR-250 规范定义的，是官方<strong>推荐</strong>的初始化方式，因为它不依赖于 Spring 的特定接口。</p>
</li>
<li><p><strong><code>InitializingBean</code> 接口</strong>：如果 Bean 实现了 <code>InitializingBean</code> 接口，Spring 会调用它的 <code>afterPropertiesSet()</code> 方法。这是 Spring 早期的初始化方式。</p>
</li>
<li><p><strong>自定义 <code>init-method</code></strong>：如果你在 XML 配置中通过 <code>init-method</code> 属性，或者在 <code>@Bean</code> 注解中通过 <code>initMethod</code> 属性指定了自定义的初始化方法，Spring 会在此时调用它。</p>
<blockquote>
<p>初始化顺序：@PostConstruct -&gt; InitializingBean.afterPropertiesSet() -&gt; init-method。推荐使用 @PostConstruct。</p>
</blockquote>
</li>
<li><p><strong><code>BeanPostProcessor</code> 后置处理</strong>：调用所有 <code>BeanPostProcessor</code> 的 <code>postProcessAfterInitialization()</code> 方法。这是另一个关键的扩展点，它允许你在 Bean 完全初始化之后，再次进行处理。AOP 代理的创建主要发生在前置处理，但后置处理也可能被用到。</p>
</li>
</ol>
<h3 id="第四阶段：Bean-可用"><a href="#第四阶段：Bean-可用" class="headerlink" title="第四阶段：Bean 可用"></a>第四阶段：Bean 可用</h3><ol>
<li><strong>Bean 准备就绪</strong>：经过了以上所有步骤，Bean 现在是一个完全初始化、功能完备的对象了。它被存放在 Spring 容器的单例池（<code>singletonObjects</code>）中，等待其他对象来调用它。</li>
</ol>
<h3 id="第五阶段：销毁-Destruction"><a href="#第五阶段：销毁-Destruction" class="headerlink" title="第五阶段：销毁 (Destruction)"></a>第五阶段：销毁 (Destruction)</h3><p>当 Spring 容器关闭时（比如应用停止），容器会销毁它管理的所有单例 Bean。</p>
<ol>
<li><p><strong><code>@PreDestroy</code> 注解</strong>：如果 Bean 的方法上标注了 <code>@PreDestroy</code> 注解，Spring 会在销毁前调用这个方法。同样，这是 JSR-250 规范，是<strong>推荐</strong>的销毁方式。</p>
</li>
<li><p><strong><code>DisposableBean</code> 接口</strong>：如果 Bean 实现了 <code>DisposableBean</code> 接口，Spring 会调用它的 <code>destroy()</code> 方法。</p>
</li>
<li><p><strong>自定义 <code>destroy-method</code></strong>：如果你指定了自定义的销毁方法，它会在这里被调用。</p>
<blockquote>
<p>销毁顺序：@PreDestroy -&gt; DisposableBean.destroy() -&gt; destroy-method。推荐使用 @PreDestroy。</p>
</blockquote>
</li>
</ol>
<h2 id="BeanFactory-和-ApplicationContext-的区别"><a href="#BeanFactory-和-ApplicationContext-的区别" class="headerlink" title="BeanFactory 和 ApplicationContext 的区别"></a>BeanFactory 和 ApplicationContext 的区别</h2><p>两者是 Spring 两个核心接口，都可以用来获取 Bean 实例，但在功能上有所不同。</p>
<ul>
<li>BeanFactory<ul>
<li><strong>提供了基本的依赖注入支持</strong>。</li>
<li><strong>延迟加载，只有在明确请求时才初始化Bean</strong>。</li>
</ul>
</li>
<li>ApplicationContext<ul>
<li><strong>完全初始化所有单例Bean</strong>。</li>
<li><strong>支持国际化（i18n）、事件传播、资源加载等</strong>。</li>
<li><strong>提供了AOP功能</strong>。</li>
<li><strong>通常在应用程序中使用 ApplicationContext</strong>。</li>
</ul>
</li>
</ul>
<h2 id="Spring-加载-Bean的-方式"><a href="#Spring-加载-Bean的-方式" class="headerlink" title="Spring 加载 Bean的 方式"></a>Spring 加载 Bean的 方式</h2><ol>
<li>基于 XML 的配置</li>
<li>基于注解的配置</li>
<li>配置类（@Configuration + @Bean）</li>
<li>通过 FactoryBean</li>
</ol>
<h2 id="Spring-的-bean-为什么是单例的呢，并且除了单例以外还有什么形式，如果是多例的话，会有什么影响"><a href="#Spring-的-bean-为什么是单例的呢，并且除了单例以外还有什么形式，如果是多例的话，会有什么影响" class="headerlink" title="Spring 的 bean 为什么是单例的呢，并且除了单例以外还有什么形式，如果是多例的话，会有什么影响"></a>Spring 的 bean 为什么是单例的呢，并且除了单例以外还有什么形式，如果是多例的话，会有什么影响</h2><p>Spring 框架中Bean的默认作用域是<code>单例（singleton）</code>，这是出于以下几个原因：</p>
<ol>
<li><strong>性能优化</strong>：创建对象通常是一个昂贵的过程，尤其是涉及到 I&#x2F;O 操作（如数据库连接）时。使用单例可以减少对象创建的次数，节省资源和提升性能。</li>
<li><strong>状态共享</strong>：单例模式允许在应用的不同部分共享同一个 Bean 实例，这对于状态共享和管理非常有用。</li>
<li><strong>资源管理</strong>：许多 Bean ，如数据源、会话工厂等，是自然的单例，因为它们封装了共享资源，如数据库连接池。</li>
</ol>
<p>除了单例模式，Spring 还提供其他几种 Bean 的作用域：</p>
<ul>
<li><strong>单例（Singleton）</strong>：在 Spring IoC 容器仅存在一个 Bean 实例，Bean 以单例方式存在。</li>
<li><strong>原型（prototype）</strong>：每次注入或通过 Spring 容器的 getBean() 请求时，都会创建一个新的Bean实例（这种模式就是多例）。</li>
<li><strong>请求（request）</strong>：每个 HTTP 请求都会创建一个新的 Bean ，该作用域仅在请求的处理过程中有效。</li>
<li><strong>会话（session）</strong>：在一个 HTTP 会话中，一个 Bean 定义对应一个 Bean 实例，该作用域同样仅在会话期间中有效。</li>
<li><strong>应用（application）</strong>：在一个 ServletContext 的生命周期内，一个 Bean 定义对应一个 Bean 实例，同样仅在 Web 应用的生命周期中有效。</li>
</ul>
<p>如果将 Bean 定义为多例（prototype）作用域，将会有以下影响：</p>
<ol>
<li><strong>资源使用增加</strong>：每次请求 Bean 时都会创建新实例，会增加内存和资源的使用。</li>
<li><strong>状态管理</strong>：多例 Bean 不会共享状态，每个 Bean 实例都有自己的状态。</li>
<li><strong>生命周期管理</strong>：Spring 不会管理 prototype Bean 的完整生命周期，也就是说，Spring 不会调用 prototype Bean 的销毁方法。</li>
<li><strong>复杂性增加</strong>：在使用多例 Bean 时，需要更加小心地管理其生命周期和依赖关系。</li>
</ol>
<p>总的来说，选择正确的作用域取决于具体的应用需求。单例作用域适合于<strong>需要共享状态的全局资源</strong>，而原型作用域<strong>适合于那些具有独立状态、生命周期较短或需要隔离的Bean、每次都需要一个新实例的情况</strong>。</p>
<h2 id="Spring-循环依赖"><a href="#Spring-循环依赖" class="headerlink" title="Spring 循环依赖"></a>Spring 循环依赖</h2><h3 id="1-定义与前提"><a href="#1-定义与前提" class="headerlink" title="1. 定义与前提"></a><strong>1. 定义与前提</strong></h3><p>首先，循环依赖指的是两个或多个Bean之间相互依赖，形成了一个闭环，例如A依赖B，同时B又依赖A。</p>
<p>Spring只解决了<strong>单例（Singleton）作用域</strong>下，并且是基于<strong>setter或字段注入</strong>的循环依赖。对于构造器注入和原型（Prototype）作用域的循环依赖，Spring是无法解决的，会直接抛出异常。</p>
<h3 id="2-核心思想：分离实例化与初始化"><a href="#2-核心思想：分离实例化与初始化" class="headerlink" title="2. 核心思想：分离实例化与初始化"></a><strong>2. 核心思想：分离实例化与初始化</strong></h3><p>Spring解决问题的核心思想，是把Bean的创建过程拆分成了两个主要阶段：</p>
<ul>
<li><strong>实例化 (Instantiation)</strong>：通过反射创建一个原始的Bean对象，但此时Bean的属性都是null。</li>
<li><strong>初始化 (Initialization)</strong>：为Bean的属性进行依赖注入（DI）和执行各种初始化回调。</li>
</ul>
<p>通过将这两个阶段分离，Spring有机会将一个虽然还未完成初始化，但已经被实例化的“半成品”Bean提前暴露出去，从而打破循环。</p>
<h3 id="3-实现机制：三级缓存"><a href="#3-实现机制：三级缓存" class="headerlink" title="3. 实现机制：三级缓存"></a><strong>3. 实现机制：三级缓存</strong></h3><p>为了实现“半成品”Bean的提前暴露，Spring使用了“三级缓存”机制。这三个缓存都是Map结构：</p>
<ul>
<li><strong><code>singletonObjects</code> (一级缓存)</strong>：用于存放已经<strong>完全初始化</strong>的Bean，我们称之为“成品Bean缓存”。</li>
<li><strong><code>earlySingletonObjects</code> (二级缓存)</strong>：用于存放<strong>提前暴露</strong>的Bean，即“半成品Bean缓存”。这些Bean已被实例化，但还未完成属性注入。</li>
<li><strong><code>singletonFactories</code> (三级缓存)</strong>：这是解决循环依赖最关键的缓存。它存放的不是Bean对象，而是创建Bean的<strong>工厂（ObjectFactory）</strong>。这个工厂负责在真正需要时，才生成那个“半成品Bean”，并且可以包含AOP代理逻辑。</li>
</ul>
<h3 id="4-解决流程（以A、B循环依赖为例）"><a href="#4-解决流程（以A、B循环依赖为例）" class="headerlink" title="4. 解决流程（以A、B循环依赖为例）"></a><strong>4. 解决流程（以A、B循环依赖为例）</strong></h3><ol>
<li><strong>创建A</strong>：<code>getBean(&quot;a&quot;)</code>被调用。Spring首先实例化A，得到一个原始对象。然后，它并不会立即初始化A，而是将一个能够产生A的<code>ObjectFactory</code>放入<strong>三级缓存</strong>。</li>
<li><strong>A注入B</strong>：Spring开始初始化A，发现它依赖B，于是调用<code>getBean(&quot;b&quot;)</code>。</li>
<li><strong>创建B</strong>：Spring去创建B，同样先实例化B，然后将能产生B的<code>ObjectFactory</code>放入<strong>三级缓存</strong>。</li>
<li><strong>B注入A（关键步骤）</strong>：Spring初始化B，发现它依赖A，于是调用<code>getBean(&quot;a&quot;)</code>。</li>
<li><strong>获取A的半成品</strong>：此时，Spring按顺序查找A：<ul>
<li>在一级缓存中查找，找不到（A未完全初始化）。</li>
<li>在二级缓存中查找，也找不到。</li>
<li>在<strong>三级缓存</strong>中，<strong>成功找到了A的<code>ObjectFactory</code></strong>。</li>
</ul>
</li>
<li><strong>提前暴露A</strong>：Spring调用这个<code>ObjectFactory</code>来生成一个A的“半成品”（如果A需要AOP代理，此时会生成代理对象），并将这个半成品A放入<strong>二级缓存</strong>，然后从三级缓存中移除A的工厂。</li>
<li><strong>B创建完成</strong>：B获取到了A的半成品引用，顺利完成了自己的初始化。之后，完整的B被放入<strong>一级缓存</strong>。</li>
<li><strong>A创建完成</strong>：回到A的创建流程，它现在可以从一级缓存中获取到完整的B对象，并完成自己的初始化。最后，完整的A也被放入<strong>一级缓存</strong>。</li>
</ol>
<p>至此，循环依赖被解决。</p>
<h3 id="5-为什么必须是三级缓存？"><a href="#5-为什么必须是三级缓存？" class="headerlink" title="5. 为什么必须是三级缓存？"></a><strong>5. 为什么必须是三级缓存？</strong></h3><p>使用三级缓存而不是二级，主要是为了<strong>延迟AOP代理对象的创建</strong>。如果只有二级缓存，那就必须在Bean实例化后立刻创建代理对象，但实际上这个Bean可能最终并不需要被代理。三级缓存通过<code>ObjectFactory</code>，将代理对象的创建推迟到了真正发生循环依赖、且有其他Bean需要注入它时，才去执行，这是一种更合理、更优化的设计。</p>
<h2 id="By-Type-和-By-Name-的区别（-Autowired和-Resource的区别）"><a href="#By-Type-和-By-Name-的区别（-Autowired和-Resource的区别）" class="headerlink" title="By Type 和 By Name 的区别（@Autowired和@Resource的区别）"></a>By Type 和 By Name 的区别（@Autowired和@Resource的区别）</h2><p><strong>@Autowired 基于类型的依赖注入（By Type）</strong>：</p>
<ul>
<li><p><strong>定义</strong>：在基于类型的注入中，Spring 容器使用要注入的属性或构造函数参数的类型来在容器中查找匹配的 Bean。</p>
</li>
<li><p>代码示例：</p>
<pre class="line-numbers language-language-java"><code class="language-language-java">@Autowired
private MyService myService;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>  在这个例子中，Spring 会在其容器中查找 MyService 类型的 Bean，并进行注入。</p>
<p>  <strong>多个候选 Bean</strong>：如果存在多个同类型的 Bean，而没有其他限定信息，Spring 将无法决定使用哪一个，从而导致异常。这种情况下，可以使用 @Qualifier 注解来指定 Bean 的名称。</p>
</li>
</ul>
<p>虽然<code>@Autowired</code><strong>本身不提供直接的基于名称的注入，通过与</strong><code>@Qualifier</code><strong>结合使用，它可以非常灵活地实现</strong><code>基于名称的注入</code>相似的功能。</p>
<p><strong>代码示例</strong>：</p>
<pre class="line-numbers language-language-java"><code class="language-language-java">@Autowired
@Qualifier("mySpecificService")
private MyService myService;

...

@Service("mySpecificService")
public class MyServiceImpl implements MyService &#123;
    // 实现细节
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在这个例子中，Spring 会在其容器中查找名为 <code>mySpecificService</code> 的Bean来注入。</p>
<p><strong>@Resource 基于名称的依赖注入（By Name）（默认）</strong></p>
<p><strong>定义</strong>：<code>@Resource</code>注解是基于 JSR-250 标准，它可以根据名称或类型来注入依赖。 <strong>代码示例</strong>：</p>
<pre class="line-numbers language-language-java"><code class="language-language-java">@Resource(name = "mySpecificService")
private MyService myService;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>在这个例子中，<code>@Resource</code><strong>注解通过</strong><code>name</code>属性直接指定了要注入的 Bean 名称，从而实现了基于名称的注入。 <strong>@Resource 基于类型的依赖注入（By Type）</strong></p>
<pre class="line-numbers language-language-java"><code class="language-language-java">@Resource
private MyService myService;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h2 id="Spring-事务失效的经典场景"><a href="#Spring-事务失效的经典场景" class="headerlink" title="Spring 事务失效的经典场景"></a><strong>Spring 事务失效的经典场景</strong></h2><h3 id="1-最经典的失效场景：方法内部调用（Self-Invocation）"><a href="#1-最经典的失效场景：方法内部调用（Self-Invocation）" class="headerlink" title="1. 最经典的失效场景：方法内部调用（Self-Invocation）"></a>1. 最经典的失效场景：方法内部调用（Self-Invocation）</h3><ul>
<li><p><strong>场景描述：</strong></p>
<pre class="line-numbers language-language-java"><code class="language-language-java">@Service
public class OrderService &#123;

    public void createOrder() &#123;
        // ... 其他操作 ...
        this.updateStock(); // this 调用，事务会失效！
    &#125;

    @Transactional
    public void updateStock() &#123;
        // ... 更新库存的数据库操作 ...
    &#125;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p><strong>失效原因</strong>: 调用 <code>this.updateStock()</code> 时，使用的是原始的 <code>OrderService</code> 实例，而不是 Spring 生成的代理对象。调用直接发生在对象内部，完全绕过了代理对象，AOP 根本没有机会介入，自然无法开启事务。</p>
</li>
<li><p><strong>解决方案</strong>: 避免 <code>this</code> 调用。通过注入自身的代理对象来解决</p>
<pre class="line-numbers language-language-java"><code class="language-language-java">@Autowired private OrderService self; 

public void createOrder() &#123;
    // ... 其他操作 ...
    self.updateStock();
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ul>
<h3 id="2-方法的访问权限问题（private-protected-等）"><a href="#2-方法的访问权限问题（private-protected-等）" class="headerlink" title="2. 方法的访问权限问题（private, protected 等）"></a>2. 方法的访问权限问题（<code>private</code>, <code>protected</code> 等）</h3><ul>
<li><p><strong>场景描述</strong>: 将 <code>@Transactional</code> 注解加在了一个在非 <code>public</code> 方法上。</p>
<pre class="line-numbers language-language-java"><code class="language-language-java">@Service
public class OrderService &#123;
    @Transactional
    private void processPayment() &#123; // private 方法，事务会失效！
        // ...
    &#125;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p><strong>失效原因</strong>: Spring AOP 在创建代理时，无法拦截（或重写）<code>private</code> 方法，因为它们在类的外部是不可见的。对于 <code>protected</code> 和 <code>package-private</code>（默认）方法，虽然 CGLIB 代理理论上可以，但也存在限制且不符合最佳实践。<strong>Spring 官方文档明确建议，只在 <code>public</code> 方法上使用 <code>@Transactional</code> 注解。</strong></p>
</li>
</ul>
<h3 id="3-异常类型不匹配（rollbackFor-设置错误）"><a href="#3-异常类型不匹配（rollbackFor-设置错误）" class="headerlink" title="3. 异常类型不匹配（rollbackFor 设置错误）"></a>3. 异常类型不匹配（<code>rollbackFor</code> 设置错误）</h3><ul>
<li><p><strong>场景描述</strong>: 事务方法中抛出了一个<strong>受检异常（Checked Exception）</strong>，但没有指定 <code>rollbackFor</code> 属性。</p>
<pre class="line-numbers language-language-java"><code class="language-language-java">@Service
public class UserService &#123;
    @Transactional
    public void register() throws Exception &#123;
        // ... 数据库操作 ...
        if (someCondition) &#123;
            throw new Exception("一个受检异常"); // 事务默认不会回滚！
        &#125;
    &#125;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p><strong>失效原因</strong>: Spring 的默认事务回滚策略是：<strong>只在遇到 <code>RuntimeException</code>（运行时异常）或 <code>Error</code> 时才回滚</strong>。对于普通的 <code>Exception</code>（受检异常），Spring 认为这可能是业务逻辑的一部分，需要开发者明确指示才回滚。因此，上述代码在抛出 <code>Exception</code> 后，事务会<strong>提交</strong>而不是回滚。</p>
</li>
<li><p><strong>解决方案</strong>: 在注解上明确指定回滚的异常类型：<code>@Transactional(rollbackFor = Exception.class)</code>。</p>
</li>
</ul>
<h3 id="4-方法内部吞掉（catch）了异常"><a href="#4-方法内部吞掉（catch）了异常" class="headerlink" title="4. 方法内部吞掉（catch）了异常"></a>4. 方法内部吞掉（<code>catch</code>）了异常</h3><ul>
<li><p><strong>场景描述</strong>: 在事务方法内部使用了 <code>try...catch</code> 块，并且在 <code>catch</code> 块中没有将异常重新抛出。</p>
<pre class="line-numbers language-language-java"><code class="language-language-java">@Service
public class ProductService &#123;
    @Transactional
    public void updateProduct() &#123;
        try &#123;
            // ... 执行数据库更新，期间发生 RuntimeException ...
        &#125; catch (Exception e) &#123;
            // 异常被捕获了，但没有重新抛出
            System.out.println("发生了一个异常，但我处理掉了");
        &#125;
        // 方法正常结束，没有异常抛出
    &#125;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p><strong>失效原因</strong>: 事务回滚的前提是，代理对象需要<strong>感知到</strong>有异常发生。在上述代码中，异常被 <code>catch</code> 块完全“消化”了，没有向方法外部传播。对于代理对象来说，<code>updateProduct</code> 方法是“正常返回”的，它根本不知道内部曾发生过异常，因此会正常提交事务。</p>
</li>
</ul>
<h3 id="5-Bean-没有被-Spring-容器管理"><a href="#5-Bean-没有被-Spring-容器管理" class="headerlink" title="5. Bean 没有被 Spring 容器管理"></a>5. Bean 没有被 Spring 容器管理</h3><ul>
<li><p><strong>场景描述</strong>: 你手动 <code>new</code> 了一个对象，然后调用它的事务方法。</p>
<pre class="line-numbers language-language-java"><code class="language-language-java">public void someBusinessLogic() &#123;
    OrderService service = new OrderService(); // 手动 new
    service.updateStock(); // 事务会失效
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p><strong>失效原因</strong>: 这个 <code>OrderService</code> 实例是一个普通的 Java 对象，它完全游离在 Spring 容器之外。Spring 根本不知道它的存在，自然也无法为它创建代理对象，所有与 Spring 相关的功能（包括 <code>@Transactional</code>）都将无效。</p>
</li>
</ul>
<h2 id="Spring-Boot-的核心思想是什么？"><a href="#Spring-Boot-的核心思想是什么？" class="headerlink" title="Spring Boot 的核心思想是什么？"></a>Spring Boot 的核心思想是什么？</h2><p>Spring Boot 的核心思想是**“约定优于配置”** (Convention over Configuration)。</p>
<p>这个思想的本质是，Spring Boot 团队认为，对于绝大多数项目，很多技术的配置方式都是固定和通用的。因此，Spring Boot 不应该让开发者每次都去重复编写这些样板化的配置，而是应该提供一套“<strong>约定好的、合理的默认配置</strong>”。</p>
<p>具体来说，这个核心思想体现在以下三个方面：</p>
<ol>
<li><strong>开箱即用</strong>: Spring Boot 致力于提供一种“just run”的开发体验。开发者引入相关依赖后，无需或只需少量配置，就能快速启动和运行一个功能完备的应用。</li>
<li><ul>
<li>opinionated (有主见的)**：它为项目提供了一套“有主见的”最佳实践集合。比如，当它检测到 <code>spring-webmvc</code> 在 classpath 中时，它会“主观地”认为你正在开发一个 Web 应用，因此会自动为你配置好 DispatcherServlet、内嵌的 Tomcat 服务器等。</li>
</ul>
</li>
<li><strong>可覆盖的默认值</strong>: 虽然它提供了强大的默认配置，但它绝不“绑架”开发者。如果你对默认的配置不满意，比如不想要 Tomcat 而是想用 Undertow，或者想自定义数据源的参数，你随时可以通过简单的配置（如在 <code>application.yml</code> 中修改）来覆盖掉它的默认行为。</li>
</ol>
<p>总而言之，Spring Boot 的核心思想是通过<strong>自动配置</strong>、<strong>起步依赖</strong>等手段，用一套“约定好的”默认值来代替繁琐的手动配置，从而极大简化项目搭建和开发过程，让开发者能更专注于业务逻辑本身。</p>
<h2 id="什么是-Starter？它和普通依赖有什么区别？"><a href="#什么是-Starter？它和普通依赖有什么区别？" class="headerlink" title="什么是 Starter？它和普通依赖有什么区别？"></a>什么是 Starter？它和普通依赖有什么区别？</h2><p><strong>Starter (起步依赖)</strong> 是 Spring Boot 的核心特性之一，它本质上是一个特殊的 <strong>Maven 依赖描述符（POM）</strong>，而不是一个包含具体代码的 JAR 包。</p>
<p>它的主要作用有两个：</p>
<ol>
<li><strong>聚合相关依赖</strong>: Starter 将构建某一特定功能（如 Web 开发、数据访问）所需的一整套相关依赖聚合在一起。例如，我们引入 <code>spring-boot-starter-web</code>，它就会自动将 Spring MVC、Jackson、Validation API、内嵌的 Tomcat 服务器等所有必要的库都间接引入进来。</li>
<li><strong>管理版本兼容性</strong>: Starter 依赖于 Spring Boot 的父项目 (<code>spring-boot-dependencies</code>)，这个父项目像一个“字典”一样，统一管理了所有常用第三方库的版本号。这确保了 Starter 引入的所有传递性依赖之间版本都是互相兼容的，开发者无需再手动管理版本，从而避免了“依赖地狱”。</li>
</ol>
<p><strong>它和普通依赖的核心区别在于</strong>：</p>
<ul>
<li><strong>目的不同</strong>: 普通依赖（如 <code>spring-core.jar</code>）的目的是提供具体的 API 和功能实现。而 Starter 的目的在于<strong>简化依赖管理</strong>，它本身不提供任何代码，只负责“带入”其他依赖。</li>
<li><strong>关注点不同</strong>: 使用普通依赖时，开发者需要自己去管理一系列相关依赖的版本和兼容性。而使用 Starter 时，开发者只需要关注“我需要什么功能”（如 <code>web</code>、<code>jpa</code>），而不需要关心“为了这个功能我需要引入哪些具体的库、版本是什么”。</li>
</ul>
<p>简单来说，Starter 是 Spring Boot 提供的一种“一站式”解决方案，让依赖管理从“手动挡”变成了“自动挡”。</p>
<h2 id="请详细解释一下-Spring-Boot-的自动配置原理。"><a href="#请详细解释一下-Spring-Boot-的自动配置原理。" class="headerlink" title="请详细解释一下 Spring Boot 的自动配置原理。"></a>请详细解释一下 Spring Boot 的自动配置原理。</h2><p>Spring Boot 的自动配置是其最核心的功能，其原理主要依赖于三个关键部分：<code>@EnableAutoConfiguration</code> 注解、<code>META-INF/spring.factories</code> 文件和 <code>@Conditional</code> 系列条件注解。</p>
<p>整个流程如下：</p>
<ol>
<li><p><strong>启动自动配置总开关</strong>: Spring Boot 项目的启动类上通常有一个 <code>@SpringBootApplication</code> 注解，它是一个复合注解，里面包含了 <code>@Configuration</code>、<code>@ComponentScan</code>、<code>@EnableAutoConfiguration</code>，其中 <strong><code>@EnableAutoConfiguration</code></strong>。这个注解是激活自动配置功能的总开关。</p>
</li>
<li><p><strong>扫描候选配置类</strong>: 启动应用时，<code>@EnableAutoConfiguration</code> 注解会借助 Spring 的 <code>SpringFactoriesLoader</code> 机制，去扫描所有引入的 JAR 包中类路径下的 <strong><code>META-INF/spring.factories</code></strong> 文件。这个文件中以键值对的形式列出了大量预定义的自动配置类，例如：</p>
<pre class="line-numbers language-language-java"><code class="language-language-java"># Auto Configure
org.springframework.boot.autoconfigure.EnableAutoConfiguration=\
org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration,\
org.springframework.boot.autoconfigure.web.servlet.WebMvcAutoConfiguration
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p><strong>按需装配（条件判断）</strong>: 候选人名单有了，但并不是所有的配置都会生效。每一个自动配置类（如 <code>DataSourceAutoConfiguration</code>）本身都是一个 <code>@Configuration</code> 配置类，并且它上面会使用大量的 <strong><code>@Conditional</code> 系列注解</strong>来进行条件判断。只有当所有条件都满足时，这个自动配置类才会生效。常见的条件注解有：</p>
<ul>
<li><strong><code>@ConditionalOnClass</code></strong>: 判断 classpath 中是否存在指定的类。例如，<code>DataSourceAutoConfiguration</code> 会检查是否存在 <code>DataSource.class</code>。</li>
<li><strong><code>@ConditionalOnMissingBean</code></strong>: 判断 Spring 容器中是否<strong>不</strong>存在指定类型的 Bean。这是允许用户覆盖默认配置的关键，例如，如果用户自己定义了一个 <code>DataSource</code> Bean，那么 Spring Boot 的默认 <code>DataSource</code> 配置就不会生效。</li>
<li><strong><code>@ConditionalOnProperty</code></strong>: 判断配置文件中是否存在指定的属性及其值。</li>
</ul>
</li>
<li><p><strong>注入 Bean</strong>: 一旦某个自动配置类的所有条件都满足，它就会被 Spring 容器加载，其内部使用 <code>@Bean</code> 注解定义的一系列 Bean（如 <code>DataSource</code>, <code>JdbcTemplate</code> 等）就会被创建并注入到容器中，从而完成了自动配置。</p>
</li>
</ol>
<p>总结来说，自动配置的原理就是 <strong>“扫描 -&gt; 过滤 -&gt; 装配”</strong>：通过 <code>spring.factories</code> <strong>扫描</strong>到所有可能的配置，然后通过 <code>@Conditional</code> <strong>过滤</strong>掉不满足条件的，最后把满足条件的配置<strong>装配</strong>到 Spring 容器中。</p>
<h2 id="如何禁用某个不想要的自动配置？"><a href="#如何禁用某个不想要的自动配置？" class="headerlink" title="如何禁用某个不想要的自动配置？"></a>如何禁用某个不想要的自动配置？</h2><p>通常有两种方式可以禁用 Spring Boot 中我们不想要的自动配置：</p>
<ol>
<li><p><strong>通过注解的 <code>exclude</code> 属性（推荐）</strong>:<br>这是最常用且最直接的方式。我们可以在启动类的 <code>@SpringBootApplication</code> 或 <code>@EnableAutoConfiguration</code> 注解中，通过 <code>exclude</code> 属性来指定要排除的自动配置类。</p>
<pre class="line-numbers language-language-java"><code class="language-language-java">import org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration;

// 禁用数据源的自动配置
@SpringBootApplication(exclude = &#123;DataSourceAutoConfiguration.class&#125;)
public class MyApplication &#123;
    // ...
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p><strong>通过配置文件属性</strong>:<br>我们也可以在 <code>application.properties</code> 或 <code>application.yml</code> 文件中，通过 <code>spring.autoconfigure.exclude</code> 属性来禁用一个或多个自动配置。</p>
<pre class="line-numbers language-language-java"><code class="language-language-java"># 在 application.properties 中禁用
spring.autoconfigure.exclude=org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration,org.springframework.boot.autoconfigure.orm.jpa.HibernateJpaAutoConfiguration
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
</li>
</ol>
<h2 id="Spring-Boot-的配置文件加载顺序是怎样的？"><a href="#Spring-Boot-的配置文件加载顺序是怎样的？" class="headerlink" title="Spring Boot 的配置文件加载顺序是怎样的？"></a>Spring Boot 的配置文件加载顺序是怎样的？</h2><p>Spring Boot 会从多个位置加载配置文件（如 <code>application.properties</code> 或 <code>application.yml</code>），并且有一个明确的<strong>优先级顺序</strong>。高优先级的配置会覆盖低优先级的配置。一个常见的、简化的优先级从低到高如下：</p>
<ol>
<li><p><strong>JAR 包内部的配置文件</strong>: 项目内部resource目录下的 <code>application.properties</code> 或 <code>application.yml</code>。这是最低的优先级，通常作为默认配置。</p>
</li>
<li><p><strong>JAR 包外部的配置文件</strong>:</p>
<ul>
<li><p>在 JAR 包<strong>同级目录</strong>下的配置文件。</p>
<pre class="line-numbers language-language-java"><code class="language-language-java">/opt/app/
├── myapp.jar
└── application.properties
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
</li>
</ul>
</li>
<li><p><strong>操作系统环境变量</strong>。</p>
<ul>
<li><p>在 Linux 或 macOS 上: <code>export SERVER_PORT=8081</code>，在 Windows 上: <code>set SERVER_PORT=8081</code></p>
</li>
<li><p>环境变量 <code>SERVER_PORT</code> 会被 Spring Boot 识别为配置属性 <code>server.port</code>；环境变量 <code>SPRING_DATASOURCE_URL</code> 会被识别为 <code>spring.datasource.url</code>。</p>
</li>
<li><p>在 Docker容器化环境中，通过环境变量来注入配置是标准做法。</p>
<pre class="line-numbers language-language-docker"><code class="language-language-docker">FROM openjdk:17-jdk-slim

WORKDIR /app

COPY target/myapp.jar myapp.jar

ENTRYPOINT ["java", "-jar", "myapp.jar"]
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-language-bash"><code class="language-language-bash">docker run -p 9090:9090 -e "SERVER_PORT=9090" my-app
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
</ul>
</li>
<li><p><strong>Java 系统属性</strong> (通过 <code>java -D&lt;key&gt;=&lt;value&gt;</code> 指定)。</p>
<ul>
<li><p><strong>定义</strong>: 这是专属于某一个<strong>Java 虚拟机 (JVM) 实例</strong>的变量。它在 <code>java</code> 命令启动时通过 <code>-D</code> 参数传入，只对当前这个启动的 Java 进程有效。</p>
</li>
<li><p><strong>Spring Boot 如何读取</strong>: Spring Boot 会直接读取 JVM 的所有系统属性，属性名是什么，它就识别成什么。</p>
<pre class="line-numbers language-language-bash"><code class="language-language-bash">java -Dserver.port=8082 -jar myapp.jar
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>  <strong>示例</strong>: <code>-Dserver.port=8082</code> 就直接对应配置属性 <code>server.port</code>。</p>
</li>
</ul>
</li>
<li><p><strong>命令行参数</strong> (通过 <code>-&lt;key&gt;=&lt;value&gt;</code> 传递)。这是最高的优先级。</p>
<ul>
<li><p><strong>定义</strong>: 这是<strong>直接传递给 Spring Boot 应用本身</strong>的参数。它在 <code>java -jar myapp.jar</code> 命令的<strong>最后面</strong>，通过 <code>--</code> 形式添加。</p>
</li>
<li><p><strong>Spring Boot 如何读取</strong>: Spring Boot 会专门解析这些以 <code>--</code> 开头的参数，并直接将它们映射为配置属性。</p>
<pre class="line-numbers language-language-bash"><code class="language-language-bash">java -jar myapp.jar --server.port=8083
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>  <strong>示例</strong>: <code>--server.port=8083</code> 就直接对应配置属性 <code>server.port</code>。</p>
</li>
</ul>
</li>
</ol>

                
            </div>
            <hr/>

            



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/SpringBoot/">
                                    <span class="chip bg-color">SpringBoot</span>
                                </a>
                            
                                <a href="/tags/Spring/">
                                    <span class="chip bg-color">Spring</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">
<div id="article-share">

    

    

</div>

                </div>
            </div>
            
        </div>
    </div>

    

    

    

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/2024/04/22/springcloud-openfeign/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/6.jpg" class="responsive-img" alt="SpringCloud-OpenFeign">
                        
                        <span class="card-title">SpringCloud-OpenFeign</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2024-04-22
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/" class="post-category">
                                    微服务
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/SpringCloud/">
                        <span class="chip bg-color">SpringCloud</span>
                    </a>
                    
                    <a href="/tags/OpenFeign/">
                        <span class="chip bg-color">OpenFeign</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2023/12/26/dian-shang-xi-tong-he-xin-ji-zhu-wen-ti-yu-jie-jue-fang-an/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/20.jpg" class="responsive-img" alt="电商系统核心技术问题与解决方案">
                        
                        <span class="card-title">电商系统核心技术问题与解决方案</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2023-12-26
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/" class="post-category">
                                    消息队列
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/Kafka/">
                        <span class="chip bg-color">Kafka</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>



<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>


  <!-- 是否加载使用自带的 prismjs. -->
  <script type="text/javascript" src="/libs/prism/prism.min.js"></script>


<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>



    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget card" style="background-color: white;">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h2, h3, h4'
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>




    <footer class="page-footer bg-color">
    

    <div class="container row center-align"
         style="margin-bottom: 15px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            
                <span id="year">2023-2025</span>
            
            <a href="/about" target="_blank">Sean</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            
            <br>
            
                &nbsp;<i class="fas fa-chart-area"></i>&nbsp;站点总字数:&nbsp;<span
                        class="white-color">112.5k</span>
            
            
            
                
            
            
                <span id="busuanzi_container_site_pv">
                &nbsp;|&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;
                    <span id="busuanzi_value_site_pv" class="white-color"></span>
            </span>
            
            
                <span id="busuanzi_container_site_uv">
                &nbsp;|&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;
                    <span id="busuanzi_value_site_uv" class="white-color"></span>
            </span>
            
            <br>

            <!-- 运行天数提醒. -->
            
                <span id="sitetime"> Loading ...</span>
                <script>
                    var calcSiteTime = function () {
                        var seconds = 1000;
                        var minutes = seconds * 60;
                        var hours = minutes * 60;
                        var days = hours * 24;
                        var years = days * 365;
                        var today = new Date();
                        var startYear = "2023";
                        var startMonth = "7";
                        var startDate = "28";
                        var startHour = "0";
                        var startMinute = "0";
                        var startSecond = "0";
                        var todayYear = today.getFullYear();
                        var todayMonth = today.getMonth() + 1;
                        var todayDate = today.getDate();
                        var todayHour = today.getHours();
                        var todayMinute = today.getMinutes();
                        var todaySecond = today.getSeconds();
                        var t1 = Date.UTC(startYear, startMonth, startDate, startHour, startMinute, startSecond);
                        var t2 = Date.UTC(todayYear, todayMonth, todayDate, todayHour, todayMinute, todaySecond);
                        var diff = t2 - t1;
                        var diffYears = Math.floor(diff / years);
                        var diffDays = Math.floor((diff / days) - diffYears * 365);

                        // 区分是否有年份.
                        var language = 'zh-CN';
                        if (startYear === String(todayYear)) {
                            document.getElementById("year").innerHTML = todayYear;
                            var daysTip = 'This site has been running for ' + diffDays + ' days';
                            if (language === 'zh-CN') {
                                daysTip = '本站已运行 ' + diffDays + ' 天';
                            } else if (language === 'zh-HK') {
                                daysTip = '本站已運行 ' + diffDays + ' 天';
                            }
                            document.getElementById("sitetime").innerHTML = daysTip;
                        } else {
                            document.getElementById("year").innerHTML = startYear + " - " + todayYear;
                            var yearsAndDaysTip = 'This site has been running for ' + diffYears + ' years and '
                                + diffDays + ' days';
                            if (language === 'zh-CN') {
                                yearsAndDaysTip = '本站已运行 ' + diffYears + ' 年 ' + diffDays + ' 天';
                            } else if (language === 'zh-HK') {
                                yearsAndDaysTip = '本站已運行 ' + diffYears + ' 年 ' + diffDays + ' 天';
                            }
                            document.getElementById("sitetime").innerHTML = yearsAndDaysTip;
                        }
                    }

                    calcSiteTime();
                </script>
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/HyxiaoGe" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>



    <a href="mailto:hyxiao97@gmail.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fas fa-envelope-open"></i>
    </a>













</div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script type="text/javascript">
$(function () {
    var searchFunc = function (path, search_id, content_id) {
        'use strict';
        $.ajax({
            url: path,
            dataType: "xml",
            success: function (xmlResponse) {
                // get the contents from search data
                var datas = $("entry", xmlResponse).map(function () {
                    return {
                        title: $("title", this).text(),
                        content: $("content", this).text(),
                        url: $("url", this).text()
                    };
                }).get();
                var $input = document.getElementById(search_id);
                var $resultContent = document.getElementById(content_id);
                $input.addEventListener('input', function () {
                    var str = '<ul class=\"search-result-list\">';
                    var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                    $resultContent.innerHTML = "";
                    if (this.value.trim().length <= 0) {
                        return;
                    }
                    // perform local searching
                    datas.forEach(function (data) {
                        var isMatch = true;
                        var data_title = data.title.trim().toLowerCase();
                        var data_content = data.content.trim().replace(/<[^>]+>/g, "").toLowerCase();
                        var data_url = data.url;
                        data_url = data_url.indexOf('/') === 0 ? data.url : '/' + data_url;
                        var index_title = -1;
                        var index_content = -1;
                        var first_occur = -1;
                        // only match artiles with not empty titles and contents
                        if (data_title !== '' && data_content !== '') {
                            keywords.forEach(function (keyword, i) {
                                index_title = data_title.indexOf(keyword);
                                index_content = data_content.indexOf(keyword);
                                if (index_title < 0 && index_content < 0) {
                                    isMatch = false;
                                } else {
                                    if (index_content < 0) {
                                        index_content = 0;
                                    }
                                    if (i === 0) {
                                        first_occur = index_content;
                                    }
                                }
                            });
                        }
                        // show search results
                        if (isMatch) {
                            str += "<li><a href='" + data_url + "' class='search-result-title'>" + data_title + "</a>";
                            var content = data.content.trim().replace(/<[^>]+>/g, "");
                            if (first_occur >= 0) {
                                // cut out 100 characters
                                var start = first_occur - 20;
                                var end = first_occur + 80;
                                if (start < 0) {
                                    start = 0;
                                }
                                if (start === 0) {
                                    end = 100;
                                }
                                if (end > content.length) {
                                    end = content.length;
                                }
                                var match_content = content.substr(start, end);
                                // highlight all keywords
                                keywords.forEach(function (keyword) {
                                    var regS = new RegExp(keyword, "gi");
                                    match_content = match_content.replace(regS, "<em class=\"search-keyword\">" + keyword + "</em>");
                                });

                                str += "<p class=\"search-result\">" + match_content + "...</p>"
                            }
                            str += "</li>";
                        }
                    });
                    str += "</ul>";
                    $resultContent.innerHTML = str;
                });
            }
        });
    };

    searchFunc('/search.xml', 'searchInput', 'searchResult');
});
</script>

    <!-- 白天和黑夜主题 -->
<div class="stars-con">
    <div id="stars"></div>
    <div id="stars2"></div>
    <div id="stars3"></div>  
</div>

<script>
    function switchNightMode() {
        $('<div class="Cuteen_DarkSky"><div class="Cuteen_DarkPlanet"></div></div>').appendTo($('body')),
        setTimeout(function () {
            $('body').hasClass('DarkMode') 
            ? ($('body').removeClass('DarkMode'), localStorage.setItem('isDark', '0'), $('#sum-moon-icon').removeClass("fa-sun").addClass('fa-moon')) 
            : ($('body').addClass('DarkMode'), localStorage.setItem('isDark', '1'), $('#sum-moon-icon').addClass("fa-sun").removeClass('fa-moon')),
            
            setTimeout(function () {
            $('.Cuteen_DarkSky').fadeOut(1e3, function () {
                $(this).remove()
            })
            }, 2e3)
        })
    }
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    

    
    
    

    <!-- 雪花特效 -->
     
        <script type="text/javascript">
            // 只在桌面版网页启用特效
            var windowWidth = $(window).width();
            if (windowWidth > 768) {
                document.write('<script type="text/javascript" src="/libs/others/snow.js"><\/script>');
            }
        </script>
    

    <!-- 鼠标星星特效 -->
    

    

    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    <script src="/libs/others/clicklove.js" async="async"></script>
    
    
    <script async src="/libs/others/busuanzi.pure.mini.js"></script>
    

    

    

    <!--腾讯兔小巢-->
    
    

    

    

    
    <script src="/libs/instantpage/instantpage.js" type="module"></script>
    

</body>

</html>
