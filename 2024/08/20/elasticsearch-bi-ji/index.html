<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="ElasticSearch笔记, HyxiaoGe">
    <meta name="description" content="ElasticSearch 复习什么是ElasticSearchElasticSearch是一个基于Lucene的开源分布式搜索引擎，由Elastic公司开发。它具有以下特点：
核心特性
分布式搜索引擎：基于Lucene，提供分布式的全文搜">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="referrer" content="no-referrer-when-downgrade">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    <title>ElasticSearch笔记 | HyxiaoGe</title>
    <link rel="icon" type="image/png" href="/favicon.png">
    
    <style>
        body{
            background-image: url(http://sv6693ki5.hn-bkt.clouddn.com/background/bg.jpg);
            background-repeat:no-repeat;
            background-size: 100% 100%;
            background-attachment:fixed;
        }
    </style>



    <!-- bg-cover style     -->



<link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.min.css">
<link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
<link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
<link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
<link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
<link rel="stylesheet" type="text/css" href="/css/matery.css">
<link rel="stylesheet" type="text/css" href="/css/my.css">
<link rel="stylesheet" type="text/css" href="/css/dark.css" media="none" onload="if(media!='all')media='all'">




    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
    <link rel="stylesheet" href="/css/post.css">




    



    <script src="/libs/jquery/jquery-3.6.0.min.js"></script>

<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="HyxiaoGe" type="application/atom+xml">
<link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"><script src="/js/prism.js"></script>
<script src="/js/prism-line-numbers.min.js"></script></head>


<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">HyxiaoGe</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/contact" class="waves-effect waves-light">
      
      <i class="fas fa-comments" style="zoom: 0.6;"></i>
      
      <span>留言板</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/friends" class="waves-effect waves-light">
      
      <i class="fas fa-address-book" style="zoom: 0.6;"></i>
      
      <span>友情链接</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
  <li>
    <a href="javascript:;" class="waves-effect waves-light" onclick="switchNightMode()" title="深色/浅色模式" >
      <i id="sum-moon-icon" class="fas fa-sun" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">HyxiaoGe</div>
        <div class="logo-desc">
            
            Never really desperate, only the lost of the soul.
            
        </div>
    </div>

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/contact" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-comments"></i>
			
			留言板
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/friends" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-address-book"></i>
			
			友情链接
		</a>
          
        </li>
        
        
    </ul>
</div>


        </div>

        
    </nav>

</header>

    



<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/23.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">ElasticSearch笔记</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/ElasticSearch/">
                                <span class="chip bg-color">ElasticSearch</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fas fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/" class="post-category">
                                中间件
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2024-08-20
                </div>
                

                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-check fa-fw"></i>更新日期:&nbsp;&nbsp;
                    2025-07-27
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-file-word fa-fw"></i>文章字数:&nbsp;&nbsp;
                    6.8k
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-clock fa-fw"></i>阅读时长:&nbsp;&nbsp;
                    24 分
                </div>
                

                
                    <div id="busuanzi_container_page_pv" class="info-break-policy">
                        <i class="far fa-eye fa-fw"></i>阅读次数:&nbsp;&nbsp;
                        <span id="busuanzi_value_page_pv"></span>
                    </div>
				
            </div>
        </div>
        <hr class="clearfix">

        
        <!-- 是否加载使用自带的 prismjs. -->
        <link rel="stylesheet" href="/libs/prism/prism.min.css">
        

        

        <div class="card-content article-card-content">
            <div id="articleContent">
                <h1 id="ElasticSearch-复习"><a href="#ElasticSearch-复习" class="headerlink" title="ElasticSearch 复习"></a>ElasticSearch 复习</h1><h1 id="什么是ElasticSearch"><a href="#什么是ElasticSearch" class="headerlink" title="什么是ElasticSearch"></a>什么是ElasticSearch</h1><p>ElasticSearch是一个基于Lucene的开源分布式搜索引擎，由Elastic公司开发。它具有以下特点：</p>
<h2 id="核心特性"><a href="#核心特性" class="headerlink" title="核心特性"></a>核心特性</h2><ul>
<li><strong>分布式搜索引擎</strong>：基于Lucene，提供分布式的全文搜索功能</li>
<li><strong>RESTful API</strong>：通过HTTP使用JSON进行数据交互</li>
<li><strong>实时分析</strong>：支持实时数据分析</li>
<li><strong>高可用性</strong>：分布式架构确保无单点故障</li>
<li><strong>可扩展性</strong>：可以从小规模扩展到PB级数据</li>
</ul>
<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><ul>
<li><strong>站内搜索</strong>：网站或应用内的搜索功能</li>
<li><strong>日志分析</strong>：与Logstash和Kibana组成ELK栈，用于日志收集和分析</li>
<li><strong>数据分析</strong>：结构化数据的快速分析</li>
<li><strong>全文检索</strong>：文档、商品描述等全文内容的检索</li>
<li><strong>监控系统</strong>：用于系统性能指标的存储和分析</li>
</ul>
<h2 id="主要概念"><a href="#主要概念" class="headerlink" title="主要概念"></a>主要概念</h2><table>
<thead>
<tr>
<th>Elasticsearch 概念</th>
<th>关系型数据库 (MySQL) 类比</th>
<th>一句话解释</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Index (索引)</strong></td>
<td><code>Database</code> (数据库)</td>
<td>一个存放一类数据的“库”。</td>
</tr>
<tr>
<td><strong>Document (文档)</strong></td>
<td><code>Row</code> (一行数据)</td>
<td>一条可被搜索的记录。</td>
</tr>
<tr>
<td><strong>Field (字段)</strong></td>
<td><code>Column</code> (一列)</td>
<td>一条记录中的一个数据项。</td>
</tr>
<tr>
<td><strong>Mapping (映射)</strong></td>
<td><code>Schema</code> (表结构定义)</td>
<td>定义每个字段类型的规则。</td>
</tr>
<tr>
<td><strong>Cluster (集群)</strong></td>
<td>整个数据库服务</td>
<td>协同工作的整个 ES 服务。</td>
</tr>
<tr>
<td><strong>Node (节点)</strong></td>
<td>一个数据库服务器实例</td>
<td>集群中的一台服务器。</td>
</tr>
</tbody></table>
<p><strong>1. Document (文档)</strong></p>
<ul>
<li><strong>是什么：</strong> Elasticsearch 中最<strong>基本的、可被索引的信息单元</strong>。</li>
<li><strong>类比：</strong> 数据库表中的一<strong>行 (Row)</strong> 数据。</li>
<li><strong>解释：</strong> 它是一个用 JSON 格式表示的数据对象。你存入 ES 的每一条商品信息、每一篇博客、每一条日志，都是一个独立的文档。这是你进行搜索和分析的最小对象。</li>
</ul>
<p><strong>示例：</strong></p>
<pre class="line-numbers language-language-json"><code class="language-language-json">&#123;
  "product_id": "A-123-B-456",
  "title": "华为 Mate 60 Pro",
  "price": 6999.00
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>2. Field (字段)</strong></p>
<ul>
<li><strong>是什么：</strong> 组成文档的一个个<strong>键值对 (Key-Value Pair)</strong>。</li>
<li><strong>类比：</strong> 数据库表中的一<strong>列 (Column)</strong>。</li>
<li><strong>解释：</strong> 每个字段都有一个特定的数据类型（比如 <code>text</code> 用于全文搜索，<code>keyword</code> 用于精确值，<code>integer</code> 用于整数，<code>date</code> 用于日期等）。你在 Mapping 里定义的就是每个字段的类型和规则。</li>
</ul>
<p><strong>示例：</strong> 在上面的文档中，<code>&quot;title&quot;: &quot;华为 Mate 60 Pro&quot;</code> 就是一个字段。<code>title</code> 是字段名，<code>&quot;华为 Mate 60 Pro&quot;</code> 是字段值。</p>
<p><strong>3. Index (索引)</strong></p>
<ul>
<li><strong>是什么：</strong> 一个<strong>文档的集合</strong>。它拥有相似的特征，是 ES 中数据管理的最高层级单位。</li>
<li><strong>类比：</strong> 一个<strong>数据库 (Database)</strong>。</li>
<li><strong>解释：</strong> 比如，你可以创建一个 <code>products</code> 索引来存放所有商品文档，再创建一个 <code>logs</code> 索引来存放所有日志文档。我们所有的查询、更新、删除操作，都是针对一个或多个索引来进行的。索引的名称必须是小写。</li>
</ul>
<p><strong>4. Shard (分片)</strong></p>
<ul>
<li><strong>是什么：</strong> <strong>索引的物理拆分</strong>。每个分片都是一个功能齐全、独立的“子索引”。</li>
<li><strong>类比：</strong> 把一个巨大的数据库表<strong>水平分区 (Partitioning)</strong> 成多个小表。</li>
<li><strong>解释：</strong> 这是 Elasticsearch 实现<strong>水平扩展和高并发</strong>的核心。当一个索引的数据量太大，单个节点存不下或处理不过来时，ES 会将这个索引拆分成多个分片，并将这些分片分布到不同的<strong>节点</strong>上。这样，一个查询请求可以同时在多个分片上并行执行，极大地提升了处理能力。<ul>
<li><strong>主分片 (Primary Shard</strong>)： 索引的每个文档都只属于一个主分片。主分片的数量在索引创建时就必须固定，之后不能修改。</li>
</ul>
</li>
</ul>
<p><strong>5. Replica (副本)</strong></p>
<ul>
<li><strong>是什么：</strong> <strong>分片的一份或多份拷贝</strong>。</li>
<li><strong>类比：</strong> 数据库的<strong>主从复制</strong>中的“从库”。</li>
<li><strong>解释：</strong> 副本的主要作用有两个，我们之前也提到过：<ol>
<li><strong>高可用性 (High Availability)：</strong> 副本和它的主分片永远不会被分配在同一个节点上。如果持有主分片的节点宕机，ES 会立即将一个副本“提升”为新的主分片，保证服务不中断，数据不丢失。</li>
<li><strong>提升读性能 (Increase Read Throughput)：</strong> 查询请求（读操作）可以由主分片或任何一个副本分片来处理，从而将读请求的压力分摊到更多的节点上。</li>
</ol>
</li>
</ul>
<p><strong>6. Node (节点)</strong></p>
<ul>
<li><strong>是什么：</strong> 集群中的一个<strong>服务器实例</strong>。</li>
<li><strong>类比：</strong> 一台<strong>运行着 MySQL 实例的服务器</strong>。</li>
<li><strong>解释：</strong> 它是构成集群的单个成员，负责存储数据、参与索引和搜索。每个节点都有自己的名字，并通过 <code>cluster.name</code> 加入到指定的集群中。我们之前讨论的选举和心跳检测，都是在节点之间进行的。</li>
</ul>
<p><strong>7. Cluster (集群)</strong></p>
<ul>
<li><strong>是什么：</strong> 由<strong>一个或多个节点</strong>组成的集合。</li>
<li><strong>类比：</strong> 整个<strong>高可用的数据库集群</strong>。</li>
<li><strong>解释：</strong> 它将所有节点的数据和计算能力汇集在一起，对外提供统一的服务。你与 ES 的所有交互，都是通过集群中的某个节点进行的。集群负责管理所有索引、分片、副本的健康和分布，确保整个系统的稳定运行。</li>
</ul>
<h2 id="为什么说“索引的每个文档都只属于一个主分片。主分片的数量在索引创建时就必须固定，之后不能修改。”"><a href="#为什么说“索引的每个文档都只属于一个主分片。主分片的数量在索引创建时就必须固定，之后不能修改。”" class="headerlink" title="为什么说“索引的每个文档都只属于一个主分片。主分片的数量在索引创建时就必须固定，之后不能修改。”"></a>为什么说“索引的每个文档都只属于一个主分片。主分片的数量在索引创建时就必须固定，之后不能修改。”</h2><p><strong>我们先来理解第一部分：“索引的每个文档都只属于一个主分片”</strong></p>
<p>这句话意味着，当你保存一个文档时，Elasticsearch 必须有一个<strong>确定的、可重复的</strong>方法来决定这个文档应该存到哪个主分片里。它不能这次存到分片1，下次又存到分片2，那样就乱套了，永远也找不到数据。</p>
<p>这个决定过程，就叫做 <strong>“路由” (Routing)</strong>。</p>
<p><strong>路由是如何工作的？</strong></p>
<p>Elasticsearch 使用一个非常简单的公式：</p>
<p><code>shard_number = hash(routing_value) % number_of_primary_shards</code></p>
<p>我们来解释这个公式里的每一项：</p>
<ul>
<li><code>routing_value</code> (路由值)：默认情况下，这个值就是文档的 <strong><code>_id</code></strong>。你也可以手动指定一个值。</li>
<li><code>hash()</code>：一个哈希函数，它能把任意一个字符串（比如 <code>_id</code>）转换成一个固定的数字。</li>
<li><code>%</code>：取余数运算符。</li>
<li><code>number_of_primary_shards</code>：你创建索引时设定的主分片数量。</li>
</ul>
<p><strong>举个例子：</strong></p>
<ol>
<li>你创建了一个 <code>products</code> 索引，并设定它有 <strong>3 个主分片</strong>。</li>
<li>现在，你要存入一个新商品文档，它的 <code>_id</code> 是 <strong>“A-123-B-456”</strong>。</li>
<li>ES 会对 “A-123-B-456” 这个 <code>_id</code> 进行哈希计算，假设得到一个数字 <code>2096</code>。</li>
<li>然后，ES 计算 <code>2096 % 3</code>，结果是 <code>2</code>。</li>
<li><strong>结论：</strong> ES 就知道了，这个文档必须被存到<strong>主分片2 (Shard 2)</strong> 上。</li>
</ol>
<p>下次你根据这个 <code>_id</code> 来获取或更新这个文档时，ES 会重复一遍完全相同的计算，再次得到 <code>2</code>，然后直接去主分片2上找，而不需要去问分片0和分片1，效率极高。</p>
<hr>
<p>现在，我们来理解第二部分，也是最关键的部分：</p>
<p><strong>“主分片的数量在索引创建时就必须固定，之后不能修改”，为什么不能修改？</strong></p>
<p>我们继续用上面的例子。假设 ES 允许你把主分片数量从 <strong>3</strong> 修改成 <strong>4</strong>。</p>
<p>现在，你还是想找那个 <code>_id</code> 是 “A-123-B-456” 的文档。ES 再次执行路由计算：</p>
<ol>
<li><code>hash(&quot;A-123-B-456&quot;)</code> 的结果依然是 <code>2096</code>。</li>
<li>但是，现在主分片数量变成了 4，所以公式变成了 <code>2096 % 4</code>。</li>
<li>计算结果是 <strong><code>0</code></strong>！</li>
</ol>
<p><strong>灾难发生了！</strong></p>
<p>ES 现在认为这个文档应该在<strong>主分片0 (Shard 0)</strong> 上。但实际上，它当初被存放在了<strong>主分片2</strong>上。ES 去分片0上找，结果肯定是“找不到”。</p>
<p>如果你修改了主分片的数量，<strong>所有之前文档的路由规则就全部失效了</strong>，整个索引的数据就陷入了彻底的混乱，你将无法通过 <code>_id</code> 定位到任何一个文档。</p>
<p><strong>这就是为什么主分片数量一旦设定，就不能再修改的根本原因：为了保证路由规则的永久稳定。</strong></p>
<hr>
<p><strong>那如果我确实需要扩容怎么办？</strong></p>
<p>这是一个非常实际的问题。如果你的索引真的因为数据增长需要更多的分片来分担压力，正确的做法不是去修改现有索引，而是使用 <strong><code>Reindex API</code></strong>：</p>
<ol>
<li><strong>创建一个新的索引</strong> (比如 <code>products_v2</code>)，并为它设置一个<strong>更多的主分片数量</strong>（比如 6 个）。</li>
<li>使用 <code>Reindex API</code>，让 Elasticsearch 自动地、高效地将旧索引 (<code>products</code>) 中的所有数据读取出来，并重新写入到新索引 (<code>products_v2</code>) 中。</li>
<li>在重新写入的过程中，ES 会为每一条数据应用<strong>新的路由规则</strong>（比如 <code>% 6</code>），将它们正确地分布到新的 6 个分片中。</li>
<li>数据迁移完成后，你可以将你的应用程序指向新的索引 <code>products_v2</code>，然后安全地删除旧索引。</li>
</ol>
<h2 id="搜索的流程是什么？"><a href="#搜索的流程是什么？" class="headerlink" title="搜索的流程是什么？"></a>搜索的流程是什么？</h2><p>具体来说，它分为几个关键步骤：</p>
<ol>
<li><strong>分析查询 (Analyze Query):</strong> 首先，Elasticsearch 会使用与索引时<strong>相同的分析器 (Analyzer)</strong> 来处理用户的查询语句。例如，用户搜索“华为手机”，分析器会将其处理成词元（Tokens） <code>[&quot;华为&quot;, &quot;手机&quot;]</code>。</li>
<li><strong>查找词典 (Term Dictionary Lookup):</strong> 接着，系统会拿着处理好的每一个词元（“华为”、“手机”），去那个已经建好的、巨大的<strong>词典 (Term Dictionary)</strong> 中快速查找。</li>
<li><strong>获取文档列表 (Posting List Retrieval):</strong> 词典本身不存储文档ID，但它会告诉系统去哪里找到包含了这个词元的<strong>文档列表 (Posting List)</strong>。<ul>
<li>找到“华为” -&gt; 获取到它的文档列表，比如 <code>[Doc1, Doc5, Doc10]</code>。</li>
<li>找到“手机” -&gt; 获取到它的文档列表，比如 <code>[Doc1, Doc8, Doc10]</code>。</li>
</ul>
</li>
<li><strong>合并与计算 (Merge &amp; Calculate):</strong> 这是非常关键的一步。<ul>
<li><strong>布尔逻辑：</strong> 系统会对这些文档列表进行布尔运算。对于“华为手机”这个查询，默认是 AND 逻辑，所以它会取两个列表的<strong>交集</strong>，得到最终匹配的文档ID：<code>[Doc1, Doc10]</code>。</li>
<li><strong>相关性评分 (<code>_score</code>)：</strong> 与此同时（对于 <code>match</code> 查询），ES 还会计算每个匹配文档的<strong>相关性分数</strong>。它会考虑词频（TF，词在一个文档里出现的次数）、逆文档频率（IDF，词在所有文档中是否罕见）等因素。比如，如果 Doc1 的标题就是“华为手机”，而 Doc10 的描述里只提了一句，那么 Doc1 的得分就会更高。</li>
</ul>
</li>
<li><strong>返回结果 (Return Results):</strong> 最后，系统根据 <code>_score</code> 从高到低进行排序，然后根据这些文档 ID 去获取完整的文档内容（<code>_source</code>），并将最终排好序的结果返回给用户。</li>
</ol>
<p><strong>总结一下，更精确的说法是：</strong></p>
<ul>
<li><strong>直接修改主分片数会导致找不到文档，所以 ES 禁止这样做。</strong></li>
<li><strong>正确的扩容方式（Reindex）是一个“先建新，再搬家，最后换门牌”的过程，它通过创建全新的索引来应用新的路由规则，从而保证在任何时候都不会出现找不到文档的情况。</strong></li>
</ul>
<h2 id="倒排索引-Inverted-Index-的工作原理是什么？"><a href="#倒排索引-Inverted-Index-的工作原理是什么？" class="headerlink" title="倒排索引 (Inverted Index) 的工作原理是什么？"></a>倒排索引 (Inverted Index) 的工作原理是什么？</h2><p>倒排索引是 Elasticsearch 实现快速全文搜索的核心数据结构，它的核心思想是“词到文档”的映射。传统的关系型数据库是“文档到词”，即根据一条记录（文档）找到里面的内容（词），而倒排索引反了过来。</p>
<p>而像MySQL 和 MongoDB也是做某种“值到记录”的映射，但是跟ElasticSearch有一个根本性的区别，就是<strong>分词</strong>。</p>
<p><strong>MySQL &#x2F; MongoDB 的标准索引 (通常是 B-Tree 索引)</strong></p>
<ul>
<li><strong>索引对象：</strong> 字段的 <strong>完整值 (Entire Value)</strong>。</li>
<li><strong>工作方式：</strong> 它们为一整个字段的值创建索引。比如你有一个 <code>product_name</code> 字段，值为 “Apple iPhone 15 Pro”。MySQL 会为 <code>&quot;Apple iPhone 15 Pro&quot;</code> 这个<strong>完整的字符串</strong>建立一个索引条目，指向它所在的行。</li>
<li><strong>查询场景：</strong><ul>
<li><strong>精确匹配 (<code>=</code>)：</strong> 当你 <code>WHERE product_name = &#39;Apple iPhone 15 Pro&#39;</code> 时，索引效率极高，能瞬间定位。</li>
<li><strong>前缀匹配 (<code>LIKE &#39;Apple%&#39;</code>)：</strong> B-Tree 索引也能高效支持。</li>
<li><strong>中间或后缀匹配 (<code>LIKE &#39;%iPhone%&#39;</code>)：</strong> <strong>这正是它的痛点！</strong> 索引完全无法使用，数据库不得不进行全表扫描（或索引扫描），逐行检查 <code>product_name</code> 字段是否包含 “iPhone” 这个子字符串。数据量一大，查询就会变得极慢。</li>
</ul>
</li>
</ul>
<p><strong>ElasticSearch 的标准索引-倒排索引</strong></p>
<p>建立倒排索引主要有两个步骤：</p>
<ol>
<li><strong>分词</strong>：将文档内容拆分成一个个独立的词（term）。例如，”Elasticsearch is fast” 会被拆分成 “elasticsearch”, “is”, “fast”。</li>
<li><strong>建立映射关系</strong>：创建一个“词典（term dictionary）”，记录所有文档中出现过的词，并为每个词建立一个列表（Posting List），这个列表包含了所有出现该词的文档ID。</li>
</ol>
<p>假设我们有三个文档：</p>
<ul>
<li><strong>Doc 1:</strong> “The quick brown fox”</li>
<li><strong>Doc 2:</strong> “The lazy brown dog”</li>
<li><strong>Doc 3:</strong> “The quick brown dog and fox”</li>
</ul>
<p>经过分词和索引后，得到的倒排索引会是这样的：</p>
<table>
<thead>
<tr>
<th>词 (Term)</th>
<th>文档列表 (Posting List)</th>
</tr>
</thead>
<tbody><tr>
<td>the</td>
<td>[Doc 1, Doc 2, Doc 3]</td>
</tr>
<tr>
<td>quick</td>
<td>[Doc 1, Doc 3]</td>
</tr>
<tr>
<td>brown</td>
<td>[Doc 1, Doc 2, Doc 3]</td>
</tr>
<tr>
<td>fox</td>
<td>[Doc 1, Doc 3]</td>
</tr>
<tr>
<td>lazy</td>
<td>[Doc 2]</td>
</tr>
<tr>
<td>dog</td>
<td>[Doc 2, Doc 3]</td>
</tr>
<tr>
<td>and</td>
<td>[Doc 3]</td>
</tr>
</tbody></table>
<p><strong>追问：“那当用户搜索 <code>quick brown</code> 时，ES 是怎么做的？”</strong></p>
<ol>
<li><strong>查询词典：</strong> ES 在词典中查找 “quick”，得到文档列表 <code>[Doc 1, Doc 3]</code> <strong>(Posting List)</strong> 文件。</li>
<li><strong>查询词典：</strong> 接着查找 “brown”，得到文档列表 <code>[Doc 1, Doc 2, Doc 3]</code> <strong>(Posting List)</strong> 文件。</li>
<li><strong>合并结果：</strong> ES 对这两个列表进行交集运算，<code>[Doc 1, Doc 3]</code> 和 <code>[Doc 1, Doc 2, Doc 3]</code> 的交集是 <code>[Doc 1, Doc 3]</code>。</li>
<li><strong>返回结果：</strong> ES 就知道 Doc 1 和 Doc 3 是符合搜索条件的。</li>
</ol>
<p>因为词典通常可以被完全加载到<strong>内存</strong>中，查找速度非常快，而对文档列表的布尔运算（交、并、差）也非常高效，这就是倒排索引能实现秒级甚至毫秒级搜索的根本原因。</p>
<p>这里说的内存指的是<strong>JVM堆内存</strong>（ElasticSearch是Java应用）和<strong>操作系统文件内存</strong>。</p>
<p><strong>JVM 堆内存 (JVM Heap)</strong></p>
<ul>
<li><strong>它存放什么？</strong><ul>
<li>Elasticsearch 应用程序本身的运行时数据。</li>
<li>一些被显式缓存的数据结构，比如 <strong>Filter Cache</strong>。当你在 <code>filter</code> 上下文中使用查询时，其结果（一个包含匹配文档 ID 的位图）会被缓存到这里，以便后续相同的过滤请求能极速返回。</li>
<li>集群管理、节点通信、聚合计算的中间结果等。</li>
</ul>
</li>
</ul>
<p><strong>操作系统文件系统缓存 (OS File System Cache &#x2F; Page Cache)</strong></p>
<ul>
<li><strong>这是什么？</strong> 这是服务器物理 RAM 中，除了被 JVM 堆等应用程序占用的部分之外，由操作系统内核管理的一部分内存。</li>
<li><strong>它如何工作？</strong> 现代操作系统（如 Linux）非常智能。当你或一个程序（如 ES）读取磁盘上的文件时，操作系统会把文件的内容复制到这个缓存里。下次你再读取同一个文件时，操作系统会直接从这个高速缓存（RAM）中返回数据，而不是再次去访问慢速的磁盘。这个过程对上层应用是透明的。</li>
<li><strong>它与 ES 的关系？</strong> 这正是 Elasticsearch 和其底层库 Lucene 设计的精妙之处！Lucene 被设计成能够<strong>极度依赖和善用操作系统的文件系统缓存</strong>。倒排索引的各个部分（词典、Posting List 等）都是以特定格式的文件存储在磁盘上的。当 ES 需要查找一个词时，它会向操作系统请求读取索引文件。由于“热”的索引数据（经常被查询的数据）已经被操作系统自动缓存到了文件系统缓存中，这个“读”操作实际上是在访问内存，速度飞快。</li>
</ul>
<p>数据其实还是存在于磁盘上的，只不过是热点数据或者是说查询过的数据就缓存到了系统内存当中，所以后续的查询效率就会增加。</p>
<ul>
<li><strong>粒度精细：</strong> 缓存的是构成所有查询的基础“积木块”（词的索引信息），而不是成千上万种可能的查询组合。</li>
<li><strong>自动智能：</strong> 越是高频的词（比如 <code>我</code>、<code>爱</code>、<code>是</code>、<code>的</code>，或者某个领域的热门词汇），它们对应的索引数据就越会“常驻”在内存中，从而让整个搜索系统的平均性能得到巨大提升。</li>
</ul>
<p> 此外，Elasticsearch 全文搜索能够工作的核心匹配原则：<strong>用同样的方式处理输入和查询。</strong></p>
<p><strong>第一步：存入数据（索引时）</strong></p>
<ol>
<li><strong>收到文档：</strong> 你给 Elasticsearch 一个文档，比如 <code>&#123; &quot;title&quot;: &quot;我爱打篮球&quot; &#125;</code>。</li>
<li><strong>分析和拆解：</strong> Elasticsearch 会查看 <code>title</code> 字段的设置，找到为它配置的分析器（Analyzer）。这个分析器（比如一个标准的中文分词器）接收到 “我爱打篮球” 这个字符串。</li>
<li><strong>执行分词：</strong> 分析器将字符串拆解成一系列独立的词元（Tokens），也就是 <code>[&quot;我&quot;, &quot;爱&quot;, &quot;打&quot;, &quot;篮球&quot;]</code>。</li>
<li><strong>写入倒排索引：</strong> Elasticsearch <strong>不会</strong>在倒排索引里记录 “我爱打篮球” 这个原始字符串。它会为<strong>每一个词元</strong>建立索引，将它们分别指向这个文档的ID。最终在倒排索引里形成类似这样的记录：<ul>
<li><code>我</code> -&gt; <code>[文档ID_1]</code></li>
<li><code>爱</code> -&gt; <code>[文档ID_1]</code></li>
<li><code>打</code> -&gt; <code>[文档ID_1]</code></li>
<li><code>篮球</code> -&gt; <code>[文档ID_1]</code></li>
</ul>
</li>
</ol>
<p><strong>第二步：进行搜索（查询时）</strong></p>
<ol>
<li><strong>收到查询：</strong> 你发起一个 <code>match</code> 查询，搜索 “我爱打篮球”。</li>
<li><strong>分析和拆解（用同样的方式）：</strong> <code>match</code> 查询是一种<strong>分析查询（Analyzed Query）</strong>。这意味着 Elasticsearch 会对你的<strong>查询词</strong>也执行<strong>完全相同</strong>的分析过程。它会用 <code>title</code> 字段在索引时用的那个<strong>同一个分析器</strong>，将查询词 “我爱打篮球” 也拆解成 <code>[&quot;我&quot;, &quot;爱&quot;, &quot;打&quot;, &quot;篮球&quot;]</code>。</li>
<li><strong>匹配暗号：</strong> 现在，Elasticsearch 不再是去寻找一个叫 “我爱打篮球” 的大海捞针，而是拿着 <code>[&quot;我&quot;, &quot;爱&quot;, &quot;打&quot;, &quot;篮球&quot;]</code> 这几个拆解后的词元，去倒排索引里查找。<ul>
<li>它找到所有包含 <code>我</code> 的文档。</li>
<li>找到所有包含 <code>爱</code> 的文档。</li>
<li>…以此类推。</li>
<li>最后，它会计算哪些文档<strong>同时包含</strong>所有这些词元，并根据相关性评分，最终找到 <code>文档ID_1</code> 是最佳匹配。</li>
</ul>
</li>
</ol>
<h2 id="ES-查询参数的区别"><a href="#ES-查询参数的区别" class="headerlink" title="ES 查询参数的区别"></a>ES 查询参数的区别</h2><h3 id="match-查询：智能的全文搜索"><a href="#match-查询：智能的全文搜索" class="headerlink" title="match 查询：智能的全文搜索"></a><strong><code>match</code> 查询：智能的全文搜索</strong></h3><ul>
<li><strong>核心功能：</strong> 这是进行<strong>全文搜索</strong>的标准和首选方式。它的目标是找到“相关的”文档，并计算相关性得分 <code>_score</code>。</li>
<li><strong>是否分析查询词？</strong> <strong>是！</strong> 这是它最重要的特点。它会使用字段在 Mapping 中指定的<strong>同一个分析器</strong>来分析你的查询词。</li>
<li><strong>工作流程：</strong><ol>
<li>你搜索 <code>&quot;华为 手机&quot;</code>。</li>
<li><code>match</code> 查询拿到这个字符串，用分析器将它分词成 <code>[&quot;华为&quot;, &quot;手机&quot;]</code>。</li>
<li>然后它去倒排索引中查找同时包含这两个词元的文档。</li>
</ol>
</li>
<li><strong>适用场景：</strong> 几乎所有的<strong>搜索框</strong>功能，用户输入的自然语言搜索。最适合用于 <code>text</code> 类型的字段。</li>
<li><strong>示例：</strong></li>
</ul>
<pre class="line-numbers language-language-json"><code class="language-language-json">GET /products/_search
&#123;
  "query": &#123;
    "match": &#123;
      "title": "华为 手机" 
    &#125;
  &#125;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="term-查询：精确的、未经分析的匹配"><a href="#term-查询：精确的、未经分析的匹配" class="headerlink" title="term 查询：精确的、未经分析的匹配"></a><strong><code>term</code> 查询：精确的、未经分析的匹配</strong></h3><ul>
<li><strong>核心功能：</strong> 查找<strong>未经分析</strong>的、与你输入内容<strong>完全相等</strong>的词元。</li>
<li><strong>是否分析查询词？</strong> <strong>否！</strong> 这是它与 <code>match</code> 最根本的区别。你给它什么，它就拿着什么去倒排索引里找一模一样的词元。</li>
<li><strong>“陷阱”说明：</strong><ul>
<li>假设一个 <code>text</code> 字段的内容是 <code>&quot;Apple iPhone&quot;</code>，经过分析后，索引里存的词元是 <code>[&quot;apple&quot;, &quot;iphone&quot;]</code>（如果是keyword类型就没事了）。</li>
<li>如果你用 <code>term</code> 查询 <code>&quot;Apple iPhone&quot;</code>，<strong>绝对会失败</strong>，因为索引里根本没有 <code>&quot;Apple iPhone&quot;</code> 这个完整的词元。</li>
<li>如果你用 <code>term</code> 查询 <code>&quot;Apple&quot;</code>，也<strong>可能会失败</strong>，因为索引里的词元是小写的 <code>&quot;apple&quot;</code>。<code>term</code> 查询是区分大小写的。</li>
</ul>
</li>
<li><strong>适用场景：</strong> 它几乎<strong>不用于 <code>text</code> 字段</strong>。它被广泛用于<strong>精确值</strong>的过滤，比如 <code>keyword</code>（标签、ID）、<code>numeric</code>（数字）、<code>boolean</code>（布尔值）和 <code>date</code> 类型的字段。我们之前在 <code>filter</code> 上下文中用的就是它。</li>
<li><strong>示例：</strong></li>
</ul>
<pre class="line-numbers language-language-json"><code class="language-language-json">GET /products/_search
&#123;
  "query": &#123;
    "term": &#123;
      "tags": "卫星通话"  // 假设 tags 是 keyword 类型
    &#125;
  &#125;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="prefix-查询：“以…开头”的查询"><a href="#prefix-查询：“以…开头”的查询" class="headerlink" title="prefix 查询：“以…开头”的查询"></a><strong><code>prefix</code> 查询：“以…开头”的查询</strong></h3><ul>
<li><strong>核心功能：</strong> 查找以你指定的<strong>前缀</strong>开头的词元。</li>
<li><strong>是否分析查询词？</strong> <strong>否！</strong> 它将你输入的字符串作为一个完整的前缀。</li>
<li><strong>适用场景：</strong> 用于需要“前缀匹配”的场景，比如商品编码、URL、或者简单的输入提示。通常用于 <code>keyword</code> 类型的字段。</li>
<li><strong>示例：</strong> 查找所有 <code>product_id</code> 以 “A-123” 开头的商品。</li>
</ul>
<pre class="line-numbers language-language-json"><code class="language-language-json">GET /products/_search
&#123;
  "query": &#123;
    "prefix": &#123;
      "product_id": "A-123" 
    &#125;
  &#125;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="wildcard-查询：通配符查询"><a href="#wildcard-查询：通配符查询" class="headerlink" title="wildcard 查询：通配符查询"></a><strong><code>wildcard</code> 查询：通配符查询</strong></h3><ul>
<li><strong>核心功能：</strong> 允许你使用  (匹配任意多个字符) 和 <code>?</code> (匹配一个字符)来进行模式匹配。</li>
<li><strong>是否分析查询词？</strong> <strong>否！</strong> 它将你输入的带通配符的模式作为一个整体进行匹配。</li>
<li><strong>适用场景：</strong> 当你不确定部分内容时进行搜索。但因其性能问题，应谨慎使用。</li>
<li><strong>性能警告：</strong> 这个查询<strong>性能通常较差</strong>，因为它需要遍历词典中大量的词元来寻找匹配项。<strong>尤其要避免将通配符  放在开头</strong>，那将是性能灾难。</li>
<li><strong>示例：</strong></li>
</ul>
<pre class="line-numbers language-language-json"><code class="language-language-json">GET /products/_search
&#123;
  "query": &#123;
    "wildcard": &#123;
      "title.raw": "华? Ma*e" // 注意：通常对不分词的 .raw 字段使用
    &#125;
  &#125;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="总结对比表"><a href="#总结对比表" class="headerlink" title="总结对比表"></a><strong>总结对比表</strong></h3><table>
<thead>
<tr>
<th>查询类型</th>
<th>是否分析查询词？</th>
<th>主要用途</th>
<th>适用字段类型</th>
<th>性能</th>
</tr>
</thead>
<tbody><tr>
<td><strong><code>match</code></strong></td>
<td><strong>是</strong></td>
<td>全文搜索、相关性搜索</td>
<td><code>text</code></td>
<td><strong>高</strong></td>
</tr>
<tr>
<td><strong><code>term</code></strong></td>
<td><strong>否</strong></td>
<td>精确值过滤、完全匹配</td>
<td><code>keyword</code>, <code>numeric</code>, <code>boolean</code></td>
<td><strong>非常高</strong></td>
</tr>
<tr>
<td><strong><code>prefix</code></strong></td>
<td><strong>否</strong></td>
<td>“以…开头”的查询</td>
<td><code>keyword</code></td>
<td><strong>中等</strong></td>
</tr>
<tr>
<td><strong><code>wildcard</code></strong></td>
<td><strong>否</strong></td>
<td>通配符模式匹配</td>
<td><code>keyword</code></td>
<td><strong>低</strong>（慎用）</td>
</tr>
</tbody></table>
<h3 id="关于-prefix-和-wildcard-的区别，以及为什么-Elasticsearch-要单独提供一个-prefix-查询呢？"><a href="#关于-prefix-和-wildcard-的区别，以及为什么-Elasticsearch-要单独提供一个-prefix-查询呢？" class="headerlink" title="关于 prefix 和 wildcard 的区别，以及为什么 Elasticsearch 要单独提供一个 prefix 查询呢？"></a>关于 <code>prefix</code> 和 <code>wildcard</code> 的区别，以及为什么 Elasticsearch 要单独提供一个 <code>prefix</code> 查询呢？</h3><ul>
<li><strong><code>prefix</code>：</strong> 是专门用于<strong>前缀匹配</strong>的。</li>
<li><strong><code>wildcard</code>：</strong> 功能更强大，可以进行任意位置的<strong>模糊匹配</strong>（前缀、后缀、中间）。</li>
</ul>
<p>从<strong>功能效果</strong>上来看，使用 <code>wildcard</code> 来做前缀匹配（如 <code>&quot;abc*&quot;</code>) 和使用 <code>prefix</code> 查询（如 <code>&quot;abc&quot;</code>) 得到的结果是<strong>一模一样</strong>的。</p>
<p>那为什么我们还要用 <code>prefix</code> 呢？</p>
<p><strong>因为即使是在做完全相同的前缀匹配工作时，<code>prefix</code> 的效率也比 <code>wildcard</code> 更高。</strong></p>
<p>我们可以用一个“工具箱”的比喻来理解这个性能差异：</p>
<ul>
<li><strong><code>prefix</code> 查询</strong> 就像一把 <strong>专门用来拧六角螺丝的、尺寸完全匹配的扳手</strong>。它的设计目标就是做这一件事，因此它的结构简单、贴合度高、发力直接，效率是最高的。</li>
<li><strong><code>wildcard</code> 查询</strong> 就像一把 <strong>可以调节开口大小的活动扳手</strong>。它非常强大，不仅能拧六角螺丝，还能拧四角螺丝，甚至一些不规则形状的螺母。但是，当你用它来拧那个标准的六角螺丝时，你需要先调节开口、确保卡紧，整个操作过程和内部机械结构总会比专用扳手要稍微复杂和慢一点。</li>
</ul>
<p><strong>深入到技术层面，为什么会这样？</strong></p>
<p>Elasticsearch 底层的 Lucene 搜索引擎对这两种查询的处理方式不同：</p>
<ol>
<li><strong><code>prefix</code> 的执行路径（专用通道）</strong>：Lucene 内部的词典是按字母顺序排序的。当它收到一个 <code>prefix</code> 查询时，它有一个高度优化的“捷径”可走。它可以非常快地定位到词典中这个前缀的起始位置，然后简单地顺序向后扫描，直到不符合前缀为止。 这是一个非常直接、开销很小的操作。</li>
<li><strong><code>wildcard</code> 的执行路径（通用通道）</strong>：当 Lucene 收到一个 <code>wildcard</code> 查询时，它会先将这个通配符模式（即使是简单的 <code>&quot;abc*&quot;</code>）编译成一个更通用的内部状态机（Automaton）。 然后用这个状态机去匹配词典中的词元。虽然对于 <code>&quot;abc*&quot;</code> 这个简单的模式，最终效果和 <code>prefix</code> 一样，但启动和运行这个更“通用”和“强大”的状态机引擎，本身就会带来一点额外的计算开销。</li>
</ol>
<h2 id="query-和-filter-的区别"><a href="#query-和-filter-的区别" class="headerlink" title="query 和 filter 的区别"></a><code>query</code> 和 <code>filter</code> 的区别</h2><ol>
<li><p><strong>核心目的：相关性评分 (Scoring) vs. 是&#x2F;否 (Yes&#x2F;No)</strong></p>
<p> <strong><code>query</code> 上下文 (Query Context)</strong></p>
<ul>
<li><strong>计算相关性分数 (<code>_score</code>)</strong>：<code>query</code> 的主要任务是判断文档与查询的匹配程度，并计算出一个浮点数类型的 <code>_score</code>。分数越高，代表文档越相关。比如，搜索“篮球鞋”，标题中出现 3 次“篮球鞋”的文档会比只出现 1 次的文档得分更高。</li>
<li><strong>用于全文搜索</strong>：当你需要进行全文搜索，并希望最相关的结果排在最前面时，就应该使用 <code>query</code>。典型的例子是网站的搜索框。</li>
<li><strong>常见子句</strong>：<code>match</code>, <code>multi_match</code>, <code>query_string</code> 等。</li>
</ul>
<p> <strong><code>filter</code> 上下文 (Filter Context)</strong></p>
<ul>
<li><strong>不计算分数</strong>：<code>filter</code> 只关心“是”或“否”的匹配，它不会计算 <code>_score</code>。对于 <code>filter</code> 来说，所有匹配的文档都是平等的，没有哪个更“好”。</li>
<li><strong>用于精确匹配</strong>：当你需要根据精确值进行筛选时，就用 <code>filter</code>。例如，“产品分类是否为‘电子产品’？”、“价格是否小于 100 元？”、“创建日期是否在 2024 年之后？”。</li>
<li><strong>常见子句</strong>：<code>term</code>, <code>terms</code>, <code>range</code>, <code>exists</code>, <code>bool</code> 查询中的 <code>filter</code> 部分。</li>
</ul>
</li>
<li><p><strong>性能与缓存 (Performance &amp; Caching)</strong></p>
<p> 这是两者在技术实现上最重要的区别，直接影响查询性能。</p>
</li>
</ol>
<ul>
<li><strong><code>filter</code>：非常高效，且可以被缓存</strong><ul>
<li>由于 <code>filter</code> 只做简单的“是&#x2F;否”判断，其计算成本远低于 <code>query</code>。</li>
<li><strong>可以被高频缓存</strong>：Elasticsearch 会自动缓存 <code>filter</code> 的结果。它会生成一个包含匹配文档的位集（bitset），这个位集可以被存储在内存中（我们之前讨论的 JVM 堆内存中的 Filter Cache）。当下一个查询包含完全相同的 <code>filter</code> 条件时，ES 会直接重用这个缓存的位集，而无需再次扫描倒排索引。这使得 <code>filter</code> 的速度极快。</li>
</ul>
</li>
<li><strong><code>query</code>：计算昂贵，通常不被缓存</strong><ul>
<li>相关性分数的计算是一个复杂的过程（涉及 TF&#x2F;IDF、BM25 等算法），非常消耗 CPU 资源。</li>
<li>由于每次查询的上下文都可能不同，导致分数也不同，所以 <code>query</code> 的结果<strong>通常不会被缓存</strong>。每一次执行 <code>query</code> 都需要实时计算。</li>
</ul>
</li>
</ul>
<pre class="line-numbers language-language-json"><code class="language-language-json">GET /products/_search
&#123;
  "query": &#123;
    "bool": &#123;
      "must": [
        &#123; "match": &#123; "description": "轻便 跑鞋" &#125; &#125;  // <--- Query 上下文，需要计算相关性
      ],
      "filter": [
        &#123; "term": &#123; "brand": "Nike" &#125; &#125;,             // <--- Filter 上下文，精确匹配，可缓存
        &#123; "range": &#123; "price": &#123; "gte": 500 &#125; &#125; &#125;    // <--- Filter 上下文，范围匹配，可缓存
      ]
    &#125;
  &#125;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>简单来说，就是“<strong>先应用 filter 查询，过滤出来的结果再使用 query 查询</strong>”，它会优先执行 <code>filter</code> 部分，利用缓存快速缩小文档范围，然后再对这个小范围的文档执行 <code>query</code> 部分来进行复杂的相关性计算。</p>
<p>让我们把 <code>bool</code> 查询想象成一个可以组合不同逻辑条件的容器，它主要有**四种工具（子句）**供您使用：</p>
<ol>
<li><code>must</code> (必须匹配)</li>
<li><code>filter</code> (必须匹配，但更快)</li>
<li><code>should</code> (可以匹配)</li>
<li><code>must_not</code> (必须不匹配)</li>
</ol>
<p>您可以根据您的需求，任意选用和组合它们。下面我们看几个例子，您就会明白它的灵活性了。</p>
<hr>
<p><strong>场景1：纯粹的筛选，不需要相关性得分</strong></p>
<p><strong>需求：</strong> 找到所有品牌是 “Nike” <strong>并且</strong> 价格低于 800 元的商品。</p>
<p>在这里，我们不需要评估“有多好”，只需要一个“是&#x2F;否”的列表。所以，我们<strong>只用 <code>filter</code></strong>。</p>
<pre class="line-numbers language-language-json"><code class="language-language-json">GET /products/_search
&#123;
  "query": &#123;
    "bool": &#123;
      "filter": [
        &#123; "term":  &#123; "brand": "Nike" &#125; &#125;,
        &#123; "range": &#123; "price": &#123; "lt": 800 &#125; &#125; &#125;
      ]
    &#125;
  &#125;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>分析：</strong> 这个查询效率极高，因为它完全运行在“小筛”（Filter）模式下，可以充分利用缓存。</p>
<hr>
<p><strong>场景2：纯粹的相关性搜索</strong></p>
<p><strong>需求：</strong> 找到描述里<strong>同时包含</strong> “夏季”、“透气”和“跑鞋”的商品，并按相关性排序。</p>
<p>在这里，我们不关心硬性指标，只关心匹配度。所以，我们<strong>只用 <code>must</code></strong>。</p>
<pre class="line-numbers language-language-json"><code class="language-language-json">GET /products/_search
&#123;
  "query": &#123;
    "bool": &#123;
      "must": [
        &#123; "match": &#123; "description": "夏季" &#125; &#125;,
        &#123; "match": &#123; "description": "透气" &#125; &#125;,
        &#123; "match": &#123; "description": "跑鞋" &#125; &#125;
      ]
    &#125;
  &#125;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>分析：</strong> 这个查询会为所有匹配的文档计算一个 <code>_score</code>。</p>
<hr>
<p><strong>场景3：包含 “或者” (OR) 逻辑的搜索</strong></p>
<p><strong>需求：</strong> 寻找品牌是 “Nike” <strong>或者</strong> “Adidas” 的商品。</p>
<p>“或者”逻辑，我们使用 <strong><code>should</code></strong>。当 <code>bool</code> 查询中只有 <code>should</code> 子句时，它表示至少要满足其中一个条件。</p>
<pre class="line-numbers language-language-json"><code class="language-language-json">GET /products/_search
&#123;
  "query": &#123;
    "bool": &#123;
      "should": [
        &#123; "term": &#123; "brand": "Nike" &#125; &#125;,
        &#123; "term": &#123; "brand": "Adidas" &#125; &#125;
      ],
      "minimum_should_match": 1 // 表示should中的条件至少要满足1个
    &#125;
  &#125;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<hr>
<p><strong>场景4：包含 “不包含” (NOT) 逻辑的搜索</strong></p>
<p><strong>需求：</strong> 寻找所有 “跑鞋”，但<strong>不能是</strong> “Nike” 品牌的。</p>
<p>这里我们组合使用 <code>must</code> 和 <code>must_not</code>。</p>
<pre class="line-numbers language-language-json"><code class="language-language-json">GET /products/_search
&#123;
  "query": &#123;
    "bool": &#123;
      "must": [
        &#123; "match": &#123; "category": "跑鞋" &#125; &#125;
      ],
      "must_not": [
        &#123; "term": &#123; "brand": "Nike" &#125; &#125;
      ]
    &#125;
  &#125;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>分析：</strong> <code>must_not</code> 也运行在 filter 上下文中，因为它不计算分数，所以效率也很高。</p>
<h2 id="分析器-Analyzer-是什么"><a href="#分析器-Analyzer-是什么" class="headerlink" title="分析器 (Analyzer)是什么"></a><strong>分析器 (Analyzer)是什么</strong></h2><p><strong>工作原理</strong>：它的工作是把一段原始的、杂乱的文本，加工成一系列规整、统一的、适合搜索的最小单元——<strong>词元 (Token)</strong>。</p>
<p>固定的流程分别是：</p>
<ol>
<li><strong>字符过滤器 (Character Filter)</strong> - <em>预处理，负责“净化”</em></li>
<li><strong>分词器 (Tokenizer)</strong> - <em>核心工序，负责“拆分”</em></li>
<li><strong>词元过滤器 (Token Filter)</strong> - <em>后处理，负责“美化”</em></li>
</ol>
<p><strong>原始文本：</strong> <code>&lt;p&gt;The 2 QUICK Brown-Foxes jump over the lazy dog&#39;s bone.&lt;/p&gt;</code></p>
<hr>
<p><strong>工序 1：字符过滤器 (Character Filter)</strong></p>
<p>它的任务是在文本被拆分<strong>之前</strong>，对原始字符串进行清理和替换。你可以配置零个或多个字符过滤器。</p>
<ul>
<li><strong>常见功能：</strong><ul>
<li>去除 HTML 标签 (e.g., <code>&lt;p&gt;</code>, <code>&lt;b&gt;</code>)。</li>
<li>替换特殊字符 (e.g., <code>&amp;</code> 替换成 <code>and</code>)。</li>
<li>自定义字符映射 (e.g., 将 <code>:)</code> 替换成 <code>_happy_</code>)。</li>
</ul>
</li>
</ul>
<p><strong>经过【HTML标签去除过滤器】处理后，文本变为：</strong><code>The 2 QUICK Brown-Foxes jump over the lazy dog&#39;s bone.</code></p>
<hr>
<p><strong>工序 2：分词器 (Tokenizer)</strong></p>
<p>这是流水线的核心，它负责将经过“净化”的连续字符串，按照一定的规则<strong>拆分</strong>成独立的词元（Tokens）。<strong>一个分析器里必须有且只能有一个分词器。</strong></p>
<ul>
<li><strong>常见分词器：</strong><ul>
<li><strong>Standard Tokenizer</strong>：默认的分词器，按词的边界（如空格、标点符号）来拆分，对大多数西方语言效果很好。</li>
<li><strong>Whitespace Tokenizer</strong>：只按空格来拆分。</li>
<li><strong>Letter Tokenizer</strong>：只保留字母，遇到非字母字符就拆分。</li>
<li><strong>ik_analyzer</strong>：一个非常流行的开源中文分析器插件，需要单独安装。它基于词典进行分词，支持自定义词典和停用词典，分词粒度更灵活（有 <code>ik_smart</code> 和 <code>ik_max_word</code> 两种模式）</li>
</ul>
</li>
</ul>
<p><strong>经过【Standard Tokenizer】处理后，我们得到一个词元流：</strong><code>[ The, 2, QUICK, Brown-Foxes, jump, over, the, lazy, dog&#39;s, bone ]</code><em>(注意：<code>Brown-Foxes</code> 和 <code>dog&#39;s</code> 此时还保持原样)</em></p>
<hr>
<p><strong>工序 3：词元过滤器 (Token Filter)</strong></p>
<p>它的任务是在词元被拆分<strong>之后</strong>，对每一个词元进行修改、添加或删除。你可以配置零个或多个词元过滤器，它们会按顺序执行。</p>
<ul>
<li><strong>常见功能：</strong><ul>
<li><strong>Lowercase</strong>: 将所有词元转为小写。</li>
<li><strong>Stop Words</strong>: 移除常见的、对搜索意义不大的“停用词”（如 <code>the</code>, <code>a</code>, <code>is</code>）。</li>
<li><strong>Stemming</strong>: 将词语简化为它的词干（e.g., <code>running</code>, <code>ran</code> 都变成 <code>run</code>）。</li>
<li><strong>Synonym</strong>: 添加同义词 (e.g., 遇到 <code>quick</code>，可以额外添加一个 <code>fast</code> 词元)。</li>
</ul>
</li>
</ul>
<p><strong>让我们依次应用两个词元过滤器：</strong></p>
<ol>
<li><strong>经过【Lowercase Token Filter】处理后，词元流变为：</strong><code>[ the, 2, quick, brown-foxes, jump, over, the, lazy, dog&#39;s, bone ]</code></li>
<li><strong>经过【Stop Words Token Filter】处理后，词元流变为：</strong><code>[ 2, quick, brown-foxes, jump, over, lazy, dog&#39;s, bone ]</code><em>(两个 <code>the</code> 被移除了)</em></li>
</ol>
<p><strong>最终，被写入倒排索引的就是这个最终的词元流。</strong></p>
<h2 id="用-IK-分析器时，遇到英文会怎样？"><a href="#用-IK-分析器时，遇到英文会怎样？" class="headerlink" title="用 IK 分析器时，遇到英文会怎样？"></a>用 IK 分析器时，遇到英文会怎样？</h2><p><strong>当您为一个字段指定了 <code>ik_analyzer</code>，那么无论这个字段里是中文、英文还是数字，都会由 <code>ik_analyzer</code> 来全权处理。它不会自动切换到 <code>standard</code> 分析器。</strong></p>
<p>那么，IK 是如何处理英文的呢？</p>
<p>它的处理逻辑通常是：</p>
<ol>
<li><strong>遇到中文字符：</strong> 启用它的核心算法，根据内置的中文词典进行最大匹配或最细粒度的分词。</li>
<li><strong>遇到英文字符或数字：</strong> 它会切换到一种类似于 <code>standard</code> 分析器的模式。它会把连续的英文字母或数字识别为一个完整的词元（Token），然后根据空格和标点符号进行切分，并且通常会执行转小写的操作。</li>
</ol>
<p><strong>举个例子：</strong></p>
<p>如果你的文本是 <code>&quot;IK分析器 very good&quot;</code></p>
<p>使用 <code>ik_analyzer</code> 分析后，得到的词元流会是：<br><code>[ik, 分析器, very, good]</code></p>
<p>你可以看到，它既正确地处理了中文的“分析器”，也正确地处理了英文的“ik”、“very”和“good”。</p>
<h2 id="如何为中英文提供各自最优的分析？"><a href="#如何为中英文提供各自最优的分析？" class="headerlink" title="如何为中英文提供各自最优的分析？"></a><strong>如何为中英文提供各自最优的分析？</strong></h2><p>虽然 IK 能很好地处理英文，但它毕竟不是专门为英文设计的（比如它缺少英文中很重要的<strong>词干提取&#x2F;Stemming</strong>功能，不能把 <code>running</code> 和 <code>run</code> 视为同一个词）。</p>
<p>如果想达到极致的效果，最优的方案是使用 <strong>Multi-fields (多字段)</strong>。</p>
<p>您可以在字段映射（Mapping）中这样设置：</p>
<pre class="line-numbers language-language-json"><code class="language-language-json">PUT /my_index
&#123;
  "mappings": &#123;
    "properties": &#123;
      "title": &#123;
        "type": "text",
        "analyzer": "ik_max_word", 
        "fields": &#123;
          "english": &#123;
            "type": "text",
            "analyzer": "english" 
          &#125;
        &#125;
      &#125;
    &#125;
  &#125;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这个设置意味着：</p>
<ul>
<li><code>title</code> 字段本身使用 <code>ik_max_word</code> 分析器，最适合处理中文和基本的中英文混合搜索。</li>
<li>同时，ES 会额外创建一个 <code>title.english</code> 子字段，这个子字段专门使用 <code>english</code> 分析器（ES内置的、带词干提取等高级功能的英文分析器-<strong>Standard Tokenizer</strong>）来处理同样的内容。</li>
</ul>
<p><strong>这样使用：</strong></p>
<ul>
<li>当你的用户主要用中文搜索时，你查询 <code>title</code> 字段。</li>
<li>当你判断用户的查询是英文时，你可以去查询 <code>title.english</code> 字段。</li>
</ul>
<h2 id="索引设计讲解"><a href="#索引设计讲解" class="headerlink" title="索引设计讲解"></a>索引设计讲解</h2><p>Mapping 就是索引的“模式定义 (Schema)”，它告诉 Elasticsearch 如何处理和索引你文档中的每一个字段。一个精心设计的 Mapping 能带来诸多好处：</p>
<ul>
<li><strong>节省存储空间</strong></li>
<li><strong>提升索引和查询性能</strong></li>
<li><strong>确保查询的准确性</strong></li>
</ul>
<p><strong>场景：一个电商商品 (<code>product</code>) 文档</strong></p>
<p>我们先看一个商品文档的例子：</p>
<pre class="line-numbers language-language-json"><code class="language-language-json">&#123;
  "product_id": "A-123-B-456",
  "title": "华为 Mate 60 Pro 智能手机",
  "description": "这是华为最新款的旗舰手机，拥有强大的卫星通话功能和拍照能力。",
  "price": 6999.00,
  "tags": ["新款", "旗舰", "卫星通话"],
  "on_sale": true,
  "created_at": "2024-09-10 10:00:00",
  "stock_info": &#123;
    "warehouse_id": "WH-SH-01",
    "quantity": 500
  &#125;,
  "reviews": [
    &#123; "username": "Alice", "rating": 5, "comment": "太棒了！" &#125;,
    &#123; "username": "Bob", "rating": 4, "comment": "信号很好。" &#125;
  ]
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果让 ES 自动创建 Mapping (Dynamic Mapping)，它能工作，但绝不是最优的。下面是我们手动设计的<strong>最佳实践 Mapping</strong>：</p>
<p><strong>最佳实践 Mapping (<code>product</code> 索引)</strong></p>
<pre class="line-numbers language-language-json"><code class="language-language-json">PUT /products
&#123;
  "mappings": &#123;
    "properties": &#123;
      "product_id": &#123;
        "type": "keyword" 
      &#125;,
      "title": &#123;
        "type": "text", 
        "analyzer": "ik_max_word",
        "fields": &#123;
          "raw": &#123;
            "type": "keyword" 
          &#125;
        &#125;
      &#125;,
      "description": &#123;
        "type": "text",
        "analyzer": "ik_max_word",
        "index": true 
      &#125;,
      "price": &#123;
        "type": "scaled_float", 
        "scaling_factor": 100
      &#125;,
      "tags": &#123;
        "type": "keyword" 
      &#125;,
      "on_sale": &#123;
        "type": "boolean" 
      &#125;,
      "created_at": &#123;
        "type": "date",
        "format": "yyyy-MM-dd HH:mm:ss||epoch_millis" 
      &#125;,
      "stock_info": &#123;
        "type": "object",
        "enabled": false 
      &#125;,
      "reviews": &#123;
        "type": "nested", 
        "properties": &#123;
          "username": &#123; "type": "keyword" &#125;,
          "rating": &#123; "type": "byte" &#125;,
          "comment": &#123; "type": "text", "analyzer": "ik_smart" &#125;
        &#125;
      &#125;
    &#125;
  &#125;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>逐个解释设计思想</strong></p>
<p><strong>1. <code>product_id</code>: <code>keyword</code></strong></p>
<ul>
<li><strong>为什么是 <code>keyword</code>?</strong> ID、编码、UUID 这类数据，我们只会用它进行<strong>精确匹配</strong> (<code>term</code> 查询)，而绝不会进行分词搜索或范围查询。<code>keyword</code> 类型专门用于此目的，它将整个 “A-123-B-456” 视为一个不可分割的词元，效率远高于 <code>text</code>。即使它是纯数字，用 <code>keyword</code> 也比用 <code>integer/long</code> 更合适，因为它不参与数学计算。</li>
</ul>
<p><strong>2. <code>title</code>: <code>text</code> + <code>fields</code> (多字段)</strong></p>
<ul>
<li><strong>为什么是 <code>text</code>?</strong> <code>title</code> 是用来给用户进行全文搜索的，所以必须是 <code>text</code> 类型，并为其指定一个合适的分词器，比如 <code>ik_max_word</code>。</li>
<li>简单来说：<ul>
<li><strong>进行分词搜索</strong> (通过 <code>text</code> 类型的主字段 <code>title</code>)</li>
<li><strong>又能进行完整字符串的排序和分组</strong> (通过 <code>keyword</code> 类型的子字段 <code>title.raw</code>)</li>
</ul>
</li>
<li><strong>为什么要有 <code>fields.raw</code>?</strong> 这是一个<strong>极其重要</strong>的最佳实践。我们经常有这样的需求：对标题进行精确的<strong>聚合 (Aggregation)</strong> 或<strong>排序 (Sorting)</strong>。但 <code>text</code> 字段分词后无法完成这些操作。因此，我们通过 <code>fields</code> 为 <code>title</code> 额外创建了一个名为 <code>raw</code> 的 <code>keyword</code> 类型的子字段。这样：<ul>
<li>查 <code>title</code> 字段：进行全文搜索。</li>
<li>查 <code>title.raw</code> 字段：进行精确聚合或排序。</li>
</ul>
</li>
</ul>
<p><strong>3. <code>description</code>: <code>text</code></strong></p>
<ul>
<li><strong>为什么是 <code>text</code>?</strong> 与 <code>title</code> 类似，用于全文搜索。</li>
<li><strong>为什么要有 <code>&quot;index&quot;: true</code>?</strong> <code>index</code> 的默认值就是 <code>true</code>，这里显式写出来是为了强调。如果某个字段你永远不会用作查询条件，可以设置为 <code>false</code> 来节省空间和提高写入速度。但 <code>description</code> 通常需要被搜索，所以保持 <code>true</code>。</li>
</ul>
<p><strong>4. <code>price</code>: <code>scaled_float</code></strong></p>
<ul>
<li><strong>为什么是 <code>scaled_float</code>?</strong> 对于价格、汇率等需要精确计算的浮点数，标准的 <code>float</code> 或 <code>double</code> 类型可能会有精度问题。<code>scaled_float</code> 是处理货币的最佳选择。它通过一个 <code>scaling_factor</code> (缩放因子)，将浮点数乘以这个因子后，作为整数存储。这里 <code>100</code> 表示保留两位小数，<code>6999.00</code> 会被存储为 <code>699900</code>，完全避免了浮点数精度陷阱。</li>
</ul>
<p><strong>5. <code>tags</code>: <code>keyword</code></strong></p>
<ul>
<li><strong>为什么是 <code>keyword</code>?</strong> 标签是原子的，不可分的。我们希望对 “新款”、”旗舰” 这样的标签进行精确过滤和聚合，<code>keyword</code> 是不二之选。ES 会自动处理 <code>keyword</code> 类型的数组。</li>
</ul>
<p><strong>6. <code>on_sale</code>: <code>boolean</code></strong></p>
<ul>
<li><strong>为什么是 <code>boolean</code>?</strong> 用于表示 <code>true</code> 或 <code>false</code>，最直接，存储和过滤效率也最高。</li>
</ul>
<p><strong>7. <code>created_at</code>: <code>date</code></strong></p>
<ul>
<li><strong>为什么是 <code>date</code>?</strong> 专门用于处理日期时间，支持丰富的日期格式和强大的日期范围查询。</li>
<li><strong>为什么要有 <code>format</code>?</strong> 显式指定日期格式，可以加速日期的解析。<code>||</code> 表示“或”，意味着它既能解析 <code>&quot;yyyy-MM-dd HH:mm:ss&quot;</code> 格式的字符串，也能解析毫秒级时间戳，增强了兼容性。</li>
</ul>
<p><strong>8. <code>stock_info</code>: <code>object</code> with <code>&quot;enabled&quot;: false</code></strong></p>
<ul>
<li><strong>为什么 <code>&quot;enabled&quot;: false</code>?</strong> 这是一个<strong>关键的性能优化</strong>。假设 <code>stock_info</code> 这个对象我们<strong>只用来展示，从不按 <code>warehouse_id</code> 或 <code>quantity</code> 进行搜索</strong>。那么设置 <code>&quot;enabled&quot;: false</code> 就会告诉 ES：“不要为这个对象里的任何字段创建倒排索引”。这会节省大量的存储空间和索引开销。</li>
</ul>
<p><strong>9. <code>reviews</code>: <code>nested</code></strong></p>
<ul>
<li><p><strong>为什么是 <code>nested</code> 而不是 <code>object</code>?</strong> 这是另一个<strong>极其重要</strong>的概念。默认的 <code>object</code> 类型会“压平”数组对象，导致内部字段的关联性丢失。例如，<code>reviews</code> 数组会被压平成：</p>
<p>  <code>&quot;reviews.username&quot;: [&quot;Alice&quot;, &quot;Bob&quot;],   &quot;reviews.rating&quot;: [5, 4]</code></p>
<p>  这时如果你查询“用户是 Alice 并且评分是 4 的评论”，ES 会错误地返回 true，因为它只知道 <code>Alice</code> 和 <code>4</code> 这两个值同时存在于数组中，但不知道它们是否属于同一条评论。</p>
</li>
<li><p><strong><code>nested</code> 类型</strong>通过为每个数组元素创建独立的隐藏文档来解决这个问题，<strong>完美地保留了对象内部字段之间的关联性</strong>，让你可以进行精确的内部查询。</p>
</li>
</ul>
<h2 id="写入（索引）性能优化"><a href="#写入（索引）性能优化" class="headerlink" title="写入（索引）性能优化"></a><strong>写入（索引）性能优化</strong></h2><p>想象一个场景：您需要将一个包含 1 亿条商品数据的数据库，首次同步到 Elasticsearch 中。如果一条一条地写入，可能需要几天几夜。但通过优化，我们可能将这个时间缩短到几小时甚至几十分钟。</p>
<p>以下是提升写入性能的几个关键手段，按照重要性排序：</p>
<hr>
<p><strong>1. 使用 Bulk API (批量写入)</strong></p>
<ul>
<li><strong>这是最最最重要的一条，没有之一。</strong></li>
<li><strong>原理：</strong> 每次 HTTP 请求都有网络开销和处理开销。Bulk API 允许你在一次请求中，打包成百上千个独立的 <code>index</code>, <code>create</code>, <code>update</code>, <code>delete</code> 操作。这极大地减少了网络往返次数和请求开销，性能提升是数量级的。</li>
<li><strong>最佳实践：</strong><ul>
<li><strong>合理的批次大小：</strong> 批次不是越大越好。太大会消耗大量内存，给集群带来压力。一个好的起点是每次批量处理 <strong>1000 到 5000 个文档</strong>，或者批次的总大小在 <strong>5MB 到 15MB</strong> 之间。你需要通过实验找到最适合你数据和集群配置的“黄金尺寸”。</li>
<li><strong>并发请求：</strong> 如果机器资源充足，可以开启多个线程或进程，同时向 ES 发送 Bulk 请求。但要注意，并发数过多可能会导致 ES 拒绝请求（HTTP 429 错误），需要有相应的重试机制。</li>
</ul>
</li>
</ul>
<p><strong>2. 优化索引刷新策略 (Refresh Interval)</strong></p>
<ul>
<li><strong>原理：</strong> 之前我们提到，新写入的数据需要经过一次 <code>refresh</code> 操作才能被搜索到。默认情况下，这个操作是每秒执行一次 (<code>&quot;index.refresh_interval&quot;: &quot;1s&quot;</code>)。在海量数据写入时，每秒一次的 <code>refresh</code> 会产生大量的 I&#x2F;O 操作和新的分段（Segment），严重拖慢写入速度。</li>
<li><strong>最佳实践：</strong><ul>
<li><p>在开始批量导入数据之前，临时将刷新间隔调大，甚至禁用它。</p>
<pre class="line-numbers language-language-json"><code class="language-language-json">PUT /my_index/_settings
&#123;
  "index": &#123;
    "refresh_interval": "60s" 
  &#125;
&#125;
// 或者直接禁用
PUT /my_index/_settings
&#123;
  "index": &#123;
    "refresh_interval": "-1"
  &#125;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p><strong>数据全部写入完成后，再将刷新间隔调回默认值 <code>1s</code> 或 <code>null</code>。</strong></p>
</li>
</ul>
</li>
</ul>
<p><strong>3. 临时禁用或减少副本 (Number of Replicas)</strong></p>
<ul>
<li><strong>原理：</strong> 每写入一个文档到主分片，这个文档也必须被复制到所有的副本分片上。如果有 2 个副本，那么一次写入操作实际上会触发 3 次（1 主 + 2 副）真实的物理写入。这个复制过程是同步的，会阻塞写入请求的返回。</li>
<li><strong>最佳实践：</strong><ul>
<li><p>对于<strong>全新的索引</strong>进行首次数据导入时，可以先将副本数设置为 0。</p>
<pre class="line-numbers language-language-json"><code class="language-language-json">PUT /my_index/_settings
&#123;
  "index": &#123;
    "number_of_replicas": 0
  &#125;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p><strong>数据全部写入完成后，再将副本数调回到你期望的值</strong>（比如 1 或 2）。</p>
<pre class="line-numbers language-language-json"><code class="language-language-json">PUT /my_index/_settings
&#123;
  "index": &#123;
    "number_of_replicas": 1
  &#125;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>  ES 会在后台自动开始复制数据，这个过程不会影响你后续的操作。</p>
</li>
</ul>
</li>
</ul>
<p><strong>4. 优化磁盘 I&#x2F;O 和分段合并 (Translog &amp; Merging)</strong></p>
<ul>
<li><strong>原理：</strong> ES 为了保证数据不丢失，会先将数据写入一个叫 <code>translog</code> 的事务日志中。默认情况下，每次请求都会触发一次 <code>fsync</code>，确保 <code>translog</code> 的数据被刷到磁盘上，这个操作比较耗时。</li>
<li><strong>最佳实践（谨慎使用）：</strong><ul>
<li><p>可以将 <code>translog</code> 的刷盘策略从 <code>request</code>（每次请求）改为 <code>async</code>（异步），并增加刷盘间隔。</p>
<pre class="line-numbers language-language-json"><code class="language-language-json">PUT /my_index/_settings
&#123;
  "index": &#123;
    "translog.sync_interval": "30s",
    "translog.durability": "async"
  &#125;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p><strong>警告：</strong> 这个设置<strong>牺牲了数据的安全性</strong>。如果在异步刷盘的间隔内节点宕机，可能会丢失一部分数据。所以，它只适用于可以接受少量数据丢失的场景，比如重新导入日志数据。<strong>数据导入完成后，务必改回默认值。</strong></p>
</li>
</ul>
</li>
</ul>
<p><strong>总结：批量导入数据的黄金流程</strong></p>
<ol>
<li><strong>创建索引：</strong> 设计好 Mapping，将 <code>number_of_replicas</code> 设置为 <code>0</code>。</li>
<li><strong>修改设置：</strong> 将 <code>refresh_interval</code> 设置为 <code>1</code>。如果能接受风险，可以调整 <code>translog</code> 设置。</li>
<li><strong>执行写入：</strong> 使用多线程和 <strong>Bulk API</strong> 并发地写入数据，并监控集群状态。</li>
<li><strong>恢复设置：</strong> 数据全部写入完成后，将 <code>number_of_replicas</code> 和 <code>refresh_interval</code> 恢复到它们的正常值。</li>
</ol>
<h2 id="查询性能优化"><a href="#查询性能优化" class="headerlink" title="查询性能优化"></a>查询性能优化</h2><p><strong>1. 避免深度分页 (Deep Pagination)</strong></p>
<ul>
<li><strong>问题是什么？</strong> 在关系型数据库中，<code>LIMIT 10000, 10</code> 这样的查询可能依然很快。但在分布式系统中，这会成为一个灾难。ES 中使用 <code>from</code> 和 <code>size</code> 的分页方式，当你请求 <code>from: 10000, size: 10</code> 时，ES 必须：<ol>
<li>在<strong>每个分片</strong>上都找出前 <code>10010</code> (from + size) 个文档。</li>
<li>将所有分片的结果（比如 5 个分片 * 10010 条 &#x3D; 50050 条数据）汇集到协调节点。</li>
<li>协调节点对这 50050 条数据进行<strong>重新排序</strong>。</li>
<li>最后，从排序后的结果中，丢弃前 10000 条，返回第 10001 到 10010 条。<br>  这个过程随着 <code>from</code> 值的增大，消耗的内存和 CPU 会急剧增加，非常低效。</li>
</ol>
</li>
<li><strong>解决方案：</strong><ul>
<li><strong><code>search_after</code></strong>: 这是官方推荐的、用于深度分页或实时滚动加载的解决方案。它的工作方式是，利用上一页最后一条数据的信息来“定位”下一页的开始位置。它不关心你要跳过多少页，只关心“从哪里开始”。这使得它非常高效，因为每个分片只需要返回 <code>size</code> 数量的文档。</li>
<li><strong><code>scroll</code> API</strong>: 适用于需要处理<strong>全部</strong>查询结果的场景，比如数据导出或数据迁移。它会创建一个查询上下文的“快照”，然后你可以像迭代器一样逐批拉取数据。它不适合用于实时的用户界面分页。</li>
</ul>
</li>
</ul>
<p><strong>2. 只请求必要的字段 (<code>_source</code> Filtering)</strong></p>
<ul>
<li><p><strong>原理：</strong> 默认情况下，ES 会返回完整的 <code>_source</code> 字段，也就是你存入的整个 JSON 文档。如果你的文档很大，而前端展示只需要其中几个字段，那么传输这些不必要的数据会浪费网络带宽，并增加 ES 节点的序列化开销。</p>
</li>
<li><p><strong>最佳实践：</strong></p>
<ul>
<li><p>在查询时，明确指定你需要的字段。</p>
<pre class="line-numbers language-language-json"><code class="language-language-json">GET /products/_search
&#123;
  "_source": ["product_id", "title", "price"],
  "query": &#123; "match": &#123; "title": "手机" &#125; &#125;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>如果你完全不需要 <code>_source</code>（比如只关心聚合结果），可以将其禁用：<code>&quot;_source&quot;: false</code>。</p>
</li>
</ul>
<p>  <strong>3. 警惕脚本查询 (Script Queries)</strong></p>
<ul>
<li><strong>问题是什么？</strong> ES 允许你使用脚本（通常是 Painless 语言）来执行非常灵活的查询和聚合。但脚本是在查询时动态执行的，无法利用索引，并且通常比原生查询慢得多。</li>
<li><strong>最佳实践：</strong><ul>
<li><strong>能不用就不用。</strong> 优先考虑通过改进 Mapping 或在索引时预处理数据来满足需求。</li>
<li>如果必须用，确保脚本尽可能简单高效，并测试其性能影响。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>总结一下查询优化的核心思想：</strong></p>
<ol>
<li><strong>数据说话：</strong> 优先处理数据量大的部分。先用 <code>filter</code> 快速过滤掉绝大部分无关数据。</li>
<li><strong>避免浪费：</strong> 不做多余的工作。避免深度分页的巨大开销，只请求必要的字段。</li>
<li><strong>善用索引：</strong> 确保你的查询能最大化地利用倒排索引的优势，避免全索引扫描。</li>
</ol>
<h2 id="脑裂-Split-Brain"><a href="#脑裂-Split-Brain" class="headerlink" title="脑裂 (Split-Brain)"></a>脑裂 (Split-Brain)</h2><p>我们先用一个简单的比喻来理解。</p>
<p>想象一个公司只有一个 CEO，所有决策都由他做出，公司井井有条。</p>
<p>突然有一天，公司总部大楼中间的电话线和网络断了，把公司分成了两半（比如A座和B座）。</p>
<ul>
<li>A座的员工联系不上CEO，等了一会儿，他们以为CEO出事了，于是他们从A座的管理层里<strong>选举出了一个新的CEO</strong>。</li>
<li>与此同时，B座的员工和原来的CEO在一起，他们继续正常工作。</li>
</ul>
<p>现在，这个公司就出现了<strong>两个CEO</strong>。A座的CEO开始下达指令，B座的CEO也在下达指令，这两个指令可能是完全冲突的。整个公司陷入了混乱，决策不一，数据错乱。</p>
<p>这就是“脑裂”。</p>
<p>在 Elasticsearch 集群中，“CEO” 就是 <strong>主节点 (Master Node)</strong>。它的职责是<strong>管理集群状态，比如创建索引、分配分片、维护节点列表等</strong>。</p>
<p><strong>脑裂 (Split-Brain)</strong> 指的是，由于网络故障（比如交换机故障、网络分区），一个集群被分割成了两个或多个互不通信的“孤岛”。这时，每个“孤岛”都以为对方下线了，于是各自<strong>选举出了自己的主节点</strong>。</p>
<p>最终的结果就是，一个集群内同时存在了多个主节点。这会导致灾难性的后果：</p>
<ul>
<li><strong>数据不一致：</strong> 不同的“孤岛”接收了不同的写请求，数据开始走向不同的“分支”，造成数据丢失或冲突。</li>
<li><strong>集群状态错乱：</strong> 每个主节点都在管理分片，可能会做出完全相反的决策。</li>
<li><strong>无法恢复：</strong> 一旦网络恢复，这些拥有不同数据和状态的“孤岛”无法自动合并，需要人工干预，过程极其复杂且可能导致数据丢失。</li>
</ul>
<p><strong>如何防止脑裂？(Quorum&#x2F;法定人数)</strong></p>
<p>防止脑裂的核心思想很简单：<strong>一个决策（比如选举CEO），必须得到“大多数人”的同意才能生效。</strong></p>
<p>这个“大多数人”，在分布式系统中被称为 <strong>Quorum (法定人数)</strong>。</p>
<p>在 Elasticsearch 中，这个机制通过一个关键配置来实现。</p>
<ul>
<li><strong>ES 7.0 之前:</strong> 需要手动设置一个参数 <code>discovery.zen.minimum_master_nodes</code>。</li>
<li><strong>ES 7.0 及之后:</strong> 这个过程被极大地简化和自动化了，不再需要手动设置上述参数，但其背后的原理依然是 Quorum。</li>
</ul>
<p><strong>Quorum 的工作原理：</strong></p>
<p>选举主节点或任何一个主节点要做的决策，都必须获得超过半数的主节点候选人（master-eligible nodes）的投票。</p>
<p>这个“法定人数”的计算公式是：</p>
<p>Quorum &#x3D; (master_eligible_nodes&#x2F;2) + 1</p>
<p>假设我们有一个由 <strong>3个</strong> 有主节点资格的节点（Node-1, Node-2, Node-3）组成的集群。</p>
<p>根据公式，法定人数 Quorum &#x3D; (3 &#x2F; 2) + 1 &#x3D; 1 + 1 &#x3D; <strong>2</strong>。</p>
<p>现在，网络发生故障，Node-1 单独成为了一个“孤岛”，Node-2 和 Node-3 在另一个“孤岛”。</p>
<ul>
<li><strong>孤岛1 (Node-1):</strong> 它只有一个节点，数量 <code>1</code> 小于法定人数 <code>2</code>。因此，它<strong>无权</strong>选举新的主节点，它只能下线自己，静静地等待网络恢复。</li>
<li><strong>孤岛2 (Node-2, Node-3):</strong> 它们有两个节点，数量 <code>2</code> 等于法定人数 <code>2</code>。因此，它们<strong>有权</strong>在它们之间选举出一个新的主节点（比如 Node-2）。</li>
</ul>
<p><strong>结果：</strong> 整个集群在任何时候都只有一个合法的主节点（Node-2）。当网络恢复后，Node-1 会自动发现已经存在主节点，并作为从节点加入回去。<strong>脑裂被成功避免了！</strong></p>
<h2 id="集群引导-Cluster-Bootstrapping"><a href="#集群引导-Cluster-Bootstrapping" class="headerlink" title="集群引导 (Cluster Bootstrapping)"></a><strong>集群引导 (Cluster Bootstrapping)</strong></h2><p>“集群引导”是一个<strong>仅在集群生命周期中发生一次</strong>的初始化过程。</p>
<p><strong>这个过程是如何工作的？</strong></p>
<p>当你准备启动一个全新的、由多个节点（比如 Node-A, Node-B, Node-C）组成的 ES 集群时，你需要在<strong>每一个主节点候选人</strong>的配置文件 (<code>elasticsearch.yml</code>) 中，明确地列出这个初始“三人小组”的成员。</p>
<p>这个配置项就是：<code>cluster.initial_master_nodes</code></p>
<ol>
<li><p><strong>在 Node-A 的 <code>elasticsearch.yml</code> 中：</strong></p>
<pre class="line-numbers language-language-json"><code class="language-language-json"># ======================== Cluster ========================
# 为你的集群设置一个唯一的名字
cluster.name: my-first-cluster

# ======================== Node =========================
# 为你的节点设置一个唯一的名字
node.name: Node-A

# ======================== Network ======================
# 绑定节点的IP地址
network.host: 192.168.1.10

# ====================== Discovery ======================
# 启动新集群时的初始主节点候选人列表 (只在第一次启动时使用)
cluster.initial_master_nodes: ["Node-A", "Node-B", "Node-C"]

# 用于节点发现的种子主机列表 (集群运行起来后使用)
discovery.seed_hosts: ["192.168.1.10", "192.168.1.11", "192.168.1.12"]
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p><strong>在 Node-B 的 <code>elasticsearch.yml</code> 中：</strong></p>
<pre class="line-numbers language-language-json"><code class="language-language-json"># ======================== Cluster ========================
# 为你的集群设置一个唯一的名字
cluster.name: my-first-cluster

# ======================== Node =========================
# 为你的节点设置一个唯一的名字
node.name: Node-B

# ======================== Network ======================
# 绑定节点的IP地址
network.host: 192.168.1.11

# ====================== Discovery ======================
# 启动新集群时的初始主节点候选人列表 (只在第一次启动时使用)
cluster.initial_master_nodes: ["Node-A", "Node-B", "Node-C"]

# 用于节点发现的种子主机列表 (集群运行起来后使用)
discovery.seed_hosts: ["192.168.1.10", "192.168.1.11", "192.168.1.12"]
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p><strong>在 Node-C 的 <code>elasticsearch.yml</code> 中：</strong></p>
<pre class="line-numbers language-language-json"><code class="language-language-json"># ======================== Cluster ========================
# 为你的集群设置一个唯一的名字
cluster.name: my-first-cluster

# ======================== Node =========================
# 为你的节点设置一个唯一的名字
node.name: Node-C

# ======================== Network ======================
# 绑定节点的IP地址
network.host: 192.168.1.12

# ====================== Discovery ======================
# 启动新集群时的初始主节点候选人列表 (只在第一次启动时使用)
cluster.initial_master_nodes: ["Node-A", "Node-B", "Node-C"]

# 用于节点发现的种子主机列表 (集群运行起来后使用)
discovery.seed_hosts: ["192.168.1.10", "192.168.1.11", "192.168.1.12"]
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ol>
<p><strong>启动时会发生什么？</strong></p>
<ol>
<li>当你启动这三个节点时，它们会读取这个 <code>cluster.initial_master_nodes</code> 列表。</li>
<li>它们会尝试与列表中的其他成员建立联系。</li>
<li>一旦它们发现彼此，并且确认当前在线的节点数量达到了<strong>这个初始列表的法定人数 (Quorum)</strong>（在这个例子里是 <code>(3/2)+1=2</code>），它们就会开始进行第一次主节点选举。</li>
<li>选举成功后（比如 Node-A 当选为 Master），第一个健康的集群就正式形成了。</li>
</ol>
<p><strong>最关键的一步：“记住”与“抛弃”</strong></p>
<p>一旦集群成功形成，这个 <code>cluster.initial_master_nodes</code> 配置的<strong>历史使命就完成了</strong>。</p>
<ul>
<li><strong>“记住”：</strong> 新当选的主节点会把当前集群的成员列表（包含所有节点的详细信息）写入到<strong>集群状态 (Cluster State)</strong> 中。这个状态会被同步到所有节点上并持久化。从此以后，集群就拥有了自己“记忆”，它知道自己有哪些成员。</li>
<li><strong>“抛弃”：</strong> 从此刻起，<strong>所有节点都会忽略 <code>elasticsearch.yml</code> 文件中的 <code>cluster.initial_master_nodes</code> 配置</strong>。即使你重启节点，它也不会再去看这个配置了。它会信任持久化在自己磁盘上的那个“记忆”（集群状态），并通过 <code>discovery.seed_hosts</code> 配置去寻找已知的其他成员。</li>
</ul>
<p><strong>为什么这个机制如此重要？</strong></p>
<ol>
<li><strong>安全性：</strong> 因为这个配置只在第一次启动空集群时生效，所以它能有效地防止你意外地用它来初始化一个已经有数据的、正在运行的集群，从而避免灾难。如果你在一个已经有数据的节点上设置了这个参数并启动，ES 会报错并拒绝启动，保护你的数据。</li>
<li><strong>自动化：</strong> 它为集群提供了一个安全的“起点”。一旦集群启动并运行起来，后续的成员管理（比如节点的加入、离开、主节点重选）就都进入了我们之前讨论的全自动 Quorum 模式，不再需要人工干预。</li>
</ol>
<p><strong>后续进来新的节点会发生什么？</strong></p>
<p>后续添加的所有节点已经不属于<strong>集群引导</strong>了，而是属于<strong>节点发现</strong>。现在在已经存在的由 A、B、C 组成的集群中添加 Node-D，正确的操作如下：</p>
<ol>
<li><p><strong>准备 Node-D 的配置文件 (<code>elasticsearch.yml</code>)</strong></p>
<ul>
<li><strong>不要设置 <code>cluster.initial_master_nodes</code>！</strong> 这个参数是新集群的“出生证明”，而 Node-D 是要加入一个已经“成年”的集群，所以用不上。</li>
<li><strong>设置 <code>discovery.seed_hosts</code></strong>：这个配置项告诉 Node-D 去哪里“敲门”。你需要在这里填上现有集群中部分或全部节点的地址。</li>
<li>确保 <code>cluster.name</code> 与现有集群完全一致。</li>
</ul>
<p> <strong>Node-D 的 <code>elasticsearch.yml</code> 应该长这样：</strong></p>
<pre class="line-numbers language-language-json"><code class="language-language-json"># ======================== Cluster ========================
# 为你的集群设置一个唯一的名字
cluster.name: my-first-cluster

# ======================== Node =========================
# 为你的节点设置一个唯一的名字
node.name: Node-D

# ======================== Network ======================
# 绑定节点的IP地址
network.host: 192.168.1.13

# ====================== Discovery ======================
# 用于节点发现的种子主机列表 (集群运行起来后使用)
discovery.seed_hosts: ["192.168.1.10", "192.168.1.11", "192.168.1.12"]
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p><strong>启动 Node-D</strong></p>
<p> 直接启动 Node-D 的 Elasticsearch 服务即可。</p>
</li>
</ol>
<p><strong>启动后发生了什么？(自动的“发现”过程)</strong></p>
<ol>
<li>Node-D 启动，读取自己的配置，发现 <code>discovery.seed_hosts</code> 中有三个地址。</li>
<li>它会尝试联系这几个地址上的节点。</li>
<li>比如，它成功联系上了 Node-A（当前的主节点）。</li>
<li>Node-D 会向 Node-A 发送“加入请求”，并报上自己的集群名 (<code>cluster.name</code>)。</li>
<li>主节点 Node-A 验证通过后，会欢迎 Node-D 加入集群，并更新<strong>集群状态 (Cluster State)</strong>，将 Node-D 的信息添加进去。</li>
<li>最后，主节点 Node-A 会将这个<strong>包含了新成员的、最新的集群状态</strong>广播给集群里的所有节点（包括刚加入的 Node-D）。</li>
</ol>
<p>至此，Node-D 就成功地、平滑地成为了集群的一员。整个过程<strong>完全不需要</strong>重启或修改现有的 Node-A, B, C。</p>
<table>
<thead>
<tr>
<th>过程</th>
<th><strong>集群引导 (Bootstrapping)</strong></th>
<th><strong>节点发现 (Discovery)</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>目的</strong></td>
<td>从零开始，选举<strong>第一个</strong> Master</td>
<td>向<strong>已存在的</strong>集群添加新节点</td>
</tr>
<tr>
<td><strong>时机</strong></td>
<td>集群生命周期中<strong>仅一次</strong></td>
<td><strong>随时</strong>发生</td>
</tr>
<tr>
<td><strong>关键配置</strong></td>
<td><code>cluster.initial_master_nodes</code></td>
<td><code>discovery.seed_hosts</code></td>
</tr>
</tbody></table>
<p><strong>主节点挂掉重启的过程中，会发生什么？</strong></p>
<p><strong>会的。在 Node-A（主节点）从关闭到重启完成的这段时间里，只要剩余节点满足法定人数 (Quorum)，集群就会发起一次新的主节点选举。</strong></p>
<p>整个过程是全自动的，目的就是为了保证集群的服务尽可能不中断。我们来分解一下这个过程的时间线：</p>
<hr>
<p><strong>主节点重启期间的事件时间线</strong></p>
<p>假设我们有一个由 Node-A (Master), Node-B, Node-C 组成的健康集群。</p>
<p><strong>第 1 步：Node-A (主节点) 开始重启</strong></p>
<ul>
<li>您在 Node-A 的服务器上执行了重启命令。Node-A 进程关闭，与集群中的其他节点断开连接。</li>
</ul>
<p><strong>第 2 步：主节点故障被检测</strong></p>
<ul>
<li>集群中的其他节点（Node-B 和 Node-C）会定期地对主节点进行“心跳检测”（Health Check）。</li>
<li>当它们连续几次都无法收到来自 Node-A 的心跳时，它们就会判定：“我们的主节点失联了！”</li>
</ul>
<p><strong>第 3 步：触发新一轮选举</strong></p>
<ul>
<li>此时，Node-B 和 Node-C 发现集群中没有主节点了。</li>
<li>它们会立即检查当前还存活的、有主节点资格的节点数量是否满足<strong>法定人数 (Quorum)</strong>。<ul>
<li>在我们的例子中，总共有 3 个主节点候选人，法定人数是 <code>(3/2) + 1 = 2</code>。</li>
<li>现在还剩下 Node-B 和 Node-C，数量是 2，<strong>满足法定人数</strong>。</li>
</ul>
</li>
<li>因为满足法定人数，它们就立即开始一轮新的选举。</li>
</ul>
<p><strong>第 4 步：新的主节点诞生</strong></p>
<ul>
<li>在 Node-B 和 Node-C 之间，通过选举算法，会有一个胜出者。我们假设 <strong>Node-B 被选举为新的主节点</strong>。</li>
<li>一旦选举成功，Node-B 就会接管主节点的所有职责，开始管理整个集群。</li>
<li><strong>关键点：</strong> 从 Node-A 宕机到 Node-B 上位，这个选举过程通常非常快（秒级）。在这段短暂的“权力真空期”，集群可能无法处理需要主节点协调的写操作（比如创建索引），但对于数据的<strong>读写操作基本不受影响</strong>，因为数据分片（Data Shards）仍然在各自的数据节点上正常工作。</li>
</ul>
<p><strong>第 5 步：旧主节点 (Node-A) 重启完成并归队</strong></p>
<ul>
<li>几分钟后，Node-A 的服务器重启完毕，Elasticsearch 服务也启动了。</li>
<li>Node-A 启动后，会读取自己的 <code>discovery.seed_hosts</code> 配置，去联系它记忆中的其他集群成员。</li>
<li>它联系上了 Node-B（或者 Node-C），然后它会发现——<strong>集群已经有了一个新的主节点 (Node-B)！</strong></li>
<li>此时，Node-A <strong>不会</strong>去尝试“抢回”主节点的位置。它会很“谦虚”地认识到自己已经不是 Master 了。</li>
<li>它会向新的主节点 Node-B 发送加入请求，并作为一个<strong>普通的从节点 (Follower Node)</strong> 重新加入集群。</li>
</ul>
<p><strong>最终结果</strong></p>
<p>集群恢复到拥有 3 个健康节点的状态，只不过此时的<strong>主节点变成了 Node-B</strong>，而原来的主节点 Node-A 则变成了一个从节点。整个集群的可用性得到了保障。</p>
<p><strong>总结一下：</strong></p>
<p>这个自动的故障转移和选举机制，正是 Elasticsearch 高可用性的核心体现。只要你保证<strong>主节点候选人的数量 &gt;&#x3D; 3 （并且是奇数）</strong>，那么任何一个主节点的重启或宕机，都不会导致整个集群的瘫痪，系统具备了自我修复的能力。</p>
<hr>
<p><strong>心跳检测是谁和谁检测？</strong></p>
<p>心跳检测<strong>不是</strong>所有节点相互检测（这在大型集群中会产生巨大的网络风暴），而是一个以<strong>主节点为中心的、双向的星型检测模式</strong>。</p>
<p>我们可以把这个机制分为两种官方的叫法：</p>
<ol>
<li><strong>Follower Checks (主查从)</strong><ul>
<li><strong>谁做：</strong> 由<strong>主节点 (Master)</strong> 发起。</li>
<li><strong>做什么：</strong> 主节点会定期地、主动地去 <code>ping</code> 集群中的<strong>每一个其他节点</strong>（无论是数据节点、协调节点还是其他主节点候选人），问一声“你还在吗？”。</li>
<li><strong>目的：</strong> 确认集群的所有成员都还健康地活着并且保持在线。</li>
</ul>
</li>
<li><strong>Leader Checks (从查主)</strong><ul>
<li><strong>谁做：</strong> 由集群中<strong>所有非主节点 (Non-master Nodes)</strong> 发起。</li>
<li><strong>做什么：</strong> 每一个从节点会定期地、主动地去 <code>ping</code> <strong>当前的主节点</strong>，问一声“老板，你还在吗？”。</li>
<li><strong>目的：</strong> 确认集群的“大脑”——主节点，依然在线且能够正常响应。如果从节点发现主节点失联，它们就会发起新一轮的选举（如我们之前讨论的）。</li>
</ul>
</li>
</ol>
<p><strong>一句话总结：主节点负责“点名”检查每个手下，而每个手下也负责时刻关注“老板”的健康状况。</strong></p>
<hr>
<p><strong>问题2：如果挂掉的是普通节点（比如数据节点）呢？</strong></p>
<p>如果挂掉的是一个普通的数据节点（我们称之为 Node-X），整个过程<strong>不会发生主节点选举</strong>，而是会触发一套不同的、以<strong>数据恢复</strong>为核心的流程。</p>
<p>以下是事件的完整时间线：</p>
<p><strong>第 1 步：故障检测 (Fault Detection)</strong></p>
<ul>
<li>主节点在执行它的“Follower Check”时，发现联系不上 Node-X。在经过几次（可配置的）重试后，主节点会正式将 Node-X 标记为“已掉线 (failed)”。</li>
</ul>
<p><strong>第 2 步：更新集群状态 (Updating Cluster State)</strong></p>
<ul>
<li>主节点的第一项行动，就是立即从<strong>集群状态</strong>中移除 Node-X。</li>
<li>然后，它会把这个<strong>不包含 Node-X 的、最新的集群状态</strong>广播给所有还存活的节点。至此，整个集群达成共识：Node-X 已经不在了。</li>
</ul>
<p><strong>第 3 步：数据自动恢复 (Shard Recovery)</strong></p>
<ul>
<li>这个新的集群状态会触发自动恢复流程。主节点现在需要处理那些“无家可归”的分片（Shards），也就是之前存放在 Node-X 上的分片。</li>
<li><strong>情况A：如果 Node-X 上有主分片 (Primary Shards)</strong><ul>
<li>主节点会立即在其他存活的节点上，找到这些主分片对应的<strong>副本分片 (Replica Shards)</strong>。</li>
<li>它会从这些副本中选择一个，并将其<strong>提升 (Promote) 为新的主分片</strong>。这是一个非常快速的元数据操作，能确保索引几乎立刻恢复可写状态。</li>
</ul>
</li>
<li><strong>情况B：恢复数据冗余度</strong><ul>
<li>现在，由于 Node-X 的离开，集群中很多分片（包括被提升为新主分片的那些）的副本数量都少了一个，整个集群的数据冗余度下降了（集群健康状态会变为 <code>yellow</code>）。</li>
<li>主节点会开始在其他健康的节点上，<strong>创建新的副本分片</strong>，并从对应的主分片那里复制数据。</li>
<li>这个数据复制的过程可能会消耗一定的网络和磁盘 I&#x2F;O，但它是在后台自动进行的。</li>
</ul>
</li>
</ul>
<p><strong>第 4 步：恢复完成</strong></p>
<ul>
<li>一旦所有缺失的副本都被重新创建并同步好数据，集群的健康状态就会恢复到 <code>green</code>。</li>
</ul>
<p><strong>总结：两种故障的核心区别</strong></p>
<ul>
<li><strong>主节点故障：</strong> 核心是**“权力真空”<strong>。解决方法是</strong>重新选举 (Re-election)<strong>，恢复</strong>集群的控制能力**。</li>
<li><strong>普通节点故障：</strong> 核心是**“数据丢失风险”<strong>。解决方法是</strong>分片恢复 (Shard Recovery)<strong>，包括</strong>副本提主 (Replica Promotion)** 和 <strong>重新分配副本 (Replica Allocation)</strong>，恢复<strong>数据的完整性和冗余度</strong>。这个过程由现有的主节点全权负责，<strong>不需要重新选举</strong>。</li>
</ul>

                
            </div>
            <hr/>

            



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/ElasticSearch/">
                                    <span class="chip bg-color">ElasticSearch</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">
<div id="article-share">

    

    

</div>

                </div>
            </div>
            
        </div>
    </div>

    

    

    

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/2024/08/23/git-bi-ji/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/15.jpg" class="responsive-img" alt="Git 命令完整笔记">
                        
                        <span class="card-title">Git 命令完整笔记</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2024-08-23
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/%E7%AC%94%E8%AE%B0/" class="post-category">
                                    笔记
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/Git/">
                        <span class="chip bg-color">Git</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2024/08/10/linux-bi-ji/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/19.jpg" class="responsive-img" alt="Linux常用命令">
                        
                        <span class="card-title">Linux常用命令</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2024-08-10
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/%E7%AC%94%E8%AE%B0/" class="post-category">
                                    笔记
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/Linux/">
                        <span class="chip bg-color">Linux</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>



<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>


  <!-- 是否加载使用自带的 prismjs. -->
  <script type="text/javascript" src="/libs/prism/prism.min.js"></script>


<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>



    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget card" style="background-color: white;">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h2, h3, h4'
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>




    <footer class="page-footer bg-color">
    

    <div class="container row center-align"
         style="margin-bottom: 15px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            
                <span id="year">2023-2025</span>
            
            <a href="/about" target="_blank">Sean</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            
            <br>
            
                &nbsp;<i class="fas fa-chart-area"></i>&nbsp;站点总字数:&nbsp;<span
                        class="white-color">125.3k</span>
            
            
            
                
            
            
                <span id="busuanzi_container_site_pv">
                &nbsp;|&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;
                    <span id="busuanzi_value_site_pv" class="white-color"></span>
            </span>
            
            
                <span id="busuanzi_container_site_uv">
                &nbsp;|&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;
                    <span id="busuanzi_value_site_uv" class="white-color"></span>
            </span>
            
            <br>

            <!-- 运行天数提醒. -->
            
                <span id="sitetime"> Loading ...</span>
                <script>
                    var calcSiteTime = function () {
                        var seconds = 1000;
                        var minutes = seconds * 60;
                        var hours = minutes * 60;
                        var days = hours * 24;
                        var years = days * 365;
                        var today = new Date();
                        var startYear = "2023";
                        var startMonth = "7";
                        var startDate = "28";
                        var startHour = "0";
                        var startMinute = "0";
                        var startSecond = "0";
                        var todayYear = today.getFullYear();
                        var todayMonth = today.getMonth() + 1;
                        var todayDate = today.getDate();
                        var todayHour = today.getHours();
                        var todayMinute = today.getMinutes();
                        var todaySecond = today.getSeconds();
                        var t1 = Date.UTC(startYear, startMonth, startDate, startHour, startMinute, startSecond);
                        var t2 = Date.UTC(todayYear, todayMonth, todayDate, todayHour, todayMinute, todaySecond);
                        var diff = t2 - t1;
                        var diffYears = Math.floor(diff / years);
                        var diffDays = Math.floor((diff / days) - diffYears * 365);

                        // 区分是否有年份.
                        var language = 'zh-CN';
                        if (startYear === String(todayYear)) {
                            document.getElementById("year").innerHTML = todayYear;
                            var daysTip = 'This site has been running for ' + diffDays + ' days';
                            if (language === 'zh-CN') {
                                daysTip = '本站已运行 ' + diffDays + ' 天';
                            } else if (language === 'zh-HK') {
                                daysTip = '本站已運行 ' + diffDays + ' 天';
                            }
                            document.getElementById("sitetime").innerHTML = daysTip;
                        } else {
                            document.getElementById("year").innerHTML = startYear + " - " + todayYear;
                            var yearsAndDaysTip = 'This site has been running for ' + diffYears + ' years and '
                                + diffDays + ' days';
                            if (language === 'zh-CN') {
                                yearsAndDaysTip = '本站已运行 ' + diffYears + ' 年 ' + diffDays + ' 天';
                            } else if (language === 'zh-HK') {
                                yearsAndDaysTip = '本站已運行 ' + diffYears + ' 年 ' + diffDays + ' 天';
                            }
                            document.getElementById("sitetime").innerHTML = yearsAndDaysTip;
                        }
                    }

                    calcSiteTime();
                </script>
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/HyxiaoGe" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>



    <a href="mailto:hyxiao97@gmail.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fas fa-envelope-open"></i>
    </a>













</div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script type="text/javascript">
$(function () {
    var searchFunc = function (path, search_id, content_id) {
        'use strict';
        $.ajax({
            url: path,
            dataType: "xml",
            success: function (xmlResponse) {
                // get the contents from search data
                var datas = $("entry", xmlResponse).map(function () {
                    return {
                        title: $("title", this).text(),
                        content: $("content", this).text(),
                        url: $("url", this).text()
                    };
                }).get();
                var $input = document.getElementById(search_id);
                var $resultContent = document.getElementById(content_id);
                $input.addEventListener('input', function () {
                    var str = '<ul class=\"search-result-list\">';
                    var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                    $resultContent.innerHTML = "";
                    if (this.value.trim().length <= 0) {
                        return;
                    }
                    // perform local searching
                    datas.forEach(function (data) {
                        var isMatch = true;
                        var data_title = data.title.trim().toLowerCase();
                        var data_content = data.content.trim().replace(/<[^>]+>/g, "").toLowerCase();
                        var data_url = data.url;
                        data_url = data_url.indexOf('/') === 0 ? data.url : '/' + data_url;
                        var index_title = -1;
                        var index_content = -1;
                        var first_occur = -1;
                        // only match artiles with not empty titles and contents
                        if (data_title !== '' && data_content !== '') {
                            keywords.forEach(function (keyword, i) {
                                index_title = data_title.indexOf(keyword);
                                index_content = data_content.indexOf(keyword);
                                if (index_title < 0 && index_content < 0) {
                                    isMatch = false;
                                } else {
                                    if (index_content < 0) {
                                        index_content = 0;
                                    }
                                    if (i === 0) {
                                        first_occur = index_content;
                                    }
                                }
                            });
                        }
                        // show search results
                        if (isMatch) {
                            str += "<li><a href='" + data_url + "' class='search-result-title'>" + data_title + "</a>";
                            var content = data.content.trim().replace(/<[^>]+>/g, "");
                            if (first_occur >= 0) {
                                // cut out 100 characters
                                var start = first_occur - 20;
                                var end = first_occur + 80;
                                if (start < 0) {
                                    start = 0;
                                }
                                if (start === 0) {
                                    end = 100;
                                }
                                if (end > content.length) {
                                    end = content.length;
                                }
                                var match_content = content.substr(start, end);
                                // highlight all keywords
                                keywords.forEach(function (keyword) {
                                    var regS = new RegExp(keyword, "gi");
                                    match_content = match_content.replace(regS, "<em class=\"search-keyword\">" + keyword + "</em>");
                                });

                                str += "<p class=\"search-result\">" + match_content + "...</p>"
                            }
                            str += "</li>";
                        }
                    });
                    str += "</ul>";
                    $resultContent.innerHTML = str;
                });
            }
        });
    };

    searchFunc('/search.xml', 'searchInput', 'searchResult');
});
</script>

    <!-- 白天和黑夜主题 -->
<div class="stars-con">
    <div id="stars"></div>
    <div id="stars2"></div>
    <div id="stars3"></div>  
</div>

<script>
    function switchNightMode() {
        $('<div class="Cuteen_DarkSky"><div class="Cuteen_DarkPlanet"></div></div>').appendTo($('body')),
        setTimeout(function () {
            $('body').hasClass('DarkMode') 
            ? ($('body').removeClass('DarkMode'), localStorage.setItem('isDark', '0'), $('#sum-moon-icon').removeClass("fa-sun").addClass('fa-moon')) 
            : ($('body').addClass('DarkMode'), localStorage.setItem('isDark', '1'), $('#sum-moon-icon').addClass("fa-sun").removeClass('fa-moon')),
            
            setTimeout(function () {
            $('.Cuteen_DarkSky').fadeOut(1e3, function () {
                $(this).remove()
            })
            }, 2e3)
        })
    }
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    

    
    
    

    <!-- 雪花特效 -->
     
        <script type="text/javascript">
            // 只在桌面版网页启用特效
            var windowWidth = $(window).width();
            if (windowWidth > 768) {
                document.write('<script type="text/javascript" src="/libs/others/snow.js"><\/script>');
            }
        </script>
    

    <!-- 鼠标星星特效 -->
    

    

    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    <script src="/libs/others/clicklove.js" async="async"></script>
    
    
    <script async src="/libs/others/busuanzi.pure.mini.js"></script>
    

    

    

    <!--腾讯兔小巢-->
    
    

    

    

    
    <script src="/libs/instantpage/instantpage.js" type="module"></script>
    

</body>

</html>
